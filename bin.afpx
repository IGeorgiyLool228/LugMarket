AFP_____data/errorlog.log 7429 14:58:04: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:04: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:06: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:06: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:07: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:07: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:09: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:09: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:10: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:10: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:12: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:12: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:13: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:13: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:15: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:15: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:16: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:16: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:18: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:18: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:19: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:19: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:21: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:21: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:22: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:22: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:24: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:24: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:25: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:25: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:27: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:27: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:28: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:28: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:30: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:30: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:31: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:32: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:33: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:33: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:34: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:35: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:36: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:36: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:38: thread error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
14:58:38: application error: /system/bin/shell.lua:50: connect the wired modem!
stack traceback:
	[C]: in function 'error'
	/system/bin/shell.lua:50: in main chunk
data/registry.dat 231 {primaryScreen="55eb1683-29c2-4ab0-88ca-b46167a5af3c",soundEnable=false,fullBeepDisable=false,disableRecovery=true,diskSound=false,shadowType="advanced",lowPowerSound=false,shadowMode="full",bufferType="hardware",powerMode="power"}init.lua 2727 --likeOS core
local bootfs = component.proxy(computer.getBootAddress())
local tmpfs = component.proxy(computer.tmpAddress())

local function readFile(fs, path)
    local file, err = fs.open(path, "rb")
    if not file then return nil, err end

    local buffer = ""
    repeat
        local data = fs.read(file, math.huge)
        buffer = buffer .. (data or "")
    until not data
    fs.close(file)

    return buffer
end

local function loadfile(fs, path, mode, env)
    local data, err = readFile(fs, path)
    if not data then return nil, err end
    return load(data, "=" .. path, mode or "bt", env or _G)
end

local function unserialize(str)
    local code = load("return " .. str, "=unserialize", "t", {math={huge=math.huge}})
    if code then
        local result = {pcall(code)}
        if result[1] and type(result[2]) == "table" then
            return result[2]
        end
    end
end

--------------------------------------------

local bootfile = "/system/core/bootloader.lua"
local bootproxy = bootfs
local bootargs = {}

--------------------------------------------

local bootloaderSettingsPath = "/bootloader"
local bootloaderSettingsPath_bootfile = bootloaderSettingsPath .. "/bootfile"
local bootloaderSettingsPath_bootaddr = bootloaderSettingsPath .. "/bootaddr"
local bootloaderSettingsPath_bootargs = bootloaderSettingsPath .. "/bootargs"

-------------------------------------------- launch the bootmanager (if any)

local bootmanagerfile = "/bootmanager/main.lua"
if bootfs.exists(bootmanagerfile) and not tmpfs.exists(bootloaderSettingsPath .. "/nomgr") then
    assert(loadfile(bootfs, bootmanagerfile))()
end

--------------------------------------------

if tmpfs.exists(bootloaderSettingsPath_bootfile) then
    bootfile = assert(readFile(tmpfs, bootloaderSettingsPath_bootfile))
end

if tmpfs.exists(bootloaderSettingsPath_bootaddr) then
    local bootaddr = assert(readFile(tmpfs, bootloaderSettingsPath_bootaddr))
    computer.getBootAddress = function()
        return bootaddr
    end
    bootproxy = assert(component.proxy(bootaddr))
end

if tmpfs.exists(bootloaderSettingsPath_bootargs) then
    bootargs = unserialize(assert(readFile(tmpfs, bootloaderSettingsPath_bootargs)))
end

tmpfs.remove(bootloaderSettingsPath)

--------------------------------------------

if bootproxy.exists(bootfile) then
    assert(load(assert(readFile(bootproxy, bootfile)), "=" .. bootfile, nil, _ENV))(table.unpack(bootargs))
else
    local lowLevelInitializer = "/likeOS_startup.lua" --может использоваться для запуска обновления системы
    if bootproxy.exists(lowLevelInitializer) then
        assert(loadfile(bootproxy, lowLevelInitializer))()
    end
endsystem/LICENSE 1210 This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>system/bin/LUGMarket.app/default.dat 356 {
    version = 1,
    users = {
        rootmaster = {
            0,
            false,
            true,
            true,
            false
        },
        LuaGame = {
            0,
            false,
            true,
            true,
            false
        }
    },
    items = {
        categories = {
        }
    }
}system/bin/LUGMarket.app/eula.txt 1230 |0x1e3de8|---=== Пользовательское соглашение ===---|0xffffff|
Добро пожаловать в |0x01b799|LUG Market|0xffffff|!

Баланс магазина - это вымышленная валюта (|0x1cba0b|Доллары $|0xffffff|)
Вы можете пополнить баланс игровыми ресурсами или серверными Эмеральдами

Вы можете быть заблокированы в нашем магазине, в случае если!
1. Попытаетесь нарушить работу магазина в корыстных целях т.е, умышленно
2. Найдёте баг, и будете использовать его для обогащения
3. Личное оскорбление владельцев |0x01b799|LUG Market|0xffffff| или варпа

В случае блокировки аккаунта в магазине, остаток баланса будет возвращён,
Углём и/или воском по формуле (Ваш баланс/цена = (Угля или воска))

|0xdbd904|Приобритённые товары в магазине обратно не принимаются.system/bin/LUGMarket.app/exit.lua 88 local graphic = require("graphic")
graphic.cursorColor = nil
graphic.selectColor = nilsystem/bin/LUGMarket.app/icon.t2p 162          u▄u▄u▄u▄u▄u▄U▄ w▄w▄w▄w▄w▄w▄U▄ w▄w▄w▄w▄w▄w▄U▄ W▄W▄W▄W▄W▄W▄U▄system/bin/LUGMarket.app/logo.t2p 6475 P                                                                                                                                                                           ╥               ╥           ╥       ╔ ═ ═ ╗             ╥           ╥         ╔ ═ ╗         ╔ ═ ═ ═ ═ ╗     ╥       ╔ ═     ╔ ═ ═ ═ ═     ╞ ═ ═ ═ ╦ ═ ═ ═ ╡     ║               ║           ║     ╔ ╝     ╚ ╗           ╠ ╗       ╔ ╣       ╔ ╝   ╚ ╗       ║         ║     ║   ╔ ═ ╝       ║                     ║             ║               ║           ║     ║         ╨           ║ ╚ ╗   ╔ ╝ ║       ║       ║       ║         ║     ╠ ═ ╝           ║                     ║             ║               ║           ║     ║     ╞ ═ ╗           ║   ╚ ═ ╝   ║     ╔ ╩ ═ ═ ═ ╩ ╗     ╠ ═ ╦ ═ ═ ╝     ╠ ═ ╗           ╠ ═ ═ ═ ═             ║             ║               ╚ ╗       ╔ ╝     ╚ ╗     ╔ ╝           ║           ║     ║           ║     ║   ╚ ═ ╗       ║   ╚ ═ ╗       ║                     ║             ╚ ═ ═ ═ ═ ═       ╚ ═ ═ ═ ╝         ╚ ═ ═ ╝             ╨           ╨     ╨           ╨     ╨       ╚ ═     ╨       ╚ ═     ╚ ═ ═ ═ ═             ╨                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Для Начала Работы, Встаньте на   P I M                                                                                                                                                                                                                                                                                                                                                                                                                                                D $▄$▄$▄$▄$▄$▄$▄$▄$▄$▄$▄$▄D                                                                                                                                     D " "           D                                                                                                                                     D " "           D                                                                                                                                     D " "           D                                                                                                                                     D " " " " " " " " " " " " D                                                                                                                                     D " " " " " " " " " " " " D                                                                                                                                     D B▄B▄B▄B▄B▄B▄B▄B▄B▄B▄B▄B▄D                                                                                                                                                                                                                                       По Вопросам Пишите Владельцу: LuaGame (игра) | thekilohertz_40460 (discord)                                                                                                                                                                                  Автор Програмного Обеспечения: rootmaster (игра) | smlogic (discord)                                                                                                                                                                            system/bin/LUGMarket.app/main.lua 56578 local gui_container = require("gui_container")
local serialization = require("serialization")
local component = require("component")
local graphic = require("graphic")
local system = require("system")
local paths = require("paths")
local event = require("event")
local uix = require("uix")
local registry = require("registry")
local unicode = require("unicode")
local cache = require("cache")
local format = require("format")
local gui = require("gui")
local computer = require("computer")
local sound = require("sound")
local thread = require("thread")
local clipboard = require("clipboard")
local parser = require("parser")
local fs = require("filesystem")

--damage=0.0
--text="????????? ?????"
--name="minecraft:hardened_clay"
--nbt_check=true
--price
--sellPrice
--need

local appFolder = paths.path(system.getSelfScriptPath())
local logoPath = paths.concat(appFolder, "logo.t2p")

local defaultAutocraftCount = 0

local config = _G.lugmarketConfig or error("please run the shell.lua")
local port = _G.lugmarketPort

local function configSave()
    config.data.version = config.data.version + 1
    config.save()
    _G.lugmarketSend()
    _G.syncCheck()
end

local pim = component.pim or error("connect pim!")
local me = component.me_interface or component.me_controller or error("connect me_interface or me_controller via adapter!")
local modem = component.modem
local openperipheral_selector = component.openperipheral_selector

local screen = ...
local rx, ry = graphic.getResolution(screen)
local window = graphic.createWindow(screen, 1, 1, rx, ry, true)

local raw_colors = assert(serialization.load(paths.concat(appFolder, "palette.plt")))
local colors = {
    white = raw_colors[1],
    gray = {table.unpack(raw_colors, 2, 6)},
    black = raw_colors[7],

    red = raw_colors[8],
    lime = raw_colors[9],
    blue = raw_colors[10],
    yellow = raw_colors[11],
    lightBlue = raw_colors[12],
    purple = raw_colors[13],
    cyan = raw_colors[14],
    orange = raw_colors[15],
    gray4a = raw_colors[16],
}
graphic.cursorColor = colors.purple
graphic.selectColor = colors.cyan

--для того чтобы все стандартные UI использовали правильную палитру
for key, value in pairs(colors) do
    gui_container.colors[key] = value
end
gui_container.colors.gray = colors.gray[3]
gui_container.colors.lightGray = colors.gray[1]

local numbersWhiteList = {}
local numbersWhiteListWithDot = {["."] = true}
for i = 0, 9 do
    local chr = tostring(i)
    numbersWhiteList[chr] = true
    numbersWhiteListWithDot[chr] = true
end

local function doButton(butt)
    butt.back2 = nil
    butt.fore2 = nil
    butt.autoRelease = nil
    return butt
end

--------------------------------------------------

local currentUser, currentNick, lastUser

local categoryPos   = 3
local namePos       = 3 + 16
local pricePos   = 5 + 16 + 24
local sellPricePos  = 5 + 16 + 24
local invPos  = 3 + 16 + 24 + 16 + 4
local storagePos  = 0 + 16 + 24 + 16 + 8

local pricePos2   = 3 + 16 + 24
local sellPricePos2  = 2 + 16 + 24 + 8

local function escape_pattern(text)
    return text:gsub("([^%w])", "%%%1")
end

local function unicodeFind(s, pattern, init, plain)
    if init then
        if init < 0 then
            init = -#unicode.sub(s, init)
        elseif init > 0 then
            init = #unicode.sub(s, 1, init - 1) + 1
        end
    end
    
    local a, b = s:find(pattern, init, plain)
    
    if a then
        local ap, bp = s:sub(1, a - 1), s:sub(a,b)
        a = unicode.len(ap) + 1
        b = a + unicode.len(bp) - 1

        return a, b
    else
        return a
    end
end

local function rusInput(screen, action, cx, cy, str, hidden, backgroundColor, default, disableStartSound, whitelist)
    local colors = gui_container.colors
    local gpu = graphic.findGpu(screen)

    if not cx or not cy then
        cx, cy = gpu.getResolution()
        cx = cx / 2
        cy = cy / 2
        cx = cx - 24
        cy = cy - 4
        cx = math.floor(cx) + 1
        cy = math.floor(cy) + 1
    end

    local offset = unicode.len(action) - 1

    local window = graphic.createWindow(screen, cx, cy, 48, 8, true)

    --window:fill(2, 2, window.sizeX, window.sizeY, colors.gray, 0, " ")
    local noShadow = gui.shadow(gpu, window.x, window.y, window.sizeX, window.sizeY)
    window:clear(backgroundColor or colors.lightGray)

    local pos = math.round((window.sizeX / 2) - (unicode.wlen(str) / 2)) + 1
    window:fill(1, 1, window.sizeX, 1, colors.gray, 0, " ")
    window:set(pos, 1, colors.gray, colors.white, str)

    window:set(48 - 3 - offset, 7, colors.lightBlue, colors.white, " " .. action .. " ")
    window:set(2, 7, colors.red, colors.white, " Отмена ")

    local reader = window:read(2, 3, window.sizeX - 2, colors.gray, colors.white, nil, hidden, default)
    reader.setMaxStringLen(32)
    if whitelist then
        reader.setWhitelist(whitelist)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable and not disableStartSound then
        computer.beep(2000)
        computer.beep(1500)
    end

    local function drawOk()
        window:set(48 - 3 - offset, 7, colors.blue, colors.white, " " .. action .. " ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    local function drawCancel()
        window:set(2, 7, colors.orange, colors.white, " Отмена ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    while not canStopWhile() do
        local eventData = {event.pull(0.1)}
        local windowEventData = window:uploadEvent(eventData)
        local out = reader.uploadEvent(eventData)
        if out then
            if out == true then
                drawCancel()
                noShadow()
                return false
            end
            drawOk()
            noShadow()
            return out
        end
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (48 - 3 - offset - 1) and windowEventData[3] <= ((48 - 5) + 4) then
                drawOk()
                noShadow()
                return reader.getBuffer()
            elseif windowEventData[4] == 7 and windowEventData[3] >= 2 and windowEventData[3] <= (2 + 7) then
                drawCancel()
                noShadow()
                return false
            end
        end
    end
    return false
end

local function nRusInput(screen, action, cx, cy, str, hidden, backgroundColor, default, disableStartSound, item, sellMode, whitelist) --обеспечивает работу item selector
    local colors = gui_container.colors
    local gpu = graphic.findGpu(screen)

    if not cx or not cy then
        cx, cy = gpu.getResolution()
        cx = cx / 2
        cy = cy / 2
        cx = cx - 24
        cy = cy - 4
        cx = math.floor(cx) + 1
        cy = math.floor(cy) + 1
    end

    local offset = unicode.len(action) - 1

    local window = graphic.createWindow(screen, cx, cy, 48, 8, true)

    --window:fill(2, 2, window.sizeX, window.sizeY, colors.gray, 0, " ")
    local noShadow = gui.shadow(gpu, window.x, window.y, window.sizeX, window.sizeY)
    window:clear(backgroundColor or colors.lightGray)

    local pos = math.round((window.sizeX / 2) - (unicode.wlen(str) / 2)) + 1
    window:fill(1, 1, window.sizeX, 1, colors.gray, 0, " ")
    window:set(pos, 1, colors.gray, colors.white, str)

    window:set(48 - 3 - offset, 7, colors.lightBlue, colors.white, " " .. action .. " ")
    window:set(2, 7, colors.red, colors.white, " Отмена ")

    local reader = window:read(2, 3, window.sizeX - 2, colors.gray, colors.white, nil, hidden, default)
    reader.setMaxStringLen(32)
    if whitelist then
        reader.setWhitelist(whitelist)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable and not disableStartSound then
        computer.beep(2000)
        computer.beep(1500)
    end

    local function stopSelect()
        if openperipheral_selector and item then
            pcall(openperipheral_selector.setSlot, 1)
        end
    end

    local function drawOk()
        stopSelect()

        window:set(48 - 3 - offset, 7, colors.blue, colors.white, " " .. action .. " ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    local function drawCancel()
        stopSelect()

        window:set(2, 7, colors.orange, colors.white, " Отмена ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    local function updateInfo()
        local value = sellMode and item[6] or item[5]
        local mulValue = "unknown"
        local inputValue = tonumber(reader.getBuffer())
        if inputValue then
            mulValue = tostring((value or 0) * inputValue)
        end
        local canValue = sellMode and getUserItemCount(item) or math.min(getStorageItemCount(item), math.floor(currentUser[1] / (value or 1)))

        window:fill(2, 4, 44, 3, colors.lightGray, 0, " ")
        if sellMode then
            mulValue = unicode.sub(mulValue, 1, 12)
            window:set(2, 4, colors.lightGray, colors.black, "Получите за штуку               : " .. value or "unknown")
            window:set(2, 5, colors.lightGray, colors.black, "Получите за введенное количество: " .. mulValue)
            window:set(2, 6, colors.lightGray, colors.black, "Можете Продать                  : " .. canValue)
        else
            mulValue = unicode.sub(mulValue, 1, 24)
            window:set(2, 4, colors.lightGray, colors.black, "Цена за штуку: " .. (value or "unknown"))
            window:set(2, 5, colors.lightGray, colors.black, "Цена за все  : " .. mulValue)
            window:set(2, 6, colors.lightGray, colors.black, "Можете купить: " .. canValue)
        end
    end

    if openperipheral_selector and item then
        if not item.dmg then
            pcall(openperipheral_selector.setSlot, 1, {id = item[3], dmg = item[1]})
            if sellMode ~= nil then
                updateInfo()
            end
        else
            pcall(openperipheral_selector.setSlot, 1, item)
        end
    end

    while not canStopWhile() do
        local eventData = {event.pull(0.1)}
        local windowEventData = window:uploadEvent(eventData)
        local out = reader.uploadEvent(eventData)

        if not item.dmg and sellMode ~= nil then
            updateInfo()
        end

        if out then
            if out == true then
                drawCancel()
                noShadow()
                return false
            end
            drawOk()
            noShadow()
            return out
        end
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (48 - 3 - offset - 1) and windowEventData[3] <= ((48 - 5) + 4) then
                drawOk()
                noShadow()
                return reader.getBuffer()
            elseif windowEventData[4] == 7 and windowEventData[3] >= 2 and windowEventData[3] <= (2 + 7) then
                drawCancel()
                noShadow()
                return false
            end
        end
    end
    
    stopSelect()

    return false
end

local function smallWindow(screen, cx, cy, str, backgroundColor, icon)
    local sx = 48
    local sy = 8

    local colors = gui_container.colors
    --◢▲◣▲▴▴
    local gpu = graphic.findGpu(screen)

    if not cx or not cy then
        cx, cy = gpu.getResolution()
        cx = cx / 2
        cy = cy / 2
        cx = cx - 24
        cy = cy - 4
        cx = math.floor(cx) + 1
        cy = math.floor(cy) + 1
    end

    local window = graphic.createWindow(screen, cx, cy, 48, 8, true)

    local color = backgroundColor or colors.lightGray

    --window:fill(2, 2, window.sizeX, window.sizeY, colors.gray, 0, " ")
    local noShadow = gui.shadow(gpu, window.x, window.y, window.sizeX, window.sizeY)
    window:clear(color)

    local textColor = colors.white
    if color == textColor then
        textColor = colors.black
    end

    for i, v in ipairs(parser.parseTraceback(str, sx - 9, sy - 3)) do
        window:set(8, i + 1, color, textColor, v)
    end

    if icon then
        icon(window, color)
    end

    return window, noShadow
end

local function runYesno(screen, cx, cy, str, backgroundColor)
    local colors = gui_container.colors

    local window, noShadow = smallWindow(screen, cx, cy, str, backgroundColor, function (window, color)
        window:set(2, 2, color, colors.green, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 3, color, colors.green, " ◢█◣ ")
        window:set(2, 4, color, colors.green, "◢███◣")
        window:set(4, 3, colors.green, colors.white, "?")
    end)

    window:set(48 - 4, 7, colors.lime, colors.white, " Да ")
    window:set(2, 7, colors.red, colors.white, " Нет ")

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        computer.beep(2000)
    end

    local function drawYes()
        window:set(48 - 4, 7, colors.green, colors.white, " Да ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    while not canStopWhile() do
        local eventData = {computer.pullSignal(0.1)}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (48 - 5) and windowEventData[3] <= ((48 - 5) + 4) then
                drawYes()
                noShadow()
                return true
            elseif windowEventData[4] == 7 and windowEventData[3] >= 2 and windowEventData[3] <= (2 + 4) then
                window:set(2, 7, colors.brown, colors.white, " Нет ")
                graphic.forceUpdate(screen)
                event.sleep(0.1)
                noShadow()
                return false
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            noShadow()
            return true
        end
    end
end

local function rusWarn(screen, cx, cy, str, backgroundColor)
    local colors = gui_container.colors
    local window, noShadow = smallWindow(screen, cx, cy, str, backgroundColor, function (window, color)
        window:set(2, 2, color, colors.yellow, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 3, color, colors.yellow, " ◢█◣ ")
        window:set(2, 4, color, colors.yellow, "◢███◣")
        window:set(4, 3, colors.yellow, colors.white, "!")
    end)

    window:set(48 - 8, 7, colors.lightBlue, colors.white, " Хорошо ")
    local function drawYes()
        window:set(48 - 8, 7, colors.blue, colors.white, " Хорошо ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        sound.warn()
    end

    while not canStopWhile() do
        local eventData = {computer.pullSignal(0.1)}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] >= (48 - 8) and windowEventData[3] <= ((48 - 5) + 4) then
                drawYes()
                break
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            break
        end
    end
    noShadow()
end

local function splash(screen, cx, cy, str, backgroundColor)
    smallWindow(screen, cx, cy, str, backgroundColor or colors.lightGray, function (window, color)
        window:set(2, 1, color, colors.blue, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.blue, " ◢█◣ ")
        window:set(2, 3, color, colors.blue, "◢███◣")
        window:set(4, 2, colors.blue, colors.white, "P")
    end)
    graphic.forceUpdate(screen)
    event.yield()
end

-------------------------------------------------- database

local defaultUser = {
    0, --balance
    true, --publicBalance
    true, --allowTransfers
    false, --admin
    false --eula
}

local function regUser(nickname)
    if not config.data.users[nickname] then
        config.data.users[nickname] = {}
    end

    local user = config.data.users[nickname]
    for key, value in pairs(defaultUser) do
        if user[key] == nil then
            user[key] = value
        end
    end

    return user
end

--------------------------------------------------

local selectedLayout

local function selectLayout(layout)
    if selectedLayout then
        selectedLayout:stop()
    end

    selectedLayout = layout
    if selectedLayout.onSelect then
        selectedLayout:onSelect()
    end

    selectedLayout:draw()
end

local function translateToUser(user, money)
    if currentUser[1] >= money then
        currentUser[1] = currentUser[1] - money
        if currentUser[1] <= 0 then currentUser[1] = 0 end
        user.user[1] = user.user[1] + money
        configSave()
    else
        rusWarn(screen, nil, nil, "Недостаточно средсв чтобы совершить перевод")
    end
end

local function numCheck(str, round)
    local num = tonumber(str)
    if num then
        if round then
            num = math.round(num)
        end

        if num > 0 then
            return num
        else
            rusWarn(screen, nil, nil, "Число должно быть больше нуля")
        end
    else
        rusWarn(screen, nil, nil, "Неправильный ввод")
    end
end

local function tSelectLayout(layout)
    event.timer(0, function ()
        selectLayout(layout)
    end)
end

local lastMeItems
local function refreshLastMe()
    --lastMeItems = me.getItemsInNetwork()
end

local function sellItems(item, count)
    local selled = 0
    for i = 1, pim.getInventorySize() do
        local stack = pim.getStackInSlot(i)
        if stack and stack.id == item[3] and stack.dmg == item[1] and (not item[4] or stack.nbt_hash == item.nbt_hash) then
            selled = selled + math.round(pim.pushItem("DOWN", i, count - selled))
            if selled > count then
                break
            end
        end
    end
    currentUser[1] = currentUser[1] + (item[6] * selled)
    configSave()
end

local function export(fingerprint, direction, amount)
    local ok, value = pcall(me.exportItem, fingerprint, direction, amount)
    if ok then
        return value.size
    end
    return 0, value or "error"
end

local function getFingerprint(item)
    local tbl = {}
    for _, aitem in ipairs(me.getAvailableItems()) do
        if aitem.fingerprint.id == item[3] and aitem.fingerprint.dmg == item[1] then
            table.insert(tbl, aitem.fingerprint)
        end
    end
    return tbl
end

local function advExport(item, direction, amount, exportCallback)
    local exported = 0
    while amount - exported > 0 do
        local count, err
        for i, fingerprint in ipairs(getFingerprint(item)) do
            count, err = export(fingerprint, direction, amount - exported)
            if count > 0 then
                exported = exported + count
                exportCallback(count)
                break
            end
        end
        
        if err then
            return exported, err
        end
    end
    return exported
end

local function formNum(num)
    return tostring(math.round(num))
end

local function buyItems(item, count)
    local exportedCount, err = advExport(item, "UP", count, function (exportedCount)
        currentUser[1] = currentUser[1] - (item[5] * exportedCount)
        configSave()
    end)

    if exportedCount < count then
        rusWarn(screen, nil, nil, "Удалось купить только " .. formNum(exportedCount) .. " из " .. formNum(count) .. " предметов\nэто может быть связано с нехваткой места в инвентаре.\nденег было списанно за " .. formNum(exportedCount) .. " предметов.")
    end
end

--[[
function getStorageItemCount(item)
    local count = 0
    for _, stack in ipairs(lastMeItems) do
        if currentNick then
            break
        end

        if stack and stack.name == item[3] and stack.damage == item[1] then
            count = count + (stack.size or 1)
        end
    end
    return math.round(count)
end
]]

function getStorageItemCount(item)
    local detail = me.getItemDetail({id=item[3],dmg=item[1]})
    if detail then
        return math.round(detail.all().qty or 0)
    else
        return 0
    end
end

function getUserItemCount(item)
    local count = 0
    for i = 1, pim.getInventorySize() do
        local stack = pim.getStackInSlot(i)
        if stack and stack.id == item[3] and stack.dmg == item[1] and (not item[4] or stack.nbt_hash == item.nbt_hash) then
            count = count + (stack.qty or 1)
        end
    end
    return math.round(count)
end

local function findItem(name, damage)
    for categoryName, category in pairs(config.items.categories) do
        for _, item in ipairs(category) do
            if item[3] == name and item[1] == damage then
                return item
            end
        end
    end
end

local function craftRequestTh()
    local counter = 0
    while true do
        for _, craft in ipairs(me.getCraftables()) do
            local item = craft.getItemStack()
            if item then
                local tbl = findItem(item.name, item.damage)
                if tbl then
                    local inStorage = getStorageItemCount(tbl)
                    local need = tbl[7] or defaultAutocraftCount
                    if inStorage < need then
                        craft.request(need - inStorage)
                        craft.request(1)
                    end
                end
            end
    
            if counter % 10 == 0 then
                os.sleep()
            end
            counter = counter + 1
        end
    end
end

-------------------------------------------------- logo

local mainLayout = uix.create(window, colors.black, uix.styles[2])
mainLayout:createImage(1, 1, logoPath, true)

function mainLayout:onSelect()
    graphic.inputHistory = {}
    clipboard.set()
    if lastUser then
        clipboard.set(lastUser)
    end
end

--------------------------------------------------

function downPlaneCreate(layout)
    layout:createPlane(1, ry - 2, rx, 3, colors.gray[3])
    local toSecondLayout = doButton(layout:createButton(2, ry - 1, 16, 1, colors.gray[4], colors.white, "← на главную", true))
    function toSecondLayout:onClick()
        tSelectLayout(secondLayout)
    end
    return toSecondLayout
end

function upPlaneCreate(layout, redraw)
    layout:createPlane(1, 1, rx, 3, colors.gray[3])
    layout:createText(2, 1, colors.cyan, "LUG Market")

    local preUserBalance = layout:createText(2, 2, colors.white, "Ваш Баланс: ")
    local userBalance = layout:createText(2 + unicode.len(preUserBalance.text), 2, colors.lime)
    local userName = doButton(layout:createButton(0, 2, 0, 1, colors.gray[2], colors.gray[1], nil, true))

    function userName:onClick()
        tSelectLayout(accauntLayout)
    end

    function layout:onRedraw()
        userName.text = tostring(currentNick)
        userName.x = rx - unicode.len(userName.text) - 2
        userName.sx = unicode.len(userName.text) + 2
    
        userBalance.text = "$" .. tostring(math.roundTo(currentUser[1]))

        if redraw then
            redraw()
        end
    end

    return function (state)
        preUserBalance.hidden = state
        userBalance.hidden = state
        userName.hidden = state

        preUserBalance.disabled = state
        userBalance.disabled = state
        userName.disabled = state
    end
end

function listCreate(layout, elementList, elementDraw)
    local offsetList = 0
    local upOffset = 5

    local scrollBar = layout:createSeek(rx, 6, ry - 9, colors.gray[2], colors.gray[2], colors.red, 0, true, true)

    local function drawElement(pos)
        local i = (pos - upOffset) + offsetList
        local element = elementList[i]
        if element then
            elementDraw(i, pos, element)
        else
            layout.window:fill(2, pos, rx - 3, 1, colors.black, 0, " ")
        end
    end

    local elementPoses = {}
    local elementIdxs = {}

    local function remathList()
        elementPoses = {}
        elementIdxs = {}

        for i = 1, #elementList do
            local pos = (i + upOffset) - offsetList

            if pos > upOffset and pos <= ry - 4 then
                elementPoses[pos] = elementList[i]
                elementIdxs[pos] = i
            end
        end
    end

    local function redrawList()
        elementPoses = {}
        elementIdxs = {}

        for i = 1, #elementList do
            local pos = (i + upOffset) - offsetList

            if pos > upOffset and pos <= ry - 4 then
                local element = elementList[i]
                elementPoses[pos] = element
                elementIdxs[pos] = element and i
                if element then
                    drawElement(pos)
                end
            end
        end

        local lastElementPos = (#elementList + upOffset) - offsetList
        if lastElementPos > 0 then
            layout.window:fill(1, lastElementPos + 1, rx - 1, ry - lastElementPos - 3, colors.black, 0, " ")
        end
    end

    local function upList()
        offsetList = offsetList - 1
        if offsetList < 0 then offsetList = 0 return end
        scrollBar.value = math.map(offsetList, 0, #elementList - 1, 0, 1)
        scrollBar:draw()

        window:copy(1, 6, rx - 1, ry - 10, 0, 1)
        drawElement(6)
        remathList()
    end

    local function downList()
        offsetList = offsetList + 1
        if offsetList >= #elementList then offsetList = #elementList - 1 return end
        scrollBar.value = math.map(offsetList, 0, #elementList - 1, 0, 1)
        scrollBar:draw()

        window:copy(1, 7, rx - 1, ry - 10, 0, -1)
        drawElement(ry - 4)
        remathList()
    end

    function scrollBar:onSeek(value, oldValue, isTouch)
        local oldOldValue = oldValue
        if isTouch then
            value = math.round(math.map(value, 0, 1, 0, #elementList - 1))
            oldValue = math.round( math.map(oldValue, 0, 1, 0, #elementList - 1))
        end

        if value > oldValue then
            downList()
        elseif value < oldValue then
            upList()
        else
            self.value = oldOldValue
            self:draw()
        end
    end

    local up = doButton(layout:createButton(rx, 5, 1, 1, colors.black, colors.orange, "^"))
    function up:onClick()
        upList()
    end

    local down = doButton(layout:createButton(rx, ry - 3, 1, 1, colors.black, colors.orange, "v"))
    function down:onClick()
        downList()
    end



    local manager = {}

    function manager.getScr()
        return offsetList
    end

    function manager.setScr(pos)
        offsetList = pos
    end

    function manager.check(eventData)
        if eventData and eventData[1] == "touch" and eventData[3] >= 2 and eventData[3] <= rx - 2 then
            return elementIdxs[eventData[4]], elementPoses[eventData[4]]
        end
    end

    return redrawList, scrollBar, manager
end

-------------------------------------------------- eula

local eulaLayout = uix.create(window, colors.black, uix.styles[2])

local toSecondLayout = downPlaneCreate(eulaLayout)

local px, py = format.objectPos(screen, 16, 1, 0, 11)
local toSecondLayout2 = doButton(eulaLayout:createButton(px, py, 16, 1, colors.gray[4], colors.white, "Принять ✓", true))
function toSecondLayout2:onClick()
    currentUser[5] = true
    configSave()
    tSelectLayout(secondLayout)
end

local function drawEula(screen, px, py, sx, bg, path)
    local content = assert(fs.readFile(path))
    local gpu = graphic.findGpu(screen)

    if bg then
        gpu.setBackground(bg)
    end

    local function set(x, y, text)
        gpu.set(x + (px - 1), y + (py - 1), text)
    end

    local lines = {}
    for _, raw_line in ipairs(parser.toLinesLn(content, sx)) do
        local line = {size = 0}
        local isColor = false
        for _, part in ipairs(parser.split(unicode, raw_line, "|")) do
            if isColor then
                table.insert(line, tonumber(part))
            else
                table.insert(line, part)
                line.size = line.size + unicode.len(part)
            end
            isColor = not isColor
        end
        table.insert(lines, line)
    end

    local color = 0xffffff
    gpu.setForeground(color)
    for y, line in ipairs(lines) do
        local cursorX = 1
        for _, part in ipairs(line) do
            if type(part) == "number" then
                gpu.setForeground(part)
            else
                set(math.round((sx / 2) - (line.size / 2)) + cursorX, y, part)
                cursorX = cursorX + unicode.len(part)
            end
        end
    end
end

local hide = upPlaneCreate(eulaLayout, function ()
    drawEula(screen, 1, 5, rx, colors.black, paths.concat(appFolder, "eula.txt"))
end)

function eulaLayout:onSelect()
    if currentUser[5] then
        hide(false)

        toSecondLayout2.disabled = true
        toSecondLayout.disabled = false

        toSecondLayout2.hidden = true
        toSecondLayout.hidden = false
    else
        hide(true)

        toSecondLayout2.disabled = false
        toSecondLayout.disabled = true

        toSecondLayout2.hidden = false
        toSecondLayout.hidden = true
    end
end

-------------------------------------------------- main control

secondLayout = uix.create(window, colors.black, uix.styles[2])

local px, py = format.objectPos(screen, 24, 3, 0, -2)
local buyButton = doButton(secondLayout:createButton(px, py, 24, 3, colors.gray[3], colors.gray[1], "Купить предметы", true))

local px, py = format.objectPos(screen, 24, 3, 0, 2)
local sellButton = doButton(secondLayout:createButton(px, py, 24, 3, colors.gray[3], colors.gray[1], "Продать предметы", true))

px, py = format.objectPos(screen, 16, 1, 16, 8)
local eulaButton = doButton(secondLayout:createButton(px, py, 16, 1, colors.gray[3], colors.gray[1], "Соглашение", true))

px, py = format.objectPos(screen, 16, 1, -16, 8)
local usersButton = doButton(secondLayout:createButton(px, py, 16, 1, colors.gray[3], colors.gray[1], "Пользователи", true))

px, py = format.objectPos(screen, 24, 3, 0, -6)
local adminPanel = doButton(secondLayout:createButton(px, py, 24, 3, colors.gray[3], colors.gray[1], "Изменения списка", true))

function buyButton:onClick()
    tradeLayout.sellMode = false
    tSelectLayout(tradeLayout)
end

function sellButton:onClick()
    tradeLayout.sellMode = true
    tSelectLayout(tradeLayout)
end

function eulaButton:onClick()
    tSelectLayout(eulaLayout)
end

function usersButton:onClick()
    tSelectLayout(usersLayout)
end

function adminPanel:onClick()
    if currentUser[4] then
        tradeLayout.sellMode = 2
        tSelectLayout(tradeLayout)
    end
end

function secondLayout:onSelect()
    if currentUser[4] then
        adminPanel.hidden = false
        adminPanel.disabled = false
    else
        adminPanel.hidden = true
        adminPanel.disabled = true
    end
end


secondLayout:createText(3, ry - 2, colors.white, "По Вопросам Пишите Владельцу: IGeorgiyLool228 (игра) | dadya_kvantum (discord)")
secondLayout:createText(7, ry - 1, colors.white, "Автор Програмного Обеспечения: LuaGame (игра) | dadya_kvantum (discord)")

upPlaneCreate(secondLayout)

-------------------------------------------------- accaunt control

accauntLayout = uix.create(window, colors.black, uix.styles[2])
accauntLayout:createPlane(2, 5, rx - 2, 5, colors.gray[4])

local balanceShowSwitch = accauntLayout:createSwitch(3, 6)
local transferAllowSwitch = accauntLayout:createSwitch(3, 8)

accauntLayout:createText(10, 6, colors.white, "Разрешить другим пользователям просматривать ваш баланс")
accauntLayout:createText(10, 8, colors.white, "Разрешить другим пользователям переводить средства на ваш аккаунт")

function balanceShowSwitch:onSwitch()
    currentUser[2] = self.state
    configSave()
end

function transferAllowSwitch:onSwitch()
    currentUser[3] = self.state
    configSave()
end

function accauntLayout:onSelect()
    balanceShowSwitch.state = currentUser[2]
    transferAllowSwitch.state = currentUser[3]
end

downPlaneCreate(accauntLayout)
upPlaneCreate(accauntLayout)

-------------------------------------------------- users layout

usersLayout = uix.create(window, colors.black, uix.styles[2])

usersLayout:createPlane(1, 4, rx, 1, colors.blue)
usersLayout:createText(3, 4, colors.orange, "Никнейм")
usersLayout:createText(3 + 16, 4, colors.orange, "Баланс")
usersLayout:createText(3 + 16 + 16, 4, colors.orange, "Переводы")

local elementList = {}

local redrawList, scrollBar, manager = listCreate(usersLayout, elementList, function (i, pos, element)
    local color = i % 2 == 0 and colors.gray4a or colors.gray[4]
    if element.nickname == currentNick then
        color = colors.gray[2]
    end

    local smart = format.smartConcat()
    smart.makeSize(rx - 3)
    smart.add(2, element.nickname)
    if element.user[2] then
        smart.add(2 + 16, math.roundTo(element.user[1]))
    else
        smart.add(2 + 16, "Скрыт")
    end
    if element.user[3] then
        smart.add(2 + 16 + 16, "Разрешены")
    else
        smart.add(2 + 16 + 16, "Запрешены")
    end
    usersLayout.window:set(2, pos, color, colors.white, smart.get())
end)

downPlaneCreate(usersLayout)

local currentSearch

local function usersMathList(search, noRedraw)
    local function isSearch(text)
        if not search or search == "" then
            return true
        end

        text = text:lower()
        search = search:lower()
        return not not text:find(search)
    end

    for key, value in pairs(elementList) do
        elementList[key] = nil
    end
    manager.setScr(0)
    scrollBar.value = 0

    local addedBalances = {}
    local balances = {}
    local maxBalance = 0
    for nickname, user in pairs(config.users) do
        if user[1] then
            if not addedBalances[user[1]] then
                table.insert(balances, user[1])
                addedBalances[user[1]] = true
                if user[1] > maxBalance then
                    maxBalance = user[1]
                end
            end
        else
            table.insert(elementList, {nickname = nickname, user = user})
        end
    end
    table.sort(balances, function (a, b)
        return a < b
    end)
    for index, targetBalance in ipairs(balances) do
        for nickname, user in pairs(config.users) do
            if user[1] == targetBalance then
                table.insert(elementList, 1, {nickname = nickname, user = user})
            end
        end
    end

    for i = #elementList, 1, -1 do
        local obj = elementList[i]
        if not isSearch(obj.nickname) then
            table.remove(elementList, i)
        end
    end

    if not noRedraw then
        redrawList()
        scrollBar:draw()
    end
end

local searchInput = usersLayout:createInput(rx - 28, ry - 1, 24, colors.gray[4], colors.white, nil, nil, nil, 16, nil, nil, "Поиск...")
function searchInput:onTextChanged(text)
    if text == "" then
        currentSearch = ""
    else
        currentSearch = escape_pattern(text)
    end
    usersMathList(currentSearch)
end

local searchClean = doButton(usersLayout:createButton(rx - 4, ry - 1, 3, 1, colors.gray[2], colors.orange, "X"))
function searchClean:onClick()
    currentSearch = ""
    searchInput.read.setBuffer(currentSearch)
    searchInput:draw()
    usersMathList(currentSearch)
end

function usersLayout:onSelect()
    currentSearch = ""
    searchInput.read.setBuffer(currentSearch)
    searchInput.read.setAllowUse(false)
    searchInput.read.setOffset(0, 0)
    usersMathList(currentSearch, true)
end

function usersLayout:onEvent(eventData)
    local _, user = manager.check(eventData)
    if user and user.nickname ~= currentNick then
        if user.user[3] then
            local input = rusInput(screen, "Перевести", nil, nil, "Сумма Для \"" .. user.nickname .. "\"", nil, nil, nil, nil, numbersWhiteListWithDot)
            if input then
                local num = numCheck(input)
                if num then
                    translateToUser(user, num)
                end
            end
        else
            rusWarn(screen, nil, nil, "Пользователь \"" .. user.nickname .. "\" запретил перевод сведств на свой аккаунт")
        end
        usersLayout:draw()
    end
end

upPlaneCreate(usersLayout, redrawList)

-------------------------------------------------- 


tradeLayout = uix.create(window, colors.black, uix.styles[2])
tradeLayout:createPlane(1, 4, rx, 1, colors.blue)

local elementList = {}
tradeLayout:createText(namePos , 4, colors.orange, "Имя")
local buyLabel = tradeLayout:createText(pricePos , 4, colors.orange, "Цена")
local sellLabel = tradeLayout:createText(sellPricePos, 4, colors.orange, "Цена Продажи")

local buyLabel2 = tradeLayout:createText(pricePos2, 4, colors.orange, "Цена")
local sellLabel2 = tradeLayout:createText(sellPricePos2, 4, colors.orange, "Цена Продажи")

local invLabel = tradeLayout:createText(invPos, 4, colors.orange, "В инвентаре")
local storageLabel = tradeLayout:createText(storagePos, 4, colors.orange, "В наличии")
local nbtLabel = tradeLayout:createText(rx - 4, 4, colors.orange, "NBT")

local redrawList, scrollBar, manager = listCreate(tradeLayout, elementList, function (i, pos, element)
    local color = i % 2 == 0 and colors.gray4a or colors.gray[4]

    local smart = format.smartConcat()
    smart.makeSize(rx - 3)
    smart.add(categoryPos - 1, element.category)
    smart.add(namePos - 1, element.item[2])
    if tradeLayout.sellMode == 2 then
        smart.add(sellPricePos2 - 1, tostring(element.item[6]))
        smart.add(pricePos2 - 1, tostring(element.item[5]))
        smart.add(storagePos - 1, tostring(getStorageItemCount(element.item)))
    elseif tradeLayout.sellMode then
        smart.add(sellPricePos - 1, tostring(element.item[6]))
        smart.add(invPos - 1, tostring(getUserItemCount(element.item)))
    else
        smart.add(pricePos - 1, tostring(element.item[5]))
        smart.add(storagePos - 1, tostring(getStorageItemCount(element.item)))
    end
    tradeLayout.window:set(2, pos, color, colors.white, smart.get())

    if tradeLayout.sellMode == 2 then
        tradeLayout.window:set(rx - 4, pos, color, element.item[4] and colors.white or colors.gray[5], "⠶")
    end
end)

upPlaneCreate(tradeLayout, redrawList)

local lastCategory, currentSearch
local lastCategoryI = 1
local actives = {}
local categoriesList 
local categoriesFuncs

local function reCategory()
    categoriesList = {"Все"}
    categoriesFuncs = {function ()
        for i = 1, #categoriesList do
            actives[i] = true
        end
        actives[1] = false

        lastCategoryI = 1
        lastCategory = nil
        mathList(lastCategory, currentSearch)
        categorySelector:draw()
    end}

    local ctg = {}
    for name in pairs(config.items.categories) do
        table.insert(ctg, name)
    end
    table.sort(ctg)

    for i, name in ipairs(ctg) do
        table.insert(categoriesList, name)
        table.insert(categoriesFuncs, function ()
            for i = 1, #categoriesList do
                actives[i] = true
            end
            actives[i + 1] = false

            lastCategoryI = i + 1
            lastCategory = name
            mathList(lastCategory, currentSearch)
            categorySelector:draw()
        end)
    end

    for k, v in pairs(actives) do
        actives[k] = nil
    end
    for i = 1, #categoriesList do
        actives[i] = true
    end
    actives[lastCategoryI] = false

    if categorySelector then
        categorySelector:destroy()
    end
    categorySelector = tradeLayout:createContext(categoryPos, 4, 11, 1, colors.orange, colors.black, " Категория↓", categoriesList, categoriesFuncs, actives)
end

function mathList(category, search, noRedraw)
    local function isSearch(text)
        if not search or search == "" then
            return true
        end

        text = text:lower()
        search = search:lower()
        return not not text:find(search)
    end
    refreshLastMe()

    for key, value in pairs(elementList) do
        elementList[key] = nil
    end
    manager.setScr(0)
    scrollBar.value = 0
    if category then
        for index, value in ipairs(config.items.categories[category]) do
            table.insert(elementList, {item = value, category = category, index = index})
        end
    else
        for _, category in ipairs(categoriesList) do
            for index, value in ipairs(config.items.categories[category] or {}) do
                table.insert(elementList, {item = value, category = category, index = index})
            end
        end
    end
    for i = #elementList, 1, -1 do
        local obj = elementList[i]
        local add = true
        if tradeLayout.sellMode ~= 2 then
            if tradeLayout.sellMode then
                if not obj.item[6] then
                    add = false
                end
            else
                if not obj.item[5] then
                    add = false
                end
            end
        end
        if not add or (not isSearch(obj.category) and not isSearch(obj.item[2])) then
            table.remove(elementList, i)
        end
    end

    if not noRedraw then
        redrawList()
        scrollBar:draw()
    end
end

reCategory()

downPlaneCreate(tradeLayout)

--[[
local refresh = tradeLayout:createButton(6, ry, 4, 1, colors.blue, colors.white, "@@", true)
function refresh:onClick()
    tradeLayout:draw()
end
]]

local searchInput = tradeLayout:createInput(rx - 28, ry - 1, 24, colors.gray[4], colors.white, nil, nil, nil, 16, nil, nil, "Поиск...")
function searchInput:onTextChanged(text)
    if text == "" then
        currentSearch = ""
    else
        currentSearch = escape_pattern(text)
    end
    mathList(lastCategory, currentSearch)
end

local searchClean = doButton(tradeLayout:createButton(rx - 4, ry - 1, 3, 1, colors.gray[2], colors.orange, "X"))
function searchClean:onClick()
    currentSearch = ""
    searchInput.read.setBuffer(currentSearch)
    searchInput:draw()
    mathList(lastCategory, currentSearch)
end

local addCategory = doButton(tradeLayout:createButton(3, 2, 3, 1, colors.gray[2], colors.orange, "+", true))
local delCategory = doButton(tradeLayout:createButton(7, 2, 3, 1, colors.gray[2], colors.orange, "-", true))
local renCategory = doButton(tradeLayout:createButton(11, 2, 3, 1, colors.gray[2], colors.orange, "R", true))

function addCategory:onClick()
    local name = rusInput(screen, "Применить", nil, nil, "Введите имя категории")
    if name then
        config.data.items.categories[name] = {}
        reCategory()
        configSave()
    end
    tradeLayout:draw()
end

function delCategory:onClick()
    if lastCategory and lastCategory ~= "All" then
        if runYesno(screen, nil, nil, "Вы действительно хотите удалить категорию \"" .. (lastCategory or "unknown") .. "\" со всеми предметами?") then
            config.data.items.categories[lastCategory] = nil
            lastCategory, currentSearch, lastCategoryI = nil, "", 1
            reCategory()
            configSave()
            mathList(lastCategory, currentSearch)
        end
    else
        rusWarn(screen, nil, nil, "Сначала выберите категорию")
    end
    tradeLayout:draw()
end

function renCategory:onClick()
    if lastCategory and lastCategory ~= "All" then
        local newName = rusInput(screen, "Переименовать", nil, nil, "Имя категории", nil, nil, tostring(lastCategory))
        if newName then
            local currentCategory = config.data.items.categories[lastCategory]
            config.data.items.categories[lastCategory] = nil
            config.data.items.categories[newName] = currentCategory
            lastCategory = newName
            reCategory()
            configSave()
            mathList(lastCategory, currentSearch)
        end
    else
        rusWarn(screen, nil, nil, "Сначала выберите категорию")
    end
    tradeLayout:draw()
end


local addItem = doButton(tradeLayout:createButton(19, 2, 3, 1, colors.gray[2], colors.red, "+", true))
function addItem:onClick()
    if lastCategory and lastCategory ~= "All" then
        local pimitem = component.pim.getStackInSlot(1)
        if pimitem then
            local name = nRusInput(screen, "Добавить", nil, nil, "Введите имя", nil, nil, tostring(pimitem.display_name), nil, pimitem)
            if name then
                local item = {
                    pimitem.dmg,
                    name,
                    pimitem.id,
                    pimitem.nbt_hash
                }
                table.insert(config.data.items.categories[lastCategory], item)
                configSave()
                mathList(lastCategory, currentSearch)
            end
        else
            rusWarn(screen, nil, nil, "Сначала возмите предмет в первый слот хотбара")
        end
    else
        rusWarn(screen, nil, nil, "Сначала выберите категорию")
    end
    tradeLayout:draw()
end

function tradeLayout:onSelect()
    local dis = tradeLayout.sellMode ~= 2

    addCategory.hidden = dis
    addCategory.disabled = dis

    delCategory.hidden = dis
    delCategory.disabled = dis

    renCategory.hidden = dis
    renCategory.disabled = dis

    addItem.hidden = dis
    addItem.disabled = dis

    if not dis then
        local placePos = rx - unicode.len(currentNick) - 7
        addItem.x = placePos - 13
        addCategory.x = placePos - 8
        delCategory.x = placePos - 4
        renCategory.x = placePos
    end

    buyLabel2.hidden = true
    sellLabel2.hidden = true
    nbtLabel.hidden = true
    if tradeLayout.sellMode == 2 then
        buyLabel2.hidden = false
        sellLabel2.hidden = false
        nbtLabel.hidden = false

        sellLabel.hidden = true
        buyLabel.hidden = true

        invLabel.hidden = true
        storageLabel.hidden = false
    elseif tradeLayout.sellMode then
        sellLabel.hidden = false
        buyLabel.hidden = true

        invLabel.hidden = false
        storageLabel.hidden = true
    else
        sellLabel.hidden = true
        buyLabel.hidden = false

        invLabel.hidden = true
        storageLabel.hidden = false
    end

    lastCategory, currentSearch, lastCategoryI = nil, "", 1
    reCategory()
    searchInput.read.setBuffer(currentSearch)
    searchInput.read.setAllowUse(false)
    searchInput.read.setOffset(0, 0)
    mathList(lastCategory, currentSearch, true)
end

function lugContext(layout, screen, posX, posY, strs, active)
    layout.controlLock = true
    local th = thread.create(gui.contextAuto, screen, posX, posY, strs, active)
    th:resume()
    local out = {}
    while not canStopWhile() do
        if th:status() == "dead" then
            local lout = {th:decode()}
            if lout[1] then
                out = lout
                break
            else
                assert(table.unpack(out))
            end
        end
        os.sleep(0.1)
    end
    th:kill()
    layout.controlLock = false
    return table.unpack(out, 2)
end



function tradeLayout:onEvent(eventData)
    local _, oitem = manager.check(eventData)
    if oitem then
        local cfgitem = config.data.items.categories[oitem.category][oitem.index]
        local item = oitem.item
        if tradeLayout.sellMode == 2 then
            if eventData[3] == rx - 4 then
                cfgitem[4] = not cfgitem[4]
                if cfgitem[4] == false then oitem.cfgitem = nil end
                configSave()
            else
                local _, num = lugContext(tradeLayout, screen, eventData[3], eventData[4], {"Удалить предмет", "Изменить цену покупки", "Удалить цену покупки", "Изменить цены продажи", "Удалить цену продажи", "Изменить имя", "Установить количество автокрафта"})
                if num then
                    if num == 1 then
                        if runYesno(screen, nil, nil, "Вы действительно хотите удалить \"" .. (cfgitem[2] or "unknown") .. "\"?") then
                            table.remove(config.data.items.categories[oitem.category], oitem.index)
                        end
                    elseif num == 2 then
                        local count = nRusInput(screen, "Изменить", nil, nil, "Цена для покупки предмета", nil, nil, cfgitem[5] and tostring(cfgitem[5]), nil, item, nil, numbersWhiteListWithDot)
                        if count then
                            local num = numCheck(count)
                            if num then
                                cfgitem[5] = num
                            end
                        end
                    elseif num == 3 then
                        cfgitem[5] = nil
                    elseif num == 4 then
                        local count = nRusInput(screen, "Изменить", nil, nil, "Цена продажи предмета", nil, nil, cfgitem[6] and tostring(cfgitem[6]), nil, item, nil, numbersWhiteListWithDot)
                        if count then
                            local num = numCheck(count)
                            if num then
                                cfgitem[6] = num
                            end
                        end
                    elseif num == 5 then
                        cfgitem[6] = nil
                    elseif num == 6 then
                        local name = nRusInput(screen, "Изменить", nil, nil, "Имя", nil, nil, tostring(cfgitem[2]), nil, item)
                        if name then
                            cfgitem[2] = name
                        end
                    elseif num == 7 then
                        local count = nRusInput(screen, "Установить", nil, nil, "Сколько автокрафтить \"" .. item[2] .. "\"?", nil, nil, tostring(cfgitem[7] or defaultAutocraftCount), nil, item, nil, numbersWhiteList)
                        if count then
                            local num = numCheck(count, true)
                            if num then
                                cfgitem[7] = num
                            end
                        end
                    end
                    configSave()
                    mathList(lastCategory, currentSearch)
                end
            end
        elseif tradeLayout.sellMode then
            local count = nRusInput(screen, "Продать", nil, nil, "Сколько продать \"" .. item[2] .. "\"?", nil, nil, nil, nil, item, true, numbersWhiteList)
            if count then
                local num = numCheck(count, true)
                if num then
                    if num > getUserItemCount(item) then
                        rusWarn(screen, nil, nil, "В инвентаре недостаточно предметов этого типа")
                    else
                        splash(screen, nil, nil, "Процесс продажи...")
                        sellItems(item, num)
                        refreshLastMe()
                    end
                end
            end
        else
            local count = nRusInput(screen, "Купить", nil, nil, "Сколько купить \"" .. item[2] .. "\"?", nil, nil, nil, nil, item, false, numbersWhiteList)
            if count then
                local num = numCheck(count, true)
                if num then
                    if num * item[5] > currentUser[1] then
                        rusWarn(screen, nil, nil, "Недостаточно средств для совершения покупки")
                    elseif num <= getStorageItemCount(item) then
                        splash(screen, nil, nil, "Процесс покупки...")
                        refreshLastMe()
                        buyItems(item, num)
                        refreshLastMe()
                    else
                        rusWarn(screen, nil, nil, "На складе недостаточно предметов этого типа")
                    end
                end
            end
        end
        tradeLayout:draw()
    end
end

--------------------------------------------------

function canStopWhile()
    return pim.getInventoryName() ~= currentNick
end

selectLayout(mainLayout)

local craftTh = thread.create(craftRequestTh)
thread.create(function ()
    while true do
        if currentNick then
            craftTh:suspend()
        else
            craftTh:resume()
        end

        os.sleep(1)
    end
end):resume()

thread.create(function ()
    while true do
        if not currentNick then
            _G.syncCheck()
            _G.updateCheck()
        end
        os.sleep(2)
    end
end):resume()

while true do
    local eventData = {event.pull(0.1)}
    selectedLayout:uploadEvent(eventData)

    local inventoryName = pim.getInventoryName()
    if inventoryName ~= "pim" then
        if inventoryName ~= currentNick then
            currentNick = inventoryName
            currentUser = regUser(currentNick)
            lastUser = currentUser
            _G.lugMarketUser = currentNick
            if currentUser[5] then
                selectLayout(secondLayout)
            else
                selectLayout(eulaLayout)
            end
        end
    elseif selectedLayout ~= mainLayout then
        _G.lugMarketUser = nil
        currentUser = nil
        currentNick = nil
        tradeLayout.controlLock = false
        if cache.data.clipboard then
            for k, v in pairs(cache.data.clipboard) do
                cache.data.clipboard[k] = nil
            end
        end
        selectLayout(mainLayout)
    end
endsystem/bin/LUGMarket.app/palette.plt 243 {
    0xffffff,
    0xc5c5c5,
    0x858585,
    0x545454,
    0x343434,
    0x1b1b1b,
    0x000000,
    0xba0b0b,
    0x1cba0b,
    0x1e3de8,
    0xdbd904,
    0x01b799,
    0xff00ff,
    0x4C99B2,
    0xdb9204,
    0x434343
}system/bin/files.tbl 205 {"shell.lua","LUGMarket.app/default.dat","LUGMarket.app/eula.txt","LUGMarket.app/exit.lua","LUGMarket.app/icon.t2p","LUGMarket.app/logo.t2p","LUGMarket.app/main.lua","LUGMarket.app/palette.plt",version=28}system/bin/shell.lua 4867 local event = require("event")
local component = require("component")
local liked = require("liked")
local apps = require("apps")
local paths = require("paths")
local serialization = require("serialization")
local registry = require("registry")
local system = require("system")
local graphic = require("graphic")
local computer = require("computer")
local internet = require("internet")
internet.settings.timeout = 10

local screen = ...

if _G.lugMarketScreen and _G.lugMarketScreen ~= screen then
    event.wait()
    return
end

_G.lugMarketScreen = screen
_G.lugmarketPort = 4561
_G.lugmarketMsg = "lugmarket_msg"

_G.host = "http://176.53.161.98:4045"
_G.updateHost = _G.host .. "/e2d8fefb-dd72-4c9a-be85-6db41a92b3db/"
_G.postUrl = _G.host .. "/d86a22ef-ad92-45b5-bd89-9d6c59e0c63f/"
_G.updateFile = _G.updateHost .. "files.tbl"
_G.dbFile = _G.updateHost .. "data.dat"

-------------------------------------------------------- system settings

graphic.setDepth(screen, 4)
registry.shadowMode = "full"
registry.shadowType = "advanced"
registry.bufferType = "hardware"
--registry.bufferType = "none"
liked.applyBufferType()

-------------------------------------------------------- modem check & wakeup

local appFolder = paths.concat(paths.path(system.getSelfScriptPath()), "LUGMarket.app")
local defaultConfigPath = paths.concat(appFolder, "default.dat")
local defaultConfig = serialization.load(defaultConfigPath)
local config = registry.new("lugmarket.dat", defaultConfig)
_G.lugmarketConfig = config

-------------------------------------------------------- modem check & wakeup

local modem = component.modem or error("connect the wired modem!")
if modem.isWireless() then
    error("wireless modem is not support")
end

modem.close()
modem.open(_G.lugmarketPort)
modem.setWakeMessage(_G.lugmarketMsg, true)

local function sendToServer()
    local card = internet.cardProxy()
    if card then
        card.request(_G.postUrl, serialization.serialize(config.data))
    end
end

function _G.lugmarketSend()
    modem.broadcast(_G.lugmarketPort, _G.lugmarketMsg, config.data.version, serialization.serialize(config.data))
end

local function getTable(url)
    if internet.card() then
        local files = internet.get(url)
        if files then
            files = serialization.unserialize(files)
            if files then
                return files
            end
        end
    end
end

function _G.updateCheck()
    local files = getTable(_G.updateFile)
    if files then
        if not registry.lugver or registry.lugver ~= files.version then
            --local downloads = {}
            for _, file in ipairs(files) do
                --table.insert(downloads, {_G.updateHost .. file, paths.concat("/system/bin", file)})
                internet.download(_G.updateHost .. file, paths.concat("/system/bin", file))
            end
            --internet.downloads(downloads)
            registry.lugver = files.version
            computer.shutdown("fast")
        end
    end
end

function _G.syncCheck()
    local files = getTable(_G.dbFile)
    if files then
        if files.version > config.data.version then
            config.data = files
            config.save()
        elseif files.version < config.data.version then
            sendToServer()
        end
    end
end

event.timer(3, function ()
    _G.lugmarketSend()
end, math.huge)

event.listen("modem_message", function (_, uuid, sender, port, dist, title, version, cfg)
    if title == _G.lugmarketMsg then
        if version > config.data.version then
            config.data = serialization.unserialize(cfg)
            config.save()
        end
    end
end)

-------------------------------------------------------- event hook

event.hyperHook(function (...)
    local eventData = {...}
    if eventData[1] == "key_down" or eventData[1] == "key_up" then
        if _G.lugMarketUser and eventData[5] ~= _G.lugMarketUser then
            eventData[1] = "skipped_" .. eventData[1]
        end
    elseif eventData[1] == "touch" or eventData[1] == "scroll" or eventData[1] == "drag" or eventData[1] == "drop" then
        if _G.lugMarketUser and eventData[6] ~= _G.lugMarketUser then
            eventData[1] = "skipped_" .. eventData[1]
        end
    end
    return table.unpack(eventData)
end)

-------------------------------------------------------- redstone wakeup

for addrs in component.list("redstone", true) do
    component.invoke(addrs, "setWakeThreshold", 1)
end

-------------------------------------------------------- running market shell

_G.syncCheck()
_G.updateCheck()

while true do
    apps.execute("LUGMarket", screen)
    for i = 1, 3 do
        computer.beep(300, 0.5)
        os.sleep(0.1)
    end
endsystem/core/LICENSE 1210 This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>system/core/autoruns/a_component.lua 9155 local component = require("component")
local computer = require("computer")
local event = require("event")

local adding = {}
local primaries = {}

-------------------------------------------------------------------------------

-- This allows writing component.modem.open(123) instead of writing
-- component.getPrimary("modem").open(123), which may be nicer to read.
setmetatable(component, {
    __index = function(_, key)
        return primaries[key] --опционально
    end,
    __pairs = function(self)
        local parent = false
        return function(_, key)
            if parent then
                return next(primaries, key)
            else
                local k, v = next(self, key)
                if not k then
                    parent = true
                    return next(primaries)
                else
                    return k, v
                end
            end
        end
    end
})

function component.get(address, componentType)
    checkArg(1, address, "string")
    checkArg(2, componentType, "string", "nil")
    for c in component.list(componentType, true) do
        if c:sub(1, address:len()) == address then
            return c
        end
    end
    return nil, "no such component"
end

function component.isAvailable(componentType)
    checkArg(1, componentType, "string")
    if not primaries[componentType] and not adding[componentType] then
        -- This is mostly to avoid out of memory errors preventing proxyN
        -- creation cause confusion by trying to create the proxy again,
        -- causing the oom error to be thrown again.
        pcall(component.setPrimary, componentType, component.list(componentType, true)())
    end
    return primaries[componentType] ~= nil
end

function component.isPrimary(address)
    local componentType = component.type(address)
    if componentType then
        if component.isAvailable(componentType) then
            return primaries[componentType].address == address
        end
    end
    return false
end

function component.getPrimary(componentType)
    checkArg(1, componentType, "string")
    assert(component.isAvailable(componentType),
        "no primary '" .. componentType .. "' available")
    return primaries[componentType]
end

function component.setPrimary(componentType, address)
    checkArg(1, componentType, "string")
    checkArg(2, address, "string", "nil")

    if address ~= nil then
        address = component.get(address, componentType)
        assert(address, "no such component")
    end

    local wasAvailable = primaries[componentType]
    if wasAvailable and address == wasAvailable.address then
        return
    end
    local wasAdding = adding[componentType]
    if wasAdding and address == wasAdding.address then
        return
    end
    if wasAdding then
        event.cancel(wasAdding.timer)
    end
    primaries[componentType] = nil
    adding[componentType] = nil

    local primary = address and component.proxy(address) or nil
    if wasAvailable then
        computer.pushSignal("component_unavailable", componentType)
    end
    if primary then
        if wasAvailable or wasAdding then
            adding[componentType] = {
                address = address,
                proxy = primary,
                timer = event.timer(0.1, function()
                    adding[componentType] = nil
                    primaries[componentType] = primary
                    computer.pushSignal("component_available", componentType)
                end)
            }
        else
            primaries[componentType] = primary
            computer.pushSignal("component_available", componentType)
        end
    end
end

function component.isConnected(proxyOrAddress)
    if type(proxyOrAddress) == "table" then
        proxyOrAddress = proxyOrAddress.address
    end
    return not not pcall(component.doc, proxyOrAddress, "")
end

function component.getReal(ctype, gproxy)
    local vcomponent = require("vcomponent")
    for address in component.list(ctype, true) do
        if not vcomponent.isVirtual(address) then
            if gproxy then
                return component.proxy(address)
            else
                return address
            end
        end
    end
end

-------------------------------------------------------------------------------

local function onComponentAdded(_, address, componentType)
    local prev = primaries[componentType] or (adding[componentType] and adding[componentType].proxy)

    if prev then
        -- special handlers -- some components are just better at being primary
        if componentType == "screen" then
            --the primary has no keyboards but we do
            if #prev.getKeyboards() == 0 then
                local first_kb = component.invoke(address, 'getKeyboards')[1]
                if first_kb then
                    -- just in case our kb failed to achieve primary
                    -- possible if existing primary keyboard became primary first without a screen
                    -- then prev (a screen) was added without a keyboard
                    -- and then we attached this screen+kb pair, and our kb fired first - failing to achieve primary
                    -- also, our kb may fire right after this, which is fine
                    pcall(component.setPrimary, "keyboard", first_kb)
                    prev = nil -- nil meaning we should take this new one over the previous
                end
            end
        elseif componentType == "keyboard" then
            -- to reduce signal noise, if this kb is also the prev, we do not need to reset primary
            if address ~= prev.address then
                --keyboards never replace primary keyboards unless the are the only keyboard on the primary screen
                local current_screen = primaries.screen or (adding.screen and adding.screen.proxy)
                --if there is not yet a screen, do not use this keyboard, it's not any better
                if current_screen then
                    -- the next phase is complicated
                    -- there is already a screen and there is already a keyboard
                    -- this keyboard is only better if this is a keyboard of the primary screen AND the current keyboard is not
                    -- i don't think we can trust kb order (1st vs 2nd), 2nd could fire first
                    -- but if there are two kbs on a screen, we can give preferred treatment to the first
                    -- thus, assume 2nd is not attached for the purposes of primary kb
                    -- and THUS, whichever (if either) is the 1st kb of the current screen
                    -- this is only possible if
                    -- 1. the only kb on the system (current) has no screen
                    -- 2. a screen is added without a kb
                    -- 3. this kb is added later manually

                    -- prev is true when addr is not equal to the primary keyboard of the current screen -- meaning
                    -- when addr is different, and thus it is not the primary keyboard, then we ignore this
                    -- keyboard, and keep the previous
                    -- prev is false means we should take this new keyboard
                    prev = address ~= current_screen.getKeyboards()[1]
                end
            end
        end
    end

    if not prev then
        pcall(component.setPrimary, componentType, address)
    end
end

local function onComponentRemoved(_, address, componentType)
    if primaries[componentType] and primaries[componentType].address == address or
        adding[componentType] and adding[componentType].address == address
    then
        local next = component.list(componentType, true)()
        pcall(component.setPrimary, componentType, next)

        if componentType == "screen" and next then
            -- setPrimary already set the proxy (if successful)
            local proxy = (primaries.screen or (adding.screen and adding.screen.proxy))
            if proxy then
                -- if a screen is removed, and the primary keyboard is actually attached to another, non-primary, screen
                -- then the `next` screen, if it has a keyboard, should TAKE priority
                local next_kb = proxy.getKeyboards()[1] -- costly, don't call this method often
                local old_kb = primaries.keyboard or adding.keyboard
                -- if the next screen doesn't have a kb, this operation is without purpose, leave things as they are
                -- if there was no previous kb, use the new one
                if next_kb and (not old_kb or old_kb.address ~= next_kb) then
                    pcall(component.setPrimary, "keyboard", next_kb)
                end
            end
        end
    end
end

event.hyperListen(function (eventType, ...)
    if eventType == "component_added" then
        pcall(onComponentAdded, eventType, ...)
    elseif eventType == "component_removed" then
        pcall(onComponentRemoved, eventType, ...)
    end
end)

for address, ctype in component.list() do
    pcall(onComponentAdded, "component_added", address, ctype)
endsystem/core/boot/a_functions.lua 3276 ------------------------------------------------ math
function math.round(number)
    if number >= 0 then
        return math.floor(number + 0.5)
    else
        return math.ceil(number - 0.5)
    end
end

function math.map(value, low, high, low_2, high_2)
    local relative_value = (value - low) / (high - low)
    local scaled_value = low_2 + (high_2 - low_2) * relative_value
    return scaled_value
end

function math.clamp(value, min, max)
    return math.min(math.max(value, min), max)
end

function math.roundTo(number, numbers)
    numbers = numbers or 3
    return tonumber(string.format("%." .. tostring(math.floor(numbers)) .. "f", number))
end


function math.mapRound(value, low, high, low_2, high_2)
    return math.round(math.map(value, low, high, low_2, high_2))
end

function math.clampRound(value, min, max)
    return math.round(math.clamp(value, min, max))
end


------------------------------------------------ table
function table.clone(tbl)
    local newtbl = {}
    for k, v in pairs(tbl) do
        newtbl[k] = v
    end
    return newtbl
end

function table.exists(tbl, val)
    for k, v in pairs(tbl) do
        if v == val then
            return true, k
        end
    end
    return false
end

function table.find(tbl, val)
    return select(2, table.exists(tbl, val))
end

function table.clear(tbl, val)
    local state = false
    for k, v in pairs(tbl) do
        if val == nil or v == val then
            tbl[k] = nil
            state = true
        end
    end
    return state
end

function table.deepclone(tbl, newtbl)
    local cache = {}
    local function recurse(tbl, newtbl)
        local newtbl = newtbl or {}

        for k, v in pairs(tbl) do
            if type(v) == "table" then
                local ltbl = cache[v]
                if not ltbl then
                    cache[v] = {}
                    ltbl = cache[v]
                    recurse(v, cache[v])
                end
                newtbl[k] = ltbl
            else
                newtbl[k] = v
            end
        end

        return newtbl
    end

    return recurse(tbl, newtbl)
end

function table.low(tbl)
    local newtbl = {}
    for i, v in ipairs(tbl) do
        newtbl[i - 1] = v
    end
    return newtbl
end

function table.high(tbl)
    local newtbl = {}
    for i, v in ipairs(tbl) do
        newtbl[i + 1] = v
    end
    return newtbl
end

function table.fromIterator(...)
    local tbl = {}
    for a, b, c, d, e, f, g, h, j, k in ... do
        table.insert(tbl, {a, b, c, d, e, f, g, h, j, k})
    end
    return tbl
end

function table.len(tbl)
    local len = 0
    for i, v in pairs(tbl) do
        len = len + 1
    end
    return len
end

------------------------------------------------ other

function spcall(...)
    local result = table.pack(pcall(...))
    if not result[1] then
        error(tostring(result[2]), 3)
    else
        return table.unpack(result, 2, result.n)
    end
end

function xor(...)
    local state = false
    for _, flag in ipairs({...}) do
        if flag then
            state = not state
        end
    end
    return state
end

function toboolean(object)
    object = tostring(object)
    if object == "true" or object == "1" then
        return true
    else
        return false
    end
endsystem/core/boot/b_lua_improvements.lua 288 local npairs, nipairs = pairs, ipairs
local getmetatable = getmetatable

function _G.pairs(tbl)
    local mt = getmetatable(tbl)
    return (mt and mt.__pairs or npairs)(tbl)
end

function _G.ipairs(tbl)
    local mt = getmetatable(tbl)
    return (mt and mt.__ipairs or nipairs)(tbl)
endsystem/core/bootloader.lua 19175 --likeOS classic bootloader

------------------------------------base init

local component, computer, unicode = component, computer, unicode

local pullSignal = computer.pullSignal
local shutdown = computer.shutdown
local error = error
local pcall = pcall

_G._COREVERSION = "likeOS-v1.8"
_G._OSVERSION = _G._COREVERSION --это перезаписываеться в дистрибутивах

local bootloader = {} --библиотека загрузчика
bootloader.firstEeprom = component.list("eeprom")() --хранит адрес eeprom с которого произошла загрузка
bootloader.tmpaddress = computer.tmpAddress()

bootloader.bootaddress = computer.getBootAddress()
bootloader.bootfs = component.proxy(bootloader.bootaddress)

bootloader.coreversion = _G._COREVERSION
bootloader.runlevel = "init"

function computer.runlevel()
    return bootloader.runlevel
end

------------------------------------ set architecture

bootloader.supportedArchitectures = {
    ["Lua 5.3"] = true,
    ["Lua 5.4"] = true
}

local architecture = "unknown"
if computer.getArchitecture then architecture = computer.getArchitecture() end
if not bootloader.supportedArchitectures[architecture] then
    pcall(computer.setArchitecture, "Lua 5.4")
    pcall(computer.setArchitecture, "Lua 5.3")
end

------------------------------------ bootloader constants

bootloader.defaultShellPath = "/system/main.lua"

------------------------------------ base functions

function bootloader.yield() --катыльный способ вызвать прирывания дабы избежать краша(звук издаваться не будет так как функция завершаеться ошибкой из за переданого 0)
    pcall(computer.beep, 0)
end

function bootloader.createEnv() --создает _ENV для программы, где _ENV будет личьный, а _G обший
    return setmetatable({_G = _G}, {__index = _G})
end

function bootloader.find(name, ignoreData)
    local checkList = {"/data/", "/vendor/", "/system/", "/system/core/"} --в порядке уменьшения приоритета(data самый приоритетный)
    if ignoreData then
        table.remove(checkList, 1)
    end
    for index, pathPath in ipairs(checkList) do
        local path = pathPath .. name
        if bootloader.bootfs.exists(path) and not bootloader.bootfs.isDirectory(path) then
            return path
        end
    end
end

function bootloader.readFile(fs, path)
    local file, err = fs.open(path, "rb")
    if not file then return nil, err end

    local buffer = ""
    repeat
        local data = fs.read(file, math.huge)
        buffer = buffer .. (data or "")
    until not data
    fs.close(file)

    return buffer
end

function bootloader.writeFile(fs, path, data)
    local file, err = fs.open(path, "wb")
    if not file then return nil, err end
    local ok, err = fs.write(file, data)
    if not ok then
        pcall(fs.close, file)
        return nil, err
    end
    fs.close(file)
    return true
end

function bootloader.loadfile(path, mode, env)
    local data, err = bootloader.readFile(bootloader.bootfs, path)
    if not data then return nil, err end
    return load(data, "=" .. path, mode or "bt", env or _G)
end

function bootloader.dofile(path, env, ...)
    return assert(bootloader.loadfile(path, nil, env))(...)
end

------------------------------------ bootloader functions

function bootloader.unittests(path, ...)
    local fs = require("filesystem")
    local paths = require("paths")
    local programs = require("programs")

    for _, file in ipairs(fs.list(path)) do
        local lpath = paths.concat(path, file)
        local ok, state, log = assert(programs.execute(lpath, ...))
        if not ok then
            error("error \"" .. (state or "unknown error") .. "\" in unittest: " .. file, 0)
        elseif not state then
            error("warning unittest \"" .. file .. "\" \"" .. (log and (", log:\n" .. log) or "") .. "\"", 0)
        end
    end
end

function bootloader.autorunsIn(path, ...)
    local fs = require("filesystem")
    local paths = require("paths")
    local event = require("event")
    local programs = require("programs")

    for i, v in ipairs(fs.list(path)) do
        local full_path = paths.concat(path, v)

        local func, err = programs.load(full_path)
        if not func then
            event.errLog("err \"" .. (err or "unknown error") .. "\", to load program: " .. full_path)
        else
            local ok, err = pcall(func, ...)
            if not ok then
                event.errLog("err \"" .. (err or "unknown error") .. "\", in program: " .. full_path)
            end
        end        
    end
end

function bootloader.initScreen(gpu, screen, rx, ry)
    pcall(component.invoke, screen, "turnOn")
    pcall(component.invoke, screen, "setPrecise", false)

    if gpu.getScreen() ~= screen then
        gpu.bind(screen, false)
    end

    if gpu.setActiveBuffer and gpu.getActiveBuffer() ~= 0 then
        gpu.setActiveBuffer(0)
    end
    
    local mx, my = gpu.maxResolution()
    rx = rx or mx
    ry = ry or my
    if rx > mx then rx = mx end
    if ry > my then ry = my end

    gpu.setDepth(1)
    gpu.setDepth(gpu.maxDepth())
    gpu.setResolution(rx, ry)
    gpu.setBackground(0)
    gpu.setForeground(0xFFFFFF)
    gpu.fill(1, 1, rx, ry, " ")

    return rx, ry
end

function bootloader.bootstrap()
    if bootloader.runlevel ~= "init" then error("bootstrap can only be started with runlevel init", 0) end

    --natives позваляет получить доступ к нетронутым методами библиотек computer и component
    _G.natives = bootloader.dofile("/system/core/lib/natives.lua", bootloader.createEnv())

    --на lua 5.3 нет встроеной либы bit32, но она нужна для совместимости, так что хай будет
    if not bit32 then 
        _G.bit32 = bootloader.dofile("/system/core/lib/bit32.lua", bootloader.createEnv())
    end

    --бут скрипты
    do 
        local path = "/system/core/boot/"
        for i, v in ipairs(bootloader.bootfs.list(path) or {}) do
            bootloader.dofile(path .. v, _G)
        end
    end

    --инициализация библиотек
    bootloader.dofile("/system/core/luaenv/a_base.lua", bootloader.createEnv())
    local package = bootloader.dofile("/system/core/lib/package.lua", bootloader.createEnv(), bootloader)
    _G.require = package.require
    _G.computer = nil
    _G.component = nil
    _G.unicode = nil
    _G.natives = nil
    package.register("paths", "/system/core/lib/paths.lua")
    local filesystem = package.register("filesystem", "/system/core/lib/filesystem.lua")
    require("vcomponent", true) --подключения библиотеки виртуальных компонентов
    require("hook", true) --подключения библиотеки хуков
    local event = require("event", true)
    require("lastinfo", true)
    require("cache", true)

    --проверка целосности системы (юнит тесты)
    bootloader.unittests("/system/core/unittests")
    bootloader.unittests("/system/unittests")

    --запуск автозагрузочных файлов ядра и дистрибутива
    bootloader.autorunsIn("/system/core/luaenv")
    bootloader.autorunsIn("/system/core/autoruns")
    bootloader.autorunsIn("/system/autoruns")

    --инициализация
    bootloader.runlevel = "kernel"
    filesystem.init()
end

function bootloader.runShell(path, ...)
    --запуск оболочки дистрибутива
    if require("filesystem").exists(path) then
        bootloader.bootSplash("Starting The Shell...")
        assert(require("programs").load(path))(...)
    else
        bootloader.bootSplash("Shell Does Not Exist. Press Enter To Continue.")
        bootloader.waitEnter()
    end
end

------------------------------------ sysinit

local err = "unknown"
local lowLevelInitializerErr

local function doLowLevel(lowLevelInitializer)
    if bootloader.bootfs.exists(lowLevelInitializer) and not bootloader.bootfs.isDirectory(lowLevelInitializer) then
        local code, lerr = bootloader.loadfile(lowLevelInitializer)
        if code then
            local lowLevelInitializerResult = {xpcall(code, debug.traceback)}
            if not lowLevelInitializerResult[1] then
                err = lowLevelInitializerResult[2] or "unknown"
                lowLevelInitializerErr = true
            end
        else
            err = lerr or "unknown"
            lowLevelInitializerErr = true
        end
    end
end

doLowLevel("/system/lowlevel.lua")

------------------------------------ registry

local registry = {}
local getRegistry
do
    function getRegistry()
        if require then
            local result = {pcall(require, "registry")}
            if result[1] and type(result[2]) == "table" and type(result[2].data) == "table" then
                return result[2].data
            else
                return registry
            end
        else
            return registry
        end
    end

    local function serialize(value, path)
        local local_pairs = function(tbl)
            local mt = getmetatable(tbl)
            return (mt and mt.__pairs or pairs)(tbl)
        end

        local kw = {
            ["and"] = true,
            ["break"] = true,
            ["do"] = true,
            ["else"] = true,
            ["elseif"] = true,
            ["end"] = true,
            ["false"] = true,
            ["for"] = true,
            ["function"] = true,
            ["goto"] = true,
            ["if"] = true,
            ["in"] = true,
            ["local"] = true,
            ["nil"] = true,
            ["not"] = true,
            ["or"] = true,
            ["repeat"] = true,
            ["return"] = true,
            ["then"] = true,
            ["true"] = true,
            ["until"] = true,
            ["while"] = true
        }
        local id = "^[%a_][%w_]*$"
        local ts = {}
        local result_pack = {}
        local function recurse(current_value, depth)
            local t = type(current_value)
            if t == "number" then
                if current_value ~= current_value then
                    table.insert(result_pack, "0/0")
                elseif current_value == math.huge then
                    table.insert(result_pack, "math.huge")
                elseif current_value == -math.huge then
                    table.insert(result_pack, "-math.huge")
                else
                    table.insert(result_pack, tostring(current_value))
                end
            elseif t == "string" then
                table.insert(result_pack, (string.format("%q", current_value):gsub("\\\n", "\\n")))
            elseif
                t == "nil" or t == "boolean" or pretty and (t ~= "table" or (getmetatable(current_value) or {}).__tostring)
             then
                table.insert(result_pack, tostring(current_value))
            elseif t == "table" then
                if ts[current_value] then
                    error("tables with cycles are not supported")
                end
                ts[current_value] = true
                local f = table.pack(local_pairs(current_value))
                local i = 1
                local first = true
                table.insert(result_pack, "{")
                for k, v in table.unpack(f) do
                    if not first then
                        table.insert(result_pack, ",")
                        if pretty then
                            table.insert(result_pack, "\n" .. string.rep(" ", depth))
                        end
                    end
                    first = nil
                    local tk = type(k)
                    if tk == "number" and k == i then
                        i = i + 1
                        recurse(v, depth + 1)
                    else
                        if tk == "string" and not kw[k] and string.match(k, id) then
                            table.insert(result_pack, k)
                        else
                            table.insert(result_pack, "[")
                            recurse(k, depth + 1)
                            table.insert(result_pack, "]")
                        end
                        table.insert(result_pack, "=")
                        recurse(v, depth + 1)
                    end
                end
                ts[current_value] = nil -- allow writing same table more than once
                table.insert(result_pack, "}")
            else
                error("unsupported type: " .. t)
            end
        end
        recurse(value, 1)
        pcall(bootloader.writeFile, bootloader.bootfs, path, table.concat(result_pack))
    end

    local function unserialize(path)
        local content = bootloader.readFile(bootloader.bootfs, path)
        if content then
            local code = load("return " .. content, "=unserialize", "t", {math={huge=math.huge}})
            if code then
                local result = {pcall(code)}
                if result[1] and type(result[2]) == "table" then
                    return result[2]
                end
            end
        end
    end

    local registryPath = "/data/registry.dat"
    local mainRegistryPath = bootloader.find("registry.dat", true)

    if mainRegistryPath and not bootloader.bootfs.exists(registryPath) then
        pcall(bootloader.bootfs.makeDirectory, "/data")
        pcall(bootloader.writeFile, bootloader.bootfs, registryPath, bootloader.readFile(bootloader.bootfs, mainRegistryPath))
    end

    if bootloader.bootfs.exists(registryPath) then
        local reg = unserialize(registryPath)
        local mainReg = mainRegistryPath and unserialize(mainRegistryPath)
        if reg then
            if mainReg then
                local newKeysFound
                for key, value in pairs(mainReg) do
                    if reg[key] == nil then
                        reg[key] = value
                        newKeysFound = true
                    end
                end
                if newKeysFound then
                    serialize(reg, registryPath)
                end
            end
            registry = reg
        end
    end
end



------------------------------------ boot splash

do
    local gpu = component.proxy(component.list("gpu")() or "")
    if gpu and not getRegistry().disableLogo then
        for screen in component.list("screen") do
            bootloader.initScreen(gpu, screen)
        end
    end

    local logoPath = bootloader.find("logo.lua")
    local logoenv = {gpu = gpu, unicode = unicode, computer = computer, component = component, bootloader = bootloader}
    local logo = bootloader.loadfile(logoPath, nil, setmetatable(logoenv, {__index = _G}))
    
    function bootloader.bootSplash(text)
        if not logo or not gpu or getRegistry().disableLogo then return end
        logoenv.text = text
        for screen in component.list("screen") do
            logoenv.screen = screen
            logo()
        end
    end

    function bootloader.waitEnter()
        if not logo or not gpu or getRegistry().disableLogo then return end
        while true do
            local eventData = {computer.pullSignal()}
            if eventData[1] == "key_down" then
                if eventData[4] == 28 then
                    return
                end
            end
        end
    end
end

------------------------------------ recovery

if not getRegistry().disableRecovery then
    local gpu = component.proxy(component.list("gpu")() or "")
    if gpu and component.list("screen")() then
        bootloader.bootSplash("Press R to open recovery menu")

        local recoveryScreen, playerNickname
        local startTime = computer.uptime()
        while computer.uptime() - startTime <= 1 do
            local eventData = {computer.pullSignal(0.1)}
            if eventData[1] == "key_down" and eventData[4] == 19 then
                for address in component.list("screen") do
                    local keyboards = component.invoke(address, "getKeyboards")
                    for i, keyboard in ipairs(keyboards) do
                        if keyboard == eventData[2] then
                            recoveryScreen = address
                            playerNickname = eventData[6]
                            goto exit
                        end
                    end
                end
            end
        end
        ::exit::

        if recoveryScreen then
            bootloader.bootSplash("RECOVERY MODE")

            local recoveryPath = bootloader.find("recovery.lua")
            if recoveryPath then
                if getRegistry().disableLogo then --если лого отключено, то экран не был инициализирован ранее, а значит его нада инициализировать сейчас
                    bootloader.initScreen(gpu, recoveryScreen)
                end
                
                local env = bootloader.createEnv()
                env.bootloader = bootloader
                assert(xpcall(assert(bootloader.loadfile(recoveryPath, nil, env)), debug.traceback, recoveryScreen, playerNickname))
                computer.shutdown("fast")
            else
                bootloader.bootSplash("failed to open recovery. press enter to continue")
                bootloader.waitEnter()
            end
        end
    end
end

------------------------------------ bootstrap

bootloader.bootSplash("Booting...")
bootloader.yield()

if not lowLevelInitializerErr then
    doLowLevel("/likeOS_startup.lua") --может использоваться для запуска обновления системы

    if not lowLevelInitializerErr then
        local bootstrapResult = {xpcall(bootloader.bootstrap, debug.traceback)}
        bootloader.yield()

        if bootstrapResult[1] then
            local shellResult = {xpcall(bootloader.runShell, debug.traceback, bootloader.defaultShellPath)}
            bootloader.yield()

            if not shellResult[1] then
                err = tostring(shellResult[2])
            end
        else
            err = tostring(bootstrapResult[2])
        end
    end
end

------------------------------------ log error

local log_ok
if require and pcall then
    local function local_require(name)
        local result = {pcall(require, name)}
        if result[1] and type(result[2]) == "table" then
            return result[2]
        end
    end
    local event = local_require("event")
    if event and event.errLog then
        log_ok = pcall(event.errLog, "global error: " .. tostring(err))
    end
end

------------------------------------ error output

if log_ok and not getRegistry().disableAutoReboot then --если удалось записать log то комп перезагрузиться, а если не удалось то передаст ошибку в bios
    shutdown(true)
end
error(err, 0)system/core/lib/archiver/formats/afpx.lua 4010 local fs = require("filesystem")
local paths = require("paths")
local unicode = require("unicode")

--------------------------------------------

--afp - archive files pack
local nullchar = string.char(0)

--------------------------------------------

local function tableRemove(tbl, dat)
    local count = 0
    for k, v in pairs(tbl) do
        if v == dat then
            count = count + 1
            tbl[k] = nil
        end
    end
    return count > 0
end

local afpx = {}

function afpx.pack(dir, outputpath)
    local files = {}
    local function process()
        local outputfile = assert(fs.open(outputpath, "wb"))
        table.insert(files, outputfile)
        assert(outputfile.write("AFP_____"))

        local function addfile(path)
            local full_path = paths.concat(dir, path)
            assert(outputfile.write(path:sub(2, #path) .. nullchar))
            assert(outputfile.write(tostring(math.floor(fs.size(full_path))) .. nullchar))

            local file, err = fs.open(full_path, "rb")
            if not file then error("error: " .. err .. " to open file " .. full_path, 0) end
            table.insert(files, file)
            while true do
                local data = file.read(math.huge)
                if not data then break end
                assert(outputfile.write(data))
            end
            tableRemove(files, file)
            file.close()
        end
        local function recurse(ldir)
            local archpath = unicode.sub(ldir, unicode.len(dir) + 1, unicode.len(ldir))
            if archpath:sub(1, 1) ~= "/" then archpath = "/" .. archpath end

            for _, path in ipairs(fs.list(ldir)) do
                local full_path = paths.concat(ldir, path)

                if full_path ~= outputpath then
                    if fs.isDirectory(full_path) then
                        recurse(full_path)
                    else
                        addfile(paths.concat(archpath, path))
                    end
                end
            end
        end
        recurse(dir)
        tableRemove(files, outputfile)
        outputfile.close()
    end

    local ret = {pcall(process)}
    for i, v in ipairs(files) do
        v.close()
    end
    return table.unpack(ret)
end

function afpx.unpack(inputpath, dir)
    local files = {}
    local function process()
        local inputfile = assert(fs.open(inputpath, "rb"))
        table.insert(files, inputfile)

        local signature = inputfile.read(8)
        if signature == "AFP_____" then --archive files pack
            local function read()
                local data = ""
                while true do
                    local ldata = inputfile.read(1)
                    if not ldata or ldata == nullchar then break end
                    data = data .. ldata
                end
                return data
            end
            while true do
                local path = read()
                if path == "" then break end
                if path:find("%.%.") then error("this archive is broken", 2) end
                local filesize = tonumber(read())

                local path = paths.concat(dir, path)
                fs.makeDirectory(paths.path(path))
                local file = assert(fs.open(path, "wb"))
                table.insert(files, file)
                while true do
                    local data = inputfile.read(filesize)
                    if not data then break end
                    filesize = filesize - #data
                    assert(file.write(data))
                    if filesize <= 0 then break end
                end
                tableRemove(files, file)
                file.close()
            end
        else
            error("this arhive format is not supported", 0)
        end

        tableRemove(files, inputfile)
        inputfile.close()
    end

    local ret = {pcall(process)}
    for i, v in ipairs(files) do
        v.close()
    end
    return table.unpack(ret)
end

afpx.unloadable = true
return afpxsystem/core/lib/archiver/formats/tar.lua 684 local fs = require("filesystem")
local paths = require("paths")
local unicode = require("unicode")

--------------------------------------------

local function tableRemove(tbl, dat)
    local count = 0
    for k, v in pairs(tbl) do
        if v == dat then
            count = count + 1
            tbl[k] = nil
        end
    end
    return count > 0
end

--------------------------------------------

local tar = {}

function tar.pack(dir, outputpath)
    dir = paths.canonical(dir)
    outputpath = paths.canonical(outputpath)
end

function tar.unpack(inputpath, dir)
    inputpath = paths.canonical(inputpath)
    dir = paths.canonical(dir)
end

tar.unloadable = true
return tarsystem/core/lib/archiver/init.lua 2024 local fs = require("filesystem")
local paths = require("paths")
local system = require("system")
local archiver = {}
archiver.formatsPath = system.getResourcePath("formats")
archiver.forceDriver = nil
archiver.supported = {}
for i, name in ipairs(fs.list(archiver.formatsPath)) do
    archiver.supported[i] = paths.hideExtension(paths.name(name))
end

function archiver.findDriver(path, custom)
    if archiver.forceDriver then
        if fs.exists(archiver.forceDriver) then
            return require(archiver.forceDriver)
        end
    else
        local function fromSignature()
            local signature = fs.readSignature(path)
            if signature == "AFP_____" then
                return "afpx"
            else
                return "tar"
            end
        end

        local function driver(exp)
            local formatDriverPath = paths.concat(archiver.formatsPath, exp .. ".lua")
            if fs.exists(formatDriverPath) then
                return require(formatDriverPath)
            end
        end

        local exp = custom or paths.extension(path)
        if exp then
            local lib = driver(exp)
            if lib then
                return lib
            else
                return driver(fromSignature())
            end
        else
            return driver(fromSignature())
        end
    end
end

function archiver.pack(dir, outputpath, custom)
    dir = paths.canonical(dir)
    outputpath = paths.canonical(outputpath)

    local driver = archiver.findDriver(outputpath, custom)
    if driver then
        return driver.pack(dir, outputpath)
    else
        return nil, "unknown archive format"
    end
end

function archiver.unpack(inputpath, dir, custom)
    inputpath = paths.canonical(inputpath)
    dir = paths.canonical(dir)

    local driver = archiver.findDriver(inputpath, custom)
    if driver then
        return driver.unpack(inputpath, dir)
    else
        return nil, "unknown archive format"
    end
end

archiver.unloadable = true
return archiversystem/core/lib/bit32.lua 2375 local bit32 = {} --bit32 нет в lua5.3, библиотека нужна для совместимости

-------------------------------------------------------------------------------

local function fold(init, op, ...)
  local result = init
  local args = table.pack(...)
  for i = 1, args.n do
    result = op(result, args[i])
  end
  return result
end

local function trim(n)
  return n & 0xFFFFFFFF
end

local function mask(w)
  return ~(0xFFFFFFFF << w)
end

function bit32.arshift(x, disp)
  return x // (2 ^ disp)
end

function bit32.band(...)
  return fold(0xFFFFFFFF, function(a, b) return a & b end, ...)
end

function bit32.bnot(x)
  return ~x
end

function bit32.bor(...)
  return fold(0, function(a, b) return a | b end, ...)
end

function bit32.btest(...)
  return bit32.band(...) ~= 0
end

function bit32.bxor(...)
  return fold(0, function(a, b) return a ~ b end, ...)
end

local function fieldargs(f, w)
  w = w or 1
  assert(f >= 0, "field cannot be negative")
  assert(w > 0, "width must be positive")
  assert(f + w <= 32, "trying to access non-existent bits")
  return f, w
end

function bit32.extract(n, field, width)
  local f, w = fieldargs(field, width)
  return (n >> f) & mask(w)
end

function bit32.replace(n, v, field, width)
  local f, w = fieldargs(field, width)
  local m = mask(w)
  return (n & ~(m << f)) | ((v & m) << f)
end

function bit32.lrotate(x, disp)
  if disp == 0 then
    return x
  elseif disp < 0 then
    return bit32.rrotate(x, -disp)
  else
    disp = disp & 31
    x = trim(x)
    return trim((x << disp) | (x >> (32 - disp)))
  end
end

function bit32.lshift(x, disp)
  return trim(x << disp)
end

function bit32.rrotate(x, disp)
  if disp == 0 then
    return x
  elseif disp < 0 then
    return bit32.lrotate(x, -disp)
  else
    disp = disp & 31
    x = trim(x)
    return trim((x >> disp) | (x << (32 - disp)))
  end
end

function bit32.rshift(x, disp)
  return trim(x >> disp)
end

-------------------------------------------------------------------------------

function bit32.readbit(byte, index)
  return byte >> index & 1 == 1
end

function bit32.writebit(byte, index, newstate)
  local current = bit32.readbit(byte, index)

  if current ~= newstate then
    if newstate then
      byte = byte + (2 ^ index)
    else
      byte = byte - (2 ^ index)
    end
  end

  return math.floor(byte)
end

return bit32
system/core/lib/cache.lua 5782 local fs = require("filesystem")
local paths = require("paths")
local event = require("event")
local package = require("package")
local computer = require("computer")

local runtimeCache = "/data/cache/runtime"
fs.remove(runtimeCache)

--------------------------------------------------

local cache = {}

local function formatType(obj, objtype)
    if objtype == "number" then
        return tonumber(obj)
    elseif objtype == "boolean" then
        return toboolean(obj)
    else
        return obj
    end
end

cache.hddCacheMt = {}
function cache.hddCacheMt:__index(key)
    if cache.cache.caches and cache.cache.caches[self._folder] then
        for name, value in pairs(cache.cache.caches[self._folder]) do
            if paths.hideExtension(name) == key then
                return formatType(value, paths.extension(name))
            end
        end
    end

    if not cache.cache.caches then cache.cache.caches = {} end
    if not cache.cache.caches[self._folder] then cache.cache.caches[self._folder] = {} end

    for _, name in ipairs(fs.list(self._folder)) do
        local lkey = paths.hideExtension(name)
        if lkey == key then
            local objtype = paths.extension(name)
            local valuename = key .. "." .. objtype
            local path = paths.concat(self._folder, valuename)
            if fs.exists(path) then
                if fs.isDirectory(path) then
                    local tbl = cache.createHddCache(path)
                    cache.cache.caches[self._folder][valuename] = tbl
                    return tbl
                else
                    local str = fs.readFile(path)
                    fs.remove(path)

                    local obj = formatType(str, objtype)
                    cache.cache.caches[self._folder][valuename] = obj
                    return obj
                end
            end
        end
    end
end

function cache.hddCacheMt:__newindex(key, value)
    local valuetype = type(value)
    key = tostring(key)
    local valuename = key .. "." .. valuetype
    local path = paths.concat(self._folder, valuename)

    if not cache.cache.caches then cache.cache.caches = {} end
    if not cache.cache.caches[self._folder] then cache.cache.caches[self._folder] = {} end

    if valuetype == "number" or valuetype == "string" or valuetype == "boolean" then
        cache.cache.caches[self._folder][valuename] = tostring(value)
    elseif valuetype == "nil" then
        cache.cache.caches[self._folder][valuename] = nil
        fs.remove(path)
    elseif valuetype == "table" then
        local tbl = cache.createHddCache(path, value)
        cache.cache.caches[self._folder][valuename] = tbl
        return tbl
    else
        error("the cache does not support the type: " .. key, 2)
    end
end

function cache.hddCacheMt:__pairs()
    local tbl = {}
    for _, name in ipairs(fs.list(self._folder)) do
        local key = paths.hideExtension(name)
        tbl[key] = formatType(self[key], paths.extension(name))
    end
    if cache.cache.caches and cache.cache.caches[self._folder] then
        for name, value in pairs(cache.cache.caches[self._folder]) do
            tbl[paths.hideExtension(name)] = formatType(value, paths.extension(name))
        end
    end
    return pairs(tbl)
end

-------------------------------------------------- unloader

local function cacheMode(tbl, state)
    local mt = getmetatable(tbl)
    if mt then
        if state then
            mt.__mode = 'v'
        else
            mt.__mode = nil
        end
    else
        mt = {}
        if state then
            mt.__mode = 'v'
        end
        setmetatable(tbl, mt)
    end
end

local unloaderTables = {}

local currentUnloadState = false
local function setUnloadState(state)
    if currentUnloadState == state then return end
    currentUnloadState = state
    for i, tbl in ipairs(unloaderTables) do
        cacheMode(tbl, state)
    end
end

local oldFree
event.timer(2, function()
    --check RAM
    local free = computer.freeMemory()
    if not oldFree or free > oldFree then --проверка сборшика мусора
        if free < computer.totalMemory() / 5 then
            setUnloadState(true)
            cache.clearCache()
        else
            setUnloadState(false)
        end
    end
    oldFree = free
end, math.huge)

function cache.attachUnloader(tbl)
    cacheMode(tbl, currentUnloadState)
    table.insert(unloaderTables, tbl)
end

cache.attachUnloader(package.libStubsCache)
cache.attachUnloader(package.cache)

--------------------------------------------------

function cache.createHddCache(folder, base)
    local tbl
    if base then
        tbl = base
        tbl._folder = paths.canonical(folder)
    else
        tbl = {_folder = paths.canonical(folder)}
    end
    return setmetatable(tbl, cache.hddCacheMt)
end

function cache.clearCache()
    if cache.cache.caches then
        for lpath, tbl in pairs(cache.cache.caches) do
            for valuename, value in pairs(tbl) do
                local path = paths.concat(lpath, valuename)
                local valuetype = type(value)

                if valuetype == "number" or valuetype == "string" or valuetype == "boolean" then
                    fs.writeFile(path, tostring(value))
                elseif valuetype == "table" then
                    fs.makeDirectory(path)
                end
            end
        end
    end

    for key, value in pairs(cache.cache) do
        cache.cache[key] = nil
    end
    cache.cache = {}
end

cache.cache = {} --can be cleaned at any time
cache.static = {} --can write the data of the unloadable library in order not to lose it when unloading
cache.data = cache.createHddCache(runtimeCache) --it can be cached on the hard disk if there is a lack of RAM

return cachesystem/core/lib/clipboard.lua 673 local cache = require("cache")
local component = require("component")
local clipboard = {}
clipboard.realClipboard = true
clipboard.defaultUser = "default"

function clipboard.get(user)
    if not cache.data.clipboard then cache.data.clipboard = {} end
    return cache.data.clipboard[user or clipboard.defaultUser]
end

function clipboard.set(user, content)
    if not cache.data.clipboard then cache.data.clipboard = {} end
    cache.data.clipboard[user or clipboard.defaultUser] = content

    if content and clipboard.realClipboard and component.debug then
        component.debug.sendToClipboard(user, content)
    end
end

clipboard.unloadable = true
return clipboardsystem/core/lib/colors.lua 2096 ---- base
local colors = {
    [0] = "white",
    [1] = "orange",
    [2] = "magenta",
    [3] = "lightBlue",
    [4] = "yellow",
    [5] = "lime",
    [6] = "pink",
    [7] = "gray",
    [8] = "lightGray",
    [9] = "cyan",
    [10] = "purple",
    [11] = "blue",
    [12] = "brown",
    [13] = "green",
    [14] = "red",
    [15] = "black"
}

---- reverse
do
    local keys = {}
    for k in pairs(colors) do
        table.insert(keys, k)
    end
    for _, k in pairs(keys) do
        colors[colors[k]] = k
    end
end

---- links
colors.silver = colors.lightGray
colors.lightGreen = colors.lime
colors.lightblue = colors.lightBlue
colors.lightgray = colors.lightGray
colors.lightgreen = colors.lightGreen

---- functions
function colors.hsvToRgb(h, s, v)
    h = h / 255
    s = s / 255
    v = v / 255

    local r, g, b

    local i = math.floor(h * 6);

    local f = h * 6 - i;
    local p = v * (1 - s);
    local q = v * (1 - f * s);
    local t = v * (1 - (1 - f) * s);

    i = math.floor(i % 6)

    if i == 0 then
        r, g, b = v, t, p
    elseif i == 1 then
        r, g, b = q, v, p
    elseif i == 2 then
        r, g, b = p, v, t
    elseif i == 3 then
        r, g, b = p, q, v
    elseif i == 4 then
        r, g, b = t, p, v
    elseif i == 5 then
        r, g, b = v, p, q
    end

    r = math.floor(r * 255)
    g = math.floor(g * 255)
    b = math.floor(b * 255)

    return r, g, b
end

function colors.blend(r, g, b)
    r = math.floor(r)
    g = math.floor(g)
    b = math.floor(b)
    return math.floor(b + (g * 256) + (r * 256 * 256))
end

function colors.unBlend(color)
    color =  math.floor(color)
    local blue = color % 256
    local green = (color // 256) % 256
    local red = (color // (256 * 256)) % 256
    return math.floor(red), math.floor(green), math.floor(blue)
end

function colors.colorMul(color, mul)
    local r, g, b = colors.unBlend(color)
    return colors.blend(
        math.clampRound(r * mul, 0, 255),
        math.clampRound(g * mul, 0, 255),
        math.clampRound(b * mul, 0, 255)
    )
end

colors.unloadable = true
return colorssystem/core/lib/event.lua 13032 local computer = require("computer")
local component = require("component")
local fs = require("filesystem")
local package = require("package")

local event = {}
event.minTime = 0 --минимальное время прирывания, можно увеличить, это вызовет подения производительности но уменьшет энергопотребления
event.listens = {}

------------------------------------------------------------------------ functions

local function tableInsert(tbl, value) --кастомный insert с возвращения значения
    for i = 1, #tbl + 1 do
        if not tbl[i] then
            tbl[i] = value
            return i
        end
    end
end

local function runThreads(eventData)
    local thread = package.get("thread")
    if thread then
        local function find(tbl)
            local parsetbl = tbl.childs
            if not parsetbl then parsetbl = tbl end
            for i = #parsetbl, 1, -1 do
                local v = parsetbl[i]
                v:status()
                if v.dead or not v.thread or coroutine.status(v.thread) == "dead" then
                    table.remove(parsetbl, i)
                    v.thread = nil
                    v.dead = true
                elseif v.enable then --если поток спит или умер то его потомки так-же не будут работать
                    v.out = {thread.xpcall(v.thread, table.unpack(v.args or eventData))}
                    if not v.out[1] then
                        event.errLog("thread error: " .. tostring(v.out[2] or "unknown") .. "\n" .. tostring(v.out[3] or "unknown"))
                    end

                    v.args = nil
                    find(v)
                end
            end
        end
        find(thread.threads)
    end
end

local isListen = false
local function runCallback(isTimer, func, index, ...)
    isListen = true
    local ok, err = xpcall(func, debug.traceback, ...)
    isListen = false

    if ok then
        if err == false then --таймер/слушатель хочет отключиться
            event.listens[index].killed = true
            event.listens[index] = nil
        end
    else
        event.errLog((isTimer and "timer" or "listen") .. " error: " .. tostring(err or "unknown"))
    end
end

------------------------------------------------------------------------ functions

function event.stub()
    event.push("stub")
end

function event.errLog(data)
    require("logs").log(data)
end

function event.sleep(waitTime)
    waitTime = waitTime or 0.1

    local startTime = computer.uptime()
    repeat
        computer.pullSignal(waitTime - (computer.uptime() - startTime))
    until computer.uptime() - startTime >= waitTime
end

function event.yield()
    computer.pullSignal(event.minTime)
end

function event.events(timeout, types, maxcount) --получает эвенты пока сыпуться
    timeout = timeout or 0.1
    local eventList = {}
    local lastEventTime = computer.uptime()
    while true do
        local ctime = computer.uptime()
        local eventData = {computer.pullSignal(timeout)}
        if #eventData > 0 and (not types or types[eventData[1]]) then
            lastEventTime = ctime
            table.insert(eventList, eventData)
            if maxcount and #eventList >= maxcount then
                break
            end
        elseif ctime - lastEventTime > timeout then
            break
        end
    end
    return eventList
end

function event.wait() --ждать то тех пор пока твой поток не убьют
    event.sleep(math.huge)
end

function event.listen(eventType, func, th)
    checkArg(1, eventType, "string", "nil")
    checkArg(2, func, "function")
    return tableInsert(event.listens, {th = th, eventType = eventType, func = func, type = true}) --нет класический table.insert не подайдет, так как он не дает понять, нуда вставил значения
end

function event.timer(time, func, times, th)
    checkArg(1, time, "number")
    checkArg(2, func, "function")
    checkArg(3, times, "number", "nil")
    return tableInsert(event.listens, {th = th, time = time, func = func, times = times or 1, lastTime = computer.uptime(), type = false})
end

function event.cancel(num)
    checkArg(1, num, "number")

    local ok = not not event.listens[num]
    if ok then
        event.listens[num].killed = true
        event.listens[num] = nil
    end
    return ok
end

function event.pull(waitTime, ...) --реализует фильтер
    local filters = table.pack(...)

    if type(waitTime) == "string" then
        table.insert(filters, 1, waitTime)
        filters.n = filters.n + 1
        waitTime = math.huge
    elseif not waitTime then
        waitTime = math.huge
    end

    if filters.n == 0 then
        return computer.pullSignal(waitTime)
    end
    
    local startTime = computer.uptime()
    while true do
        local ltime = waitTime - (computer.uptime() - startTime)
        if ltime <= 0 then break end
        local eventData = {computer.pullSignal(ltime)}

        local ok = true
        for i = 1, filters.n do
            local value = filters[i]
            if value and value ~= eventData[i] then
                ok = false
                break
            end
        end

        if ok then
            return table.unpack(eventData)
        end
    end
end

------------------------------------------------------------------------ custom queue

local remove = table.remove
local insert = table.insert
local unpack = table.unpack

local raw_computer_pullSignal = computer.pullSignal
local customQueue = {}

local function computer_pullSignal(...)
    if #customQueue == 0 then
        return raw_computer_pullSignal(...)
    else
        return unpack(remove(customQueue, 1))
    end
end

function computer.pushSignal(...)
    insert(customQueue, {...})
end

------------------------------------------------------------------------ hyper methods

--имеет самый самый высокий приоритет из возможных
--не может быть как либо удален до перезагрузки
--вызываеться при каждом завершении pullSignal даже если события не пришло
--ошибки в функции переданой в hyperListen будут переданы в вызвавщий pullSignal
function event.hyperListen(func)
    checkArg(1, func, "function")
    local pullSignal = computer_pullSignal
    local unpack = table.unpack
    computer_pullSignal = function (time)
        local eventData = {pullSignal(time)}
        func(unpack(eventData))
        return unpack(eventData)
    end
end

function event.hyperTimer(func)
    checkArg(1, func, "function")
    local pullSignal = computer_pullSignal
    computer_pullSignal = function (time)
        func()
        return pullSignal(time)
    end
end

function event.hyperHook(func)
    checkArg(1, func, "function")
    local pullSignal = computer_pullSignal
    computer_pullSignal = function (time)
        return func(pullSignal(time))
    end
end

function event.hyperCustom(func)
    checkArg(1, func, "function")
    local pullSignal = computer_pullSignal
    computer_pullSignal = function (time)
        return func(pullSignal, time)
    end
end

------------------------------------------------------------------------ custom pullSignal

function computer.pullSignal(waitTime) --кастомный pullSignal для работы background процессов
    if isListen then
        error("cannot use the pullSignal in the listener", 2)
    end

    waitTime = waitTime or math.huge
    if waitTime < event.minTime then
        waitTime = event.minTime
    end

    local thread = package.get("thread")
    local current
    if thread then
        current = thread.current()
    end

    local startTime = computer.uptime()
    while true do
        local realWaitTime = waitTime - (computer.uptime() - startTime)
        local isEnd = realWaitTime <= 0

        for k, v in pairs(event.listens) do --очистка от дохлых таймеров и слушателей
            if v.killed or (v.th and v.th:status() == "dead") then
                v.killed = true
                event.listens[k] = nil
            end
        end

        if thread then
            realWaitTime = event.minTime
        else
            --поиск времени до первого таймера, что обязательно на него успеть
            for k, v in pairs(event.listens) do --нет ipairs неподайдет, так могут быть дырки
                if not v.type and not v.killed and v.th == current then
                    local timerTime = v.time - (computer.uptime() - v.lastTime)
                    if timerTime < realWaitTime then
                        realWaitTime = timerTime
                    end
                end
            end

            if realWaitTime < event.minTime then --если время ожидания получилось меньше минимального времени то ждать минимальное(да таймеры будут плыть)
                realWaitTime = event.minTime
            end
        end

        local eventData
        if current then
            eventData = {coroutine.yield()}
        else
            eventData = {computer_pullSignal(realWaitTime)} --обязательно повисеть в pullSignal
            if not isListen then
                runThreads(eventData)
            end
        end

        local isEvent = #eventData > 0
        for k, v in pairs(event.listens) do --таймеры. нет ipairs неподайдет, там могут быть дырки
            if not v.type and not v.killed and v.th == current then
                if not v.th or v.th:status() == "running" then
                    local uptime = computer.uptime() 
                    if uptime - v.lastTime >= v.time then
                        v.lastTime = uptime --ДО выполнения функции ресатаем таймер, чтобы тайминги не поплывали при долгих функциях
                        if v.times <= 0 then
                            v.killed = true
                            event.listens[k] = nil
                        else
                            runCallback(true, v.func, k)
                            v.times = v.times - 1
                            if v.times <= 0 then
                                v.killed = true
                                event.listens[k] = nil
                            end
                        end
                    end
                elseif v.th:status() == "dead" then
                    v.killed = true
                    event.listens[k] = nil
                end
            elseif isEvent and v.type and not v.killed and v.th == current then
                if not v.th or v.th:status() == "running" then
                    if not v.eventType or v.eventType == eventData[1] then
                        runCallback(false, v.func, k, table.unpack(eventData))
                    end
                elseif v.th:status() == "dead" then
                    v.killed = true
                    event.listens[k] = nil
                end
            end
        end

        if isEvent then
            return table.unpack(eventData)
        elseif isEnd then
            break
        end
    end
end

------------------------------------------------------------------------ shutdown processing

local shutdownHandlers = {
    [function ()
        local gpu = component.getReal("gpu", true)

        if gpu then
            local vcomponent = require("vcomponent")
            for screen in component.list("screen") do
                if not vcomponent.isVirtual(screen) then
                    if gpu.getScreen() ~= screen then gpu.bind(screen, false) end
                    if gpu.setActiveBuffer then gpu.setActiveBuffer(0) end
                    gpu.setDepth(1)
                    gpu.setDepth(gpu.maxDepth())
                    gpu.setBackground(0)
                    gpu.setForeground(0xFFFFFF)
                    gpu.setResolution(50, 16)
                    gpu.fill(1, 1, 50, 16, " ")
                end
            end
        end
    end] = true
}

function event.addShutdownHandler(func)
    shutdownHandlers[func] = true
end

function event.delShutdownHandler(func)
    shutdownHandlers[func] = nil
end

local shutdown = computer.shutdown
function computer.shutdown(mode)
    local logs = require("logs")
    for handler in pairs(shutdownHandlers) do
        logs.checkWithTag("shutdown handler error", pcall(handler))
    end
    pcall(shutdown, mode)
    event.wait()
end

os.sleep = event.sleep
event.push = computer.pushSignal
return eventsystem/core/lib/filesystem.lua 27861 local component = require("component")
local computer = require("computer")
local unicode = require("unicode")
local paths = require("paths")
local bootloader = require("bootloader")

------------------------------------ base

local filesystem = {}
filesystem.bootaddress = bootloader.bootaddress
filesystem.tmpaddress = bootloader.tmpaddress
filesystem.baseFileDirectorySize = 512 --задаеться к конфиге мода(по умалчанию 512 байт)

local srvList = {"/.data"}
local mountList = {}
local virtualDirectories = {}
local forceMode = false

local function startSlash(path)
    if unicode.sub(path, 1, 1) ~= "/" then
        return "/" .. path
    end
    return path
end

local function endSlash(path)
    if unicode.sub(path, unicode.len(path), unicode.len(path)) ~= "/" then
        return path .. "/"
    end
    return path
end

local function noEndSlash(path)
    if unicode.len(path) > 1 and unicode.sub(path, unicode.len(path), unicode.len(path)) == "/" then
        return unicode.sub(path, 1, unicode.len(path) - 1)
    end
    return path
end

local function ifSuccessful(func, ok, ...)
    if ok then
        func()
    end
    return ok, ...
end

local function isService(path)
    local proxy, proxyPath = filesystem.get(path)

    for _, checkpath in ipairs(srvList) do
        if paths.equals(checkpath, proxyPath) then
            return true
        end
    end

    return false
end

local function recursionDeleteAttribute(path)
    for _, fullpath in filesystem.recursion(path) do
        filesystem.clearAttributes(fullpath)
    end
end

local function recursionCloneAttribute(path, path2)
    forceMode = true
    for lpath, fullpath in filesystem.recursion(path) do
        local ok, err = filesystem.setAttributes(paths.concat(path2, lpath), filesystem.getAttributes(fullpath), true)
        if not ok then
            forceMode = false
            return nil, err
        end
    end
    forceMode = false
end

------------------------------------ mounting functions

function filesystem.mount(proxy, path)
    if type(proxy) == "string" then
        local lproxy, err = component.proxy(proxy)
        if not lproxy then
            return nil, err
        end
        proxy = lproxy
    end

    path = paths.absolute(path)
    filesystem.makeVirtualDirectory(paths.path(path))

    path = endSlash(path)
    for i, v in ipairs(mountList) do
        if v[2] == path then
            return nil, "another filesystem is already mounted here"
        end
    end

    table.insert(mountList, {proxy, path, {}})
    table.sort(mountList, function(a, b) --просто нужно, иначе все по бараде пойдет
        return unicode.len(a[2]) > unicode.len(b[2])
    end)

    return true
end

function filesystem.umount(pathOrProxy)
    if type(pathOrProxy) == "string" then
        pathOrProxy = endSlash(paths.absolute(pathOrProxy))
        for i, v in ipairs(mountList) do
            if v[2] == pathOrProxy then
                table.remove(mountList, i)
                return true
            end
        end
        return false
    else
        local flag = false
        for i, v in ipairs(mountList) do
            if v[1] == pathOrProxy then
                table.remove(mountList, i)
                flag = true
            end
        end
        return flag
    end
end

function filesystem.mounts()
    local list = {}
    for i, v in ipairs(mountList) do
        local proxy, path = v[1], v[2]
        list[path] = v
        list[proxy.address] = v
        list[proxy] = v
        list[i] = v
    end
    return list
end

function filesystem.point(addressOrProxy)
    local mounts = filesystem.mounts()
    if mounts[addressOrProxy] then
        return noEndSlash(mounts[addressOrProxy][2])
    end
end

function filesystem.get(path, allowProxy)
    local function returnData(lpath, i)
        return mountList[i][1], lpath, mountList[i][3]
    end

    -- find from proxy
    if allowProxy and type(path) == "table" then
        for i = 1, #mountList do
            if mountList[i][1] == path then
                return returnData("/", i)
            end
        end
        return
    end

    -- find from path
    path = endSlash(paths.absolute(path))
    
    for i = #mountList, 1, -1 do
        local mount = mountList[i]
        if not mount[1].virtual and component.isConnected and not component.isConnected(mount[1]) then
            table.remove(mountList, i)
        end
    end

    for i = 1, #mountList do
        if unicode.sub(path, 1, unicode.len(mountList[i][2])) == mountList[i][2] then
            return returnData(noEndSlash(startSlash(unicode.sub(path, unicode.len(mountList[i][2]) + 1, unicode.len(path)))), i)
        end
    end

    if mountList[1] then
        return mountList[1][1], mountList[1][2], mountList[1][3]
    end
end

------------------------------------ main functions

function filesystem.exists(path)
    path = paths.absolute(path)
    if virtualDirectories[path] or paths.equals(path, "/") then
        return true
    end
    
    for i, v in ipairs(mountList) do
        if v[2] == path then
            return true
        end
    end

    local proxy, proxyPath = filesystem.get(path)
    return proxy.exists(proxyPath)
end

function filesystem.size(path)
    local proxy, proxyPath = filesystem.get(path)
    local size, sizeWithBaseCost = 0, 0
    local filesCount, dirsCount = 0, 0

    local function recurse(lpath)
        sizeWithBaseCost = sizeWithBaseCost + filesystem.baseFileDirectorySize
        for _, filename in ipairs(proxy.list(lpath)) do
            local fullpath = paths.concat(lpath, filename)
            if proxy.isDirectory(fullpath) then
                recurse(fullpath)
                dirsCount = dirsCount + 1
            else
                local lsize = proxy.size(fullpath)
                size = size + lsize
                sizeWithBaseCost = sizeWithBaseCost + lsize + filesystem.baseFileDirectorySize
                filesCount = filesCount + 1
            end
        end
    end

    if proxy.isDirectory(proxyPath) then
        recurse(proxyPath)
        dirsCount = dirsCount + 1
    else
        local lsize = proxy.size(proxyPath)
        size = size + lsize
        sizeWithBaseCost = sizeWithBaseCost + lsize + filesystem.baseFileDirectorySize
        filesCount = filesCount + 1
    end

    return size, sizeWithBaseCost, filesCount, dirsCount
end

function filesystem.isDirectory(path)
    path = paths.absolute(path)
    if virtualDirectories[path] or paths.equals(path, "/") then
        return true
    end

    for i, v in ipairs(mountList) do
        if v[2] == path then
            return true
        end
    end

    local proxy, proxyPath = filesystem.get(path)
    return proxy.isDirectory(proxyPath)
end

function filesystem.isReadOnly(pathOrProxy)
    local proxy, proxyPath, mountData = filesystem.get(pathOrProxy, true)
    if mountData.ro ~= nil then return mountData.ro end
    mountData.ro = proxy.isReadOnly()
    return mountData.ro
end

function filesystem.isLabelReadOnly(pathOrProxy)
    local proxy, proxyPath, mountData = filesystem.get(pathOrProxy, true)
    if mountData.lro ~= nil then return mountData.lro end
    mountData.lro = not pcall(proxy.setLabel, proxy.getLabel() or nil)
    if mountData.lro then
        mountData.lro = not pcall(proxy.setLabel, proxy.getLabel() or "")
    end
    return mountData.lro
end

function filesystem.makeDirectory(path)
    local proxy, proxyPath = filesystem.get(path)
    return proxy.makeDirectory(proxyPath)
end

function filesystem.lastModified(path)
    local proxy, proxyPath = filesystem.get(path)
    return proxy.lastModified(proxyPath)
end

function filesystem.remove(path)
    path = paths.absolute(path)
    if virtualDirectories[path] then
        virtualDirectories[path] = nil
        return true
    end
    local proxy, proxyPath = filesystem.get(path)
    return ifSuccessful(function() recursionDeleteAttribute(path) end, proxy.remove(proxyPath))
end

function filesystem.list(path, fullpaths, force)
    path = paths.absolute(path)
    local proxy, proxyPath = filesystem.get(path)
    local tbl = proxy.list(proxyPath) or {}

    -- virtual directories
    for lpath in pairs(virtualDirectories) do
        if paths.equals(paths.path(lpath), path) then
            table.insert(tbl, paths.name(lpath) .. "/")
        end
    end

    -- removing service objects
    if not force then
        for i = #tbl, 1, -1 do
            if isService(paths.concat(path, tbl[i])) then
                table.remove(tbl, i)
            end
        end
    end

    -- mounts
    for i = 1, #mountList do
        if paths.equals(path, paths.path(mountList[i][2])) then
            local mountName = paths.name(mountList[i][2])
            if mountName then
                table.insert(tbl, mountName .. "/")
            end
        end
    end

    -- full paths
    if fullpaths then
        for i, v in ipairs(tbl) do
            tbl[i] = paths.concat(path, v)
        end
    end

    -- sort & return
    table.sort(tbl)
    tbl.n = #tbl
    return tbl
end

function filesystem.rename(fromPath, toPath)
    fromPath = paths.absolute(fromPath)
    toPath = paths.absolute(toPath)
    if paths.equals(fromPath, toPath) then return end

    local fromProxy, fromProxyPath = filesystem.get(fromPath)
    local toProxy, toProxyPath = filesystem.get(toPath)

    recursionCloneAttribute(fromPath, toPath)

    if fromProxy.address == toProxy.address then
        return ifSuccessful(function() recursionDeleteAttribute(fromPath) end, fromProxy.rename(fromProxyPath, toProxyPath))
    else
        local success, err = filesystem.copy(fromPath, toPath)
        if not success then
            return nil, err
        end
        
        local success, err = filesystem.remove(fromPath)
        if not success then
            return nil, err
        end

        recursionDeleteAttribute(fromPath)
        return true
    end
end

function filesystem.open(path, mode, bufferSize)
    mode = mode or "rb"
    local proxy, proxyPath = filesystem.get(path)
    local result, reason = proxy.open(proxyPath, mode)
    if result then
        if bufferSize == true then
            bufferSize = 16 * 1024
        end

        local tool = mode:sub(#mode, #mode) == "b" and string or unicode
        local readBuffer
        local writeBuffer

        local handle
        handle = {
            handle = result,

            readLine = function()
                local str = ""
                while true do
                    local char = handle.read()
                    if not char then
                        if #str > 0 then
                            return str
                        end
                        return
                    elseif char == "\n" then
                        return str
                    else
                        str = str .. char
                    end
                end
            end,
            read = function(readsize)
                if not readsize then
                    readsize = 1
                end

                if bufferSize then
                    if not readBuffer then
                        readBuffer = proxy.read(result, bufferSize) or ""
                    end

                    local str = tool.sub(readBuffer, 1, readsize)
                    readBuffer = tool.sub(readBuffer, readsize + 1, tool.len(readBuffer))
                    if tool.len(readBuffer) == 0 then readBuffer = nil end
                    if tool.len(str) > 0 then
                        return str
                    end
                else
                    return proxy.read(result, readsize)
                end
            end,
            write = function(writedata)
                if bufferSize then
                    writeBuffer = (writeBuffer or "") .. writedata
                    if tool.len(writeBuffer) > bufferSize then
                        local result = proxy.write(result, writeBuffer)
                        writeBuffer = nil
                        return result
                    else
                        return true
                    end
                else
                    return proxy.write(result, writedata)
                end
            end,
            seek = function(whence, offset)
                if whence then
                    readBuffer = nil
                    if bufferSize and writeBuffer then
                        proxy.write(result, writeBuffer)
                    end
                end

                return proxy.seek(result, whence, offset)
            end,
            close = function(...)
                if writeBuffer then
                    return proxy.write(result, writeBuffer)
                end
                return proxy.close(result, ...)
            end,

            --don`t use with buffered mode!
            readAll = function()
                local buffer = ""
                repeat
                    local data = proxy.read(result, math.huge)
                    buffer = buffer .. (data or "")
                until not data
                return buffer
            end,
            readMax = function()
                return proxy.read(result, math.huge)
            end
        }
        return handle
    end
    return nil, reason
end

function filesystem.copy(fromPath, toPath, fcheck)
    fromPath = paths.absolute(fromPath)
    toPath = paths.absolute(toPath)
    if paths.equals(fromPath, toPath) then return end
    local function copyRecursively(fromPath, toPath)
        if not fcheck or fcheck(fromPath, toPath) then
            if filesystem.isDirectory(fromPath) then
                filesystem.makeDirectory(toPath)

                local list = filesystem.list(fromPath)
                for i = 1, #list do
                    local from = paths.concat(fromPath, list[i])
                    local to =  paths.concat(toPath, list[i])
                    local success, err = copyRecursively(from, to)
                    if not success then
                        return nil, err
                    end
                end
            else
                local fromHandle, err = filesystem.open(fromPath, "rb")
                if fromHandle then
                    local toHandle, err = filesystem.open(toPath, "wb")
                    if toHandle then
                        while true do
                            local chunk = fromHandle.read(math.huge)
                            if chunk then
                                if not toHandle.write(chunk) then
                                    return nil, "failed to write file"
                                end
                            else
                                toHandle.close()
                                fromHandle.close()

                                break
                            end
                        end
                    else
                        return nil, err
                    end
                else
                    return nil, err
                end
            end
        end

        return true
    end

    return ifSuccessful(function() recursionCloneAttribute(fromPath, toPath) end, copyRecursively(fromPath, toPath))
end

------------------------------------ additional functions

function filesystem.writeFile(path, data)
    filesystem.makeDirectory(paths.path(path))
    local file, err = filesystem.open(path, "wb")
    if not file then return nil, err or "unknown error" end
    local ok, err = file.write(data)
    if not ok then
        pcall(file.close)
        return err or "unknown error"
    end
    file.close()
    return true
end

function filesystem.readFile(path)
    local file, err = filesystem.open(path, "rb")
    if not file then return nil, err or "unknown error" end
    local result = {file.readAll()}
    file.close()
    return table.unpack(result)
end

function filesystem.readSignature(path, size)
    local file, err = filesystem.open(path, "rb")
    if not file then return nil, err or "unknown error" end
    local result = {file.read(size or 8)}
    file.close()
    return table.unpack(result)
end

function filesystem.equals(path1, path2)
    local file1 = assert(filesystem.open(path1, "rb"))
    local file2 = assert(filesystem.open(path2, "rb"))
    while true do
        local chunk1 = file1.readMax()
        local chunk2 = file2.readMax()
        if not chunk1 and not chunk2 then
            file1.close()
            file2.close()
            return true
        elseif chunk1 ~= chunk2 then
            file1.close()
            file2.close()
            return false
        end
    end
end

function filesystem.recursion(gpath)
    local function process(lpath)
        local fullpath = paths.concat(gpath, lpath)
        coroutine.yield({lpath, fullpath})

        if filesystem.isDirectory(fullpath) then
            for _, llpath in ipairs(filesystem.list(fullpath)) do
                process(paths.concat(lpath, llpath))
            end
        end
    end

    local t = coroutine.create(process)
    return function ()
        if coroutine.status(t) ~= "dead" then
            local _, info = coroutine.resume(t, "/")
            if type(info) == "table" then
                return table.unpack(info)
            end
        end
    end
end

function filesystem.spaceUsed(pathOrProxy)
    return filesystem.get(pathOrProxy, true).spaceUsed()
end

function filesystem.spaceTotal(pathOrProxy)
    return filesystem.get(pathOrProxy, true).spaceTotal()
end

function filesystem.spaceFree(pathOrProxy)
    local proxy = filesystem.get(pathOrProxy, true)
    return proxy.spaceTotal() - proxy.spaceUsed()
end

------------------------------------ virtual control functions

function filesystem.mask(tbl, readonly)
    local function isReadOnly()
        return not not (readonly or tbl.isReadOnly())
    end

    local proxy = {}

    for k, v in pairs(tbl) do
        proxy[k] = v
    end

    function proxy.isReadOnly()
        return isReadOnly()
    end

    function proxy.open(path, mode)
        mode = (mode or "r"):lower()
        if isReadOnly() and mode:sub(1, 1) == "w" then
            return nil, "filesystem is readonly"
        end
        return spcall(tbl.open, path, mode)
    end

    function proxy.remove(path)
        if isReadOnly() then
            return false
        end
        return spcall(tbl.remove, path)
    end

    function proxy.rename(path, path2)
        if isReadOnly() then
            return false
        end
        return spcall(tbl.rename, path, path2)
    end

    local proxy2 = {}
    for name, func in pairs(proxy) do
        proxy2[name] = setmetatable({}, {
            __tostring = function()
                return component.doc(filesystem.tmpaddress, name)
            end,
            __call = function(_, ...)
                return spcall(func, ...)
            end
        })
    end

    proxy2.address = tbl.address or require("uuid").next()
    proxy2.type = "filesystem"
    proxy2.virtual = true
    return proxy2
end

function filesystem.dump(gpath, readonly, maxSize, readonlyLabel)
    local maxLabelSize = 24
    local parent = filesystem.get(gpath)
    local proxy = {}
    
    local function repath(path)
        return paths.sconcat(gpath, path) or gpath
    end

    local function lrepath(path)
        local lpath = repath(path)
        local lparent, lparentPath = filesystem.get(lpath)
        if lparent ~= parent then
            return gpath
        else
            return lparentPath
        end
    end

    local function usedSize()
        return (select(2, filesystem.size(gpath)))
    end

    local function checkSize(writeCount)
        if maxSize then
            return (usedSize() + (writeCount or 0)) < maxSize
        else
            return true
        end
    end

    proxy.close = parent.close
    proxy.read = parent.read
    proxy.seek = parent.seek

    function proxy.write(handle, value)
        if not checkSize(#tostring(value)) then
            return nil, "not enough space"
        end
        return parent.write(handle, value)
    end

    function proxy.isReadOnly()
        return not not (readonly or parent.isReadOnly())
    end

    function proxy.spaceUsed()
        return usedSize()
    end

    function proxy.spaceTotal()
        return maxSize or parent.spaceTotal()
    end

    function proxy.open(path, mode)
        mode = (mode or "r"):lower()
        if mode:sub(1, 1) == "w" and not checkSize() then
            return nil, "not enough space"
        end
        return parent.open(lrepath(path), mode)
    end

    function proxy.isDirectory(path)
        return parent.isDirectory(lrepath(path))
    end

    function proxy.rename(path, path2)
        return parent.rename(lrepath(path), lrepath(path2))
    end

    function proxy.remove(path)
        return parent.remove(lrepath(path))
    end

    function proxy.remove(path)
        return parent.remove(lrepath(path))
    end

    function proxy.getLabel()
        return readonlyLabel or tostring(filesystem.getAttribute(gpath, "label") or "")
    end

    function proxy.setLabel(label)
        if readonlyLabel then
            error("label is readonly", 2)
        end
        if label then
            checkArg(1, label, "string")
        else
            label = ""
        end
        label = unicode.sub(label, 1, maxLabelSize)
        filesystem.setAttribute(gpath, "label", label)
        return label
    end

    function proxy.makeDirectory(path)
        if not checkSize() then
            return nil, "not enough space"
        end

        return parent.makeDirectory(lrepath(path))
    end

    function proxy.exists(path)
        return parent.exists(lrepath(path))
    end

    function proxy.list(path)
        return parent.list(lrepath(path))
    end

    function proxy.lastModified(path)
        return parent.lastModified(lrepath(path))
    end

    function proxy.size(path)
        return parent.size(lrepath(path))
    end

    return filesystem.mask(proxy, readonly)
end

function filesystem.makeVirtualDirectory(path)
    path = paths.absolute(path)
    if filesystem.exists(path) then
        return false
    end

    local parentPath = paths.path(path)
    if not filesystem.exists(parentPath) then
        filesystem.makeVirtualDirectory(parentPath)
    end
    
    virtualDirectories[path] = true
    return true
end

------------------------------------ attributes

local function attributesSystemData(path, data)
    data.dir = filesystem.isDirectory(path)
    return data
end

local function getAttributesPath(path)
    local proxy, proxyPath = filesystem.get(path)

    local attributeNumber = 0
    for i = 1, #proxyPath do
        local pathbyte = proxyPath:byte(i)
        attributeNumber = attributeNumber + (pathbyte * i)
    end
    attributeNumber = attributeNumber % 64

    return paths.concat(filesystem.point(proxy.address), paths.concat("/.data", ".attributes" .. tostring(math.round(attributeNumber))))
end

local function checkGlobalAttributes(proxy, globalAttributes)
    for path, data in pairs(globalAttributes) do
        local systemData = data[1]
        if not proxy.exists(path) or systemData.dir ~= proxy.isDirectory(path) then
            globalAttributes[path] = nil
        end
    end
end

local function cacheAttributes()
    local cache = require("cache")
    if not cache.cache.attributes then
        cache.cache.attributes = {}
    end
    return cache.cache.attributes
end

local function getGlobalAttributes(proxy, attributesPath) --attributesPath сдесь это глобальный путь
    local serialization = require("serialization")
    local cAttributes = cacheAttributes()

    local globalAttributes = cAttributes[attributesPath]
    if not globalAttributes and filesystem.exists(attributesPath) then
        globalAttributes = serialization.load(attributesPath)
        checkGlobalAttributes(proxy, globalAttributes)
        cAttributes[attributesPath] = globalAttributes
    end

    return globalAttributes or {}
end

local function saveGlobalAttributes(attributesPath, globalAttributes)
    local serialization = require("serialization")
    local cAttributes = cacheAttributes()

    if table.len(globalAttributes) > 0 then
        cAttributes[attributesPath] = globalAttributes
        return serialization.save(attributesPath, globalAttributes)
    elseif filesystem.exists(attributesPath) then
        cAttributes[attributesPath] = nil
        return filesystem.remove(attributesPath)
    else
        return true
    end
end


function filesystem.clearAttributes(path)
    local proxy, proxyPath = filesystem.get(path)
    local attributesPath = getAttributesPath(path)

    local globalAttributes = getGlobalAttributes(proxy, attributesPath)
    globalAttributes[proxyPath] = nil
    return saveGlobalAttributes(attributesPath, globalAttributes)
end

function filesystem.getAttributes(path)
    local proxy, proxyPath = filesystem.get(path)
    local attributesPath = getAttributesPath(path)
    local cAttributes = cacheAttributes()
    if cAttributes[attributesPath] or filesystem.exists(attributesPath) then
        local globalAttributes = cAttributes[attributesPath]
        if not globalAttributes then
            globalAttributes = require("serialization").load(attributesPath)
            checkGlobalAttributes(proxy, globalAttributes)
            cAttributes[attributesPath] = globalAttributes
        end

        if globalAttributes[proxyPath] then
            local systemData = globalAttributes[proxyPath][1]
            if systemData.dir == filesystem.isDirectory(path) then
                return globalAttributes[proxyPath][2] or {}
            end
        end
    end
    return {}
end

function filesystem.setAttributes(path, data)
    checkArg(1, path, "string")
    checkArg(2, data, "table")

    if not forceMode and not filesystem.exists(path) then
        return nil, "no such file or directory"
    end

    local proxy, proxyPath = filesystem.get(path)
    local attributesPath = getAttributesPath(path)
    local globalAttributes = getGlobalAttributes(proxy, attributesPath)

    local systemData
    if globalAttributes[proxyPath] then
        systemData = globalAttributes[proxyPath][1] or {}
    else
        systemData = {}
    end

    if table.len(data) > 0 then
        globalAttributes[proxyPath] = {attributesSystemData(path, systemData), data}
    else
        globalAttributes[proxyPath] = nil
    end

    return saveGlobalAttributes(attributesPath, globalAttributes)
end



function filesystem.getAttribute(path, key)
    return filesystem.getAttributes(path)[key]
end

function filesystem.setAttribute(path, key, value)
    local data = filesystem.getAttributes(path)
    data[key] = value
    return filesystem.setAttributes(path, data)
end

------------------------------------ init

assert(filesystem.mount(filesystem.bootaddress, "/"))
function filesystem.init()
    filesystem.init = nil

    assert(filesystem.mount(filesystem.tmpaddress, "/tmp"))
    assert(filesystem.mount(filesystem.tmpaddress, "/mnt/tmpfs"))
    assert(filesystem.mount(filesystem.bootaddress, "/mnt/root"))

    require("event").hyperListen(function (eventType, componentUuid, componentType)
        if componentType == "filesystem" then
            local path = paths.concat("/mnt", componentUuid)
            if eventType == "component_added" then
                filesystem.mount(component.proxy(componentUuid), path)
            elseif eventType == "component_removed" then
                filesystem.umount(path)
            end
        end
    end)

    for address in component.list("filesystem", true) do
        filesystem.mount(component.proxy(address), paths.concat("/mnt", address))
    end
end

return filesystemsystem/core/lib/graphic.lua 47929 local component = require("component")
local computer = require("computer")
local unicode = require("unicode")
local event = require("event")
local package = require("package")
local colors = require("colors")
local cache = require("cache")
local lastinfo = require("lastinfo")
local clipboardlib = require("clipboard")

local isSyntaxInstalled = package.isInstalled("syntax")
local isVGpuInstalled = package.isInstalled("vgpu")

------------------------------------

local graphic = {}
graphic.colorAutoFormat = true --рисует псевдографикой на первом тире оттенки серого
graphic.allowHardwareBuffer = false
graphic.allowSoftwareBuffer = false

graphic.screensBuffers = {}
graphic.updated = {}
graphic.windows = setmetatable({}, {__mode = "v"})
graphic.inputHistory = {}

graphic.cursorChar = "|"
graphic.hideChar = "*"
graphic.cursorColor = nil
graphic.selectColor = nil
graphic.selectColorFore = nil
graphic.defaultInputForeground = nil
graphic.defaultInputBackground = nil
graphic.fakePalette = nil

graphic.gpuPrivateList = {} --для приватизации видеокарт, дабы избежать "кражи" другими процессами, добовляйте так graphic.gpuPrivateList[gpuAddress] = true
graphic.vgpus = {}
graphic.bindCache = {}
graphic.topBindCache = {}

local function valueCheck(value)
    if value ~= value or value == math.huge or value == -math.huge then
        value = 0
    end
    return math.round(value)
end

------------------------------------class window

local function set(self, x, y, background, foreground, text, vertical, pal)
    local gpu = graphic.findGpu(self.screen)
    if gpu then
        gpu.setBackground(background, xor(self.isPal, pal))
        gpu.setForeground(foreground, xor(self.isPal, pal))
        gpu.set(valueCheck(self.x + (x - 1)), valueCheck(self.y + (y - 1)), text, vertical)
    end

    graphic.updated[self.screen] = true
end

local function get(self, x, y)
    local gpu = graphic.findGpu(self.screen)
    if gpu then
        return gpu.get(valueCheck(self.x + (x - 1)), valueCheck(self.y + (y - 1)))
    end
end

local function fill(self, x, y, sizeX, sizeY, background, foreground, char, pal)
    local gpu = graphic.findGpu(self.screen)
    if gpu then
        gpu.setBackground(background, xor(self.isPal, pal))
        gpu.setForeground(foreground, xor(self.isPal, pal))
        gpu.fill(valueCheck(self.x + (x - 1)), valueCheck(self.y + (y - 1)), valueCheck(sizeX), valueCheck(sizeY), char)
    end

    graphic.updated[self.screen] = true
end

local function copy(self, x, y, sizeX, sizeY, offsetX, offsetY)
    local gpu = graphic.findGpu(self.screen)
    if gpu then
        gpu.copy(valueCheck(self.x + (x - 1)), valueCheck(self.y + (y - 1)), valueCheck(sizeX), valueCheck(sizeY), valueCheck(offsetX), valueCheck(offsetY))
    end

    graphic.updated[self.screen] = true
end

local function clear(self, color, pal)
    self:fill(1, 1, self.sizeX, self.sizeY, color, color, " ", pal)
end

local function setCursor(self, x, y)
    self.cursorX, self.cursorY = valueCheck(x), valueCheck(y)
end

local function getCursor(self)
    return self.cursorX, self.cursorY
end

local function write(self, data, background, foreground, autoln, pal)
    graphic.updated[self.screen] = true
    local gpu = graphic.findGpu(self.screen)

    if gpu then
        local buffer = ""
        local setX, setY = self.cursorX, self.cursorY
        local function applyBuffer()
            gpu.set(self.x + (setX - 1), self.y + (setY - 1), buffer)
            buffer = ""
            setX, setY = self.cursorX, self.cursorY
        end

        local cpal = xor(self.isPal, pal)
        gpu.setBackground(background or (cpal and colors.black or 0), cpal)
        gpu.setForeground(foreground or (cpal and colors.white or 0xFFFFFF), cpal)

        for i = 1, unicode.len(data) do
            local char = unicode.sub(data, i, i)
            local ln = autoln and self.cursorX > self.sizeX
            local function setChar()
                --gpu.set(self.x + (self.cursorX - 1), self.y + (self.cursorY - 1), char)
                buffer = buffer .. char
                self.cursorX = self.cursorX + 1
            end
            if char == "\n" or ln then
                self.cursorY = self.cursorY + 1
                self.cursorX = 1
                applyBuffer()
                if ln then
                    setChar()
                end
            else
                setChar()
            end
        end

        applyBuffer()
    end
end

local function uploadEvent(self, eventData)
    local newEventData
    if eventData then
        if eventData[2] == self.screen and
        (eventData[1] == "touch" or eventData[1] == "drop" or eventData[1] == "drag" or eventData[1] == "scroll") then
            local oldSelected = self.selected
            local rePosX = (eventData[3] - self.x) + 1
            local rePosY = (eventData[4] - self.y) + 1
            local crePosX = math.ceil(rePosX)
            local crePosY = math.ceil(rePosY)
            self.selected = false

            local inside = crePosX >= 1 and crePosY >= 1 and crePosX <= self.sizeX and crePosY <= self.sizeY
            if inside or self.outsideEvents then
                self.selected = true
                newEventData = {eventData[1], eventData[2], rePosX, rePosY, eventData[5], eventData[6]}
            end

            if eventData[1] == "drop" then
                self.selected = oldSelected
            end
        elseif eventData[1] == "key_down" or eventData[1] == "key_up" or eventData[1] == "clipboard" then
            if table.exists(lastinfo.keyboards[self.screen], eventData[2]) then 
                newEventData = eventData
            end
        elseif eventData[1] == "softwareInsert" then --для подключения виртуальных клавиатур
            if eventData[2] == self.screen then
                newEventData = eventData
            end
        end
    end

    newEventData = newEventData or {}
    if not self.selected then
        newEventData = {}
    end
    newEventData.windowEventData = true
    return newEventData
end

local function toRealPos(self, x, y)
    return self.x + (x - 1), self.y + (y - 1)
end

local function toFakePos(self, x, y)
    return x - (self.x - 1), y - (self.y - 1)
end

local function readNoDraw(self, x, y, sizeX, background, foreground, preStr, hidden, buffer, clickCheck, syntax)
    local createdX
    if preStr then
        createdX = x
        x = x + #preStr
        sizeX = sizeX - #preStr
    end

    local sizeY = 1
    local isMultiline = sizeY ~= 1 --пока что не работает
    local whitelist

    local maxX, maxY = self.x + (x - 1) + (sizeX - 1), self.y + (y - 1) + (sizeY - 1)
    
    local disHistory = not not hidden
    local disableClipboard = not not hidden
    local maxDataSize = math.huge

    buffer = buffer or ""
    local lastBuffer = ""
    local allowUse = not clickCheck and self.selected
    local historyIndex
    
    local gpu = graphic.findGpu(self.screen)
    local depth = gpu.getDepth()

    if depth == 1 then
        syntax = nil
    end

    local function getPalColor(pal)
        if graphic.fakePalette then
            return graphic.fakePalette[pal] or 0
        else
            return gpu.getPaletteColor(pal)
        end
    end

    local function findColor(rgb, pal, bw)
        if self.isPal and depth > 1 then
            return pal
        else
            if depth == 8 then
                return rgb
            elseif depth == 4 then
                return getPalColor(pal)
            else
                return bw
            end
        end
    end

    background = background or graphic.defaultInputBackground or findColor(0x000000, colors.black, 0x000000)
    foreground = foreground or graphic.defaultInputForeground or findColor(0xffffff, colors.white, 0xffffff)
    local cursorColor     = graphic.cursorColor     or findColor(0x00ff00, colors.lightgreen, foreground)
    local selectColor     = graphic.selectColor     or findColor(0x0000ff, colors.blue,       foreground)
    local selectColorFore = graphic.selectColorFore
    if depth == 1 and not selectColorFore then
        selectColorFore = background
    end
    
    if not selectColor then
        if self.isPal and depth > 1 then
            selectColor = colors.blue
        else
            if depth == 8 then
                selectColor = 0x0000ff
            elseif depth == 4 then
                selectColor = getPalColor(colors.blue)
            else
                selectColor = 0xffffff
                selectColorFore = 0x000000
            end
        end
    end

    local title, titleColor

    local selectFrom
    local selectTo

    local offsetX = 0
    local offsetY = 0

    local lockState = false
    local drawLock = false

    local function getBackCol(i)
        if selectFrom then
            return (i >= selectFrom and i <= selectTo) and selectColor or background
        else
            return background
        end
    end

    local function getForeCol(i, def, pal)
        if pal then
            def = getPalColor(def)
        end
        if selectFrom and selectColorFore then
            return (i >= selectFrom and i <= selectTo) and selectColorFore or def
        else
            return def
        end
    end
    
    local function redraw()
        if drawLock then
            return drawLock
        end

        local gpu = graphic.findGpu(self.screen)
        if gpu then
            local cursorPos
            local str = buffer
            if allowUse and not lockState then
                --str = str .. "\0"
                cursorPos = unicode.len(str) + 1
                local nCursorPos = cursorPos + offsetX
                while nCursorPos < 1 do
                    offsetX = offsetX + 1
                    nCursorPos = cursorPos + offsetX
                end
                while nCursorPos > sizeX do
                    offsetX = offsetX - 1
                    nCursorPos = cursorPos + offsetX
                end
            end
            str = str .. lastBuffer

            --[[
            local num = (unicode.len(str) - sizeX) + 1
            if num < 1 then num = 1 end
            str = unicode.sub(str, num, unicode.len(str))

            str = str .. newLastBuffer
            if unicode.len(str) < sizeX then
                str = str .. string.rep(" ", sizeX - unicode.len(str))
            elseif unicode.len(str) > sizeX then
                str = unicode.sub(str, 1, sizeX)
            end
            ]]

            --local newstr = {}
            --[[
            local cursorPos
            for i = 1, unicode.len(str) do
                if unicode.sub(str, i, i) == "\0" then
                    cursorPos = i
                else
                    table.insert(newstr, unicode.sub(str, i, i))
                end
            end
            ]]


            local chars = {}
            for i = 1, unicode.len(str) do
                table.insert(chars, {hidden and graphic.hideChar or unicode.sub(str, i, i), getForeCol(i, foreground), getBackCol(i)})
            end
            if syntax == "lua" and isSyntaxInstalled then
                for index, value in ipairs(require("syntax").parse(str)) do
                    local isBreak
                    for i = 1, unicode.len(value[3]) do
                        local setTo = value[5] + (i - 1)
                        if not chars[setTo] then isBreak = true break end
                        chars[setTo] = {unicode.sub(value[3], i, i), getForeCol(i, value[4], true), getBackCol(setTo)}
                    end
                    if isBreak then break end
                end
            end

            if cursorPos then
                local cursorChar = {graphic.cursorChar, getForeCol(cursorPos, cursorColor), getBackCol(cursorPos)}
                if not pcall(table.insert, chars, cursorPos, cursorChar) then
                    table.insert(chars, cursorChar)
                end
            elseif #chars == 0 and title and titleColor then
                for i = 1, unicode.len(title) do
                    table.insert(chars, {unicode.sub(title, i, i), getForeCol(i, titleColor), getBackCol(i)})
                end
            end

            -- draw
            local defXpos = (self.x + (x - 1))
            local defYpos = (self.y + (y - 1))
            local xpos = (self.x + (x - 1))
            local ypos = (self.y + (y - 1))

            gpu.setForeground(foreground, self.isPal)
            gpu.setBackground(background, self.isPal)
            gpu.fill(xpos, ypos, sizeX, sizeY, " ")
            --graphic._fill(gpu, xpos, ypos, sizeX, sizeY, background, self.isPal, foreground, self.isPal, " ")
            if createdX then
                --graphic._set(gpu, createdX, y, background, self.isPal, foreground, self.isPal, preStr)
                local lx, ly = self:toRealPos(createdX, y)
                gpu.set(lx, ly, preStr)
            end

            --[[
            if chars[1] then
                local lines = {{}}
                for _, chr in ipairs(chars) do
                    if chr[1] == "\n" then
                        table.insert(lines, {})
                    else
                        table.insert(lines[#lines], chr)
                    end
                end
                while #lines[1] == 0 do
                    table.remove(lines, 1)
                    ypos = ypos + 1
                end

                if lines[1][1] then
                    for offY, line in ipairs(lines) do
                        for offX, chr in ipairs(line) do
                            local placeX = (xpos + offX + offsetX) - 1
                            local placeY = (ypos + offY + offsetY) - 1
                            if placeX >= xpos and placeX < xpos + sizeX then
                                if placeY >= ypos and placeY < ypos + sizeY then
                                    gpu.setForeground(chr[2], self.isPal)
                                    gpu.setBackground(chr[3], self.isPal)
                                    gpu.set(placeX, placeY, chr[1])
                                end
                            end
                        end
                    end
                end
            end
            ]]

            if chars[1] then
                local lines = {{}}
                for _, chr in ipairs(chars) do
                    if chr[1] == "\n" then
                        table.insert(lines, {})
                    else
                        table.insert(lines[#lines], chr)
                    end
                end
                while #lines[1] == 0 do
                    table.remove(lines, 1)
                    ypos = ypos + 1
                end

                if lines[1][1] then
                    local oldFore = lines[1][1][2]
                    local oldBack = lines[1][1][3]
                    local oldY = ypos
                    local buff = ""

                    for offY, line in ipairs(lines) do
                        for offX, chr in ipairs(line) do
                            if oldFore ~= chr[2] or oldBack ~= chr[3] or ypos ~= oldY then
                                --[[
                                local lmax = xpos + (unicode.len(buff) - 1)
                                if lmax > maxX then
                                    buff = unicode.sub(buff, 1, math.clamp(unicode.len(buff) - (lmax - maxX), 0, math.huge))
                                end
                                if ypos <= maxY then
                                    ]]
                                gpu.setForeground(oldFore, self.isPal)
                                gpu.setBackground(oldBack, self.isPal)

                                local xplace = xpos + offsetX
                                local yplace = ypos + offsetY
                                if yplace >= defYpos and yplace < defYpos + sizeY and xplace < defXpos + sizeX then
                                    while xplace < defXpos do
                                        buff = unicode.sub(buff, 2, unicode.len(buff))
                                        xplace = xplace + 1
                                    end
                                    while xplace + unicode.len(buff) > defXpos + sizeX do
                                        buff = unicode.sub(buff, 1, unicode.len(buff) - 1)
                                    end
                                    gpu.set(xplace, yplace, buff)
                                end
                                    --graphic._set(gpu, xpos, ypos, oldBack, self.isPal, oldFore, self.isPal, buff)
                                --end

                                buff = ""
                                xpos = self.x + ((x + offX) - 2)
                                oldY = ypos
                                oldFore = chr[2]
                                oldBack = chr[3]
                            end
                            buff = buff .. chr[1]
                        end
                        --[[
                        local lmax = xpos + (unicode.len(buff) - 1)
                        if lmax > maxX then
                            buff = unicode.sub(buff, 1, math.clamp(unicode.len(buff) - (lmax - maxX), 0, math.huge))
                        end
                        if ypos <= maxY then
                        ]]
                        gpu.setForeground(oldFore, self.isPal)
                        gpu.setBackground(oldBack, self.isPal)

                        local xplace = xpos + offsetX
                        local yplace = ypos + offsetY
                        if yplace >= defYpos and yplace < defYpos + sizeY and xplace < defXpos + sizeX then
                            while xplace < defXpos do
                                buff = unicode.sub(buff, 2, unicode.len(buff))
                                xplace = xplace + 1
                            end
                            while xplace + unicode.len(buff) > defXpos + sizeX do
                                buff = unicode.sub(buff, 1, unicode.len(buff) - 1)
                            end
                            gpu.set(xplace, yplace, buff)
                        end
                            --graphic._set(gpu, xpos, ypos, oldBack, self.isPal, oldFore, self.isPal, buff)
                        --end
                    
                        ypos = ypos + 1
                        xpos = self.x + (x - 1)
                        buff = ""
                    end
                end
            end
        end

        graphic.updated[self.screen] = true
    end

    local function isEmpty(str)
        for i = 1, unicode.len(str) do
            if unicode.sub(str, i, i) ~= " " then
                return false
            end
        end
        return true
    end

    local function addToHistory(newBuff)
        if not disHistory and graphic.inputHistory[1] ~= newBuff and not isEmpty(newBuff) then
            table.insert(graphic.inputHistory, 1, newBuff)
            while #graphic.inputHistory > 64 do
                table.remove(graphic.inputHistory, #graphic.inputHistory)
            end
        end
    end

    local function removeSelect()
        selectFrom = nil
        selectTo = nil
    end

    local function removeSelectedContent()
        if selectFrom then
            local newbuff = buffer .. lastBuffer
            local removed = unicode.sub(newbuff, selectFrom, selectTo)
            buffer = unicode.sub(newbuff, 1, selectFrom - 1)
            lastBuffer = unicode.sub(newbuff, selectTo + 1, unicode.len(buffer))
            removeSelect()
            return removed
        end
    end

    local function contrainBuffer()
        while true do
            local firstLen = unicode.len(buffer)
            local lastLen = unicode.len(lastBuffer)
            local currentLen = firstLen + lastLen
            if currentLen > maxDataSize then
                if firstLen > 0 then
                    buffer = unicode.sub(buffer, 1, firstLen - 1)
                else
                    lastBuffer = unicode.sub(lastBuffer, 2, lastLen)
                end
            else
                break
            end
        end
    end

    local function wlCheck(chr)
        return not whitelist or whitelist[chr]
    end

    local function add(inputStr)
        historyIndex = nil
        removeSelectedContent()
        for i = 1, unicode.len(inputStr) do
            local chr = unicode.sub(inputStr, i, i)
            if chr == "\n" then
                if isMultiline and wlCheck(chr) then
                    buffer = buffer .. chr
                else
                    return buffer
                end
            elseif not unicode.isWide(chr) and wlCheck(chr) then
                buffer = buffer .. chr
            end
        end
        contrainBuffer()
        redraw()
    end

    local function clipboard(inputStr, force)
        if (not disableClipboard or force) and inputStr then
            local out = add(inputStr)
            if out then
                removeSelect()
                addToHistory(out)
                return out
            end
        end
    end

    local function outFromRead()
        allowUse = false
        redraw()
    end

    return {setLock = function(lock)
        lockState = lock
    end, getLock = function()
        return not not lockState
    end, uploadEvent = function(eventData) --по идеи сюда нужно закидывать эвенты которые прошли через window:uploadEvent
        --вызывайте функцию и передавайте туда эвенты которые сами читаете, 
        --если функция чтото вернет, это результат, если он TRUE(не false) значет было нажато ctrl+w

        if lockState then return end

        if not eventData.windowEventData then --если это не эвент окна то делаем его таковым(потому что я криворукий и забываю об этом постоянно)
            eventData = self:uploadEvent(eventData)
        end

        if clickCheck then
            if self.selected then
                if eventData[1] == "touch" and eventData[2] == self.screen and eventData[5] == 0 then
                    removeSelect()
                    if eventData[3] >= x and eventData[3] < x + sizeX and eventData[4] == y then
                        allowUse = true
                        redraw()
                    else
                        allowUse = false
                        redraw()
                    end
                end
            elseif allowUse then
                removeSelect()
                allowUse = false
                redraw()
            end
        elseif self.selected ~= allowUse then
            removeSelect()
            allowUse = not not self.selected
            redraw()
        end

        if allowUse then
            if eventData[1] == "key_down" then
                if eventData[4] == 28 then
                    historyIndex = nil

                    if isMultiline then
                        add("\n")
                    else
                        local newBuff = buffer .. lastBuffer
                        removeSelect()
                        addToHistory(newBuff)
                        outFromRead()
                        return newBuff
                    end
                elseif eventData[4] == 200 then --up
                    if isMultiline then
                        local cursorPos = #buffer + 1

                        --need write movment code

                        local newBuff = buffer .. lastBuffer
                        buffer = newBuff:sub(1, cursorPos - 1)
                        lastBuffer = newBuff:sub(cursorPos, #newBuff)
                        redraw()
                    else
                        if not disHistory then
                            historyIndex = (historyIndex or 0) + 1
                            if not graphic.inputHistory[historyIndex] then
                                historyIndex = #graphic.inputHistory
                            end
                            if graphic.inputHistory[historyIndex] then
                                buffer = graphic.inputHistory[historyIndex]
                                lastBuffer = ""
                                removeSelect()
                                redraw()
                            else
                                historyIndex = nil
                            end
                        end
                    end
                elseif eventData[4] == 208 then --down
                    if not disHistory and historyIndex then
                        if graphic.inputHistory[historyIndex - 1] then
                            historyIndex = historyIndex - 1
                            buffer = graphic.inputHistory[historyIndex]
                            lastBuffer = ""
                        else
                            historyIndex = nil
                            buffer = ""
                            lastBuffer = ""
                        end
                        removeSelect()
                        redraw()
                    end
                elseif eventData[4] == 203 then -- <
                    if selectFrom then
                        lastBuffer = removeSelectedContent()
                    elseif unicode.len(buffer) > 0 then
                        lastBuffer = unicode.sub(buffer, -1, -1) .. lastBuffer
                        buffer = unicode.sub(buffer, 1, unicode.len(buffer) - 1)
                    end
                    redraw()
                elseif eventData[4] == 205 then -- >
                    if selectFrom then
                        buffer = removeSelectedContent()
                    elseif unicode.len(lastBuffer) > 0 then
                        buffer = buffer .. unicode.sub(lastBuffer, 1, 1)
                        lastBuffer = unicode.sub(lastBuffer, 2, unicode.len(lastBuffer))
                    end
                    redraw()
                elseif eventData[4] == 14 then --backspace
                    historyIndex = nil

                    if selectFrom then
                        removeSelectedContent()
                    elseif unicode.len(buffer) > 0 then
                        buffer = unicode.sub(buffer, 1, unicode.len(buffer) - 1)
                        removeSelect()
                    end
                    redraw()
                elseif eventData[3] == 23 and eventData[4] == 17 then --ctrl+w
                    historyIndex = nil
                    removeSelect()
                    outFromRead()
                    return true --exit ctrl+w
                elseif eventData[3] == 1 and eventData[4] == 30 then --ctrl+a
                    buffer = buffer .. lastBuffer
                    lastBuffer = ""
                    selectFrom = 1
                    selectTo = unicode.len(buffer)
                    redraw()
                elseif eventData[3] == 3 and eventData[4] == 46 then --ctrl+c
                    if selectFrom then
                        clipboardlib.set(eventData[5], unicode.sub(buffer .. lastBuffer, selectFrom, selectTo))
                        redraw()
                    end
                elseif eventData[3] == 24 and eventData[4] == 45 then --ctrl+x
                    if selectFrom then
                        clipboardlib.set(eventData[5], removeSelectedContent())
                        redraw()
                    end
                elseif eventData[3] == 22 and eventData[4] == 47 then --вставка с системного clipboard
                    local str = clipboard(clipboardlib.get(eventData[5]))
                    if str then outFromRead() return str end
                elseif eventData[4] == 211 then  --del
                    historyIndex = nil

                    if selectFrom then
                        removeSelectedContent()
                        redraw()
                    elseif unicode.len(lastBuffer) > 0 then
                        lastBuffer = unicode.sub(lastBuffer, 2, unicode.len(lastBuffer))
                        removeSelect()
                        redraw()
                    end
                elseif eventData[4] == 15 then --tab
                    add("  ")
                elseif eventData[3] > 0 then --any char
                    historyIndex = nil
                    local char = unicode.char(eventData[3])
                    if not unicode.isWide(char) and wlCheck(char) then
                        add(char)
                    end
                end
            elseif eventData[1] == "clipboard" then --вставка с реального clipboard
                local str = clipboard(eventData[3])
                if str then outFromRead() return str end
            elseif eventData[1] == "softwareInsert" then --для подключения виртуальных клавиатур
                local str = clipboard(eventData[3], true)
                if str then outFromRead() return str end
            end
        end
    end, redraw = redraw, getBuffer = function()
        return buffer .. lastBuffer
    end, setBuffer = function(v)
        buffer = v
        lastBuffer = ""
    end, setAllowUse = function(state)
        allowUse = state
    end, getAllowUse = function ()
        return allowUse
    end, setClickCheck = function (state)
        clickCheck = state
    end, getClickCheck = function ()
        return clickCheck
    end, add = add, setOffset = function (x, y)
        offsetX = x
        offsetY = y
    end, getOffset = function ()
        return offsetX, offsetY
    end, setAllowHistory = function (allow)
        disHistory = not allow
    end, setAllowClipboard = function (allow)
        disableClipboard = not allow
    end, setMaxStringLen = function (max)
        maxDataSize = max
    end, setTitle = function (t, tc)
        title, titleColor = t, tc
    end, setWhitelist = function(list)
        whitelist = list
    end, setDrawLock = function(state)
        drawLock = state
    end}
end

local function read(...)
    local reader = readNoDraw(...)
    reader.redraw()
    return reader
end

function graphic.createWindow(screen, x, y, sizeX, sizeY, selected, isPal)
    local obj = {
        screen = screen,
        x = x or 1,
        y = y or 1,
        sizeX = sizeX,
        sizeY = sizeY,
        cursorX = 1,
        cursorY = 1,

        readNoDraw = readNoDraw,
        read = read,
        toRealPos = toRealPos,
        toFakePos = toFakePos,
        set = set,
        get = get,
        fill = fill,
        copy = copy,
        clear = clear,
        uploadEvent = uploadEvent,
        write = write,
        getCursor = getCursor,
        setCursor = setCursor,
        isPal = isPal or false,
    }

    if not sizeX or not sizeY then
        local rx, ry = graphic.getResolution(screen)
        obj.sizeX = sizeX or rx
        obj.sizeY = sizeY or ry
    end

    if selected ~= nil then
        obj.selected = selected
    else
        obj.selected = false
    end

    if obj.selected then --за раз может быть активно только одно окно
        for i, window in ipairs(graphic.windows) do
            if window.screen == screen then
                window.selected = false
            end
        end
    end

    table.insert(graphic.windows, obj)
    return obj
end

------------------------------------ window methods

graphic.defaultWindows = {}

local function window(screen)
    local rx, ry = graphic.getResolution(screen)
    graphic.defaultWindows[screen] = graphic.defaultWindows[screen] or graphic.createWindow(screen, 1, 1, rx, ry)
    local window = graphic.defaultWindows[screen]
    window.sizeX = rx
    window.sizeY = ry
    return graphic.defaultWindows[screen]
end

function graphic.readNoDraw(screen, ...)
    return window(screen):readNoDraw(...)
end

function graphic.read(screen, ...)
    return window(screen):read(...)
end

function graphic.toRealPos(screen, ...)
    return window(screen):toRealPos(...)
end

function graphic.toFakePos(screen, ...)
    return window(screen):toFakePos(...)
end

function graphic.set(screen, ...)
    return window(screen):set(...)
end

function graphic.get(screen, ...)
    return window(screen):get(...)
end

function graphic.fill(screen, ...)
    return window(screen):fill(...)
end

function graphic.copy(screen, ...)
    return window(screen):copy(...)
end

function graphic.clear(screen, ...)
    return window(screen):clear(...)
end

function graphic.readNoDraw(screen, ...)
    return window(screen):readNoDraw(...)
end

function graphic.uploadEvent(screen, ...)
    return window(screen):uploadEvent(...)
end

function graphic.write(screen, ...)
    return window(screen):write(...)
end

function graphic.getCursor(screen, ...)
    return window(screen):getCursor(...)
end

function graphic.setCursor(screen, ...)
    return window(screen):setCursor(...)
end

------------------------------------

function graphic.unloadBuffer(screen)
    local gpu = graphic.findGpu(screen)

    graphic.bindCache[screen] = nil
    graphic.topBindCache[screen] = nil
    graphic.vgpus[screen] = nil

    if graphic.screensBuffers[screen] then
        gpu.freeBuffer(graphic.screensBuffers[screen])
    end
end

function graphic.unloadBuffers()
    for address in component.list("screen", true) do
        graphic.unloadBuffer(address)
    end
end

function graphic.findGpuAddress(screen, topOnly)
    local deviceinfo = lastinfo.deviceinfo
    if not deviceinfo[screen] then
        graphic.bindCache[screen] = nil
        graphic.topBindCache[screen] = nil
        graphic.vgpus[screen] = nil
        return
    end

    local bindCache = graphic.bindCache
    if topOnly then
        bindCache = graphic.topBindCache
    end

    if bindCache[screen] and not graphic.gpuPrivateList[bindCache[screen]] then
        return bindCache[screen]
    end

    local screenLevel = tonumber(deviceinfo[screen].capacity) or 0
    local bestGpuLevel = -math.huge
    local gpuLevel, bestGpu
    local function check(deep)
        for address in component.list("gpu") do
            local connectScr = component.invoke(address, "getScreen")
            local connectedAny = not not connectScr
            local connected = connectScr == screen

            if not graphic.gpuPrivateList[address] and (deep or connected) then
                gpuLevel = (tonumber(deviceinfo[address].capacity) or 0) / 1000

                if not topOnly then
                    if connectedAny and not connected then
                        gpuLevel = gpuLevel - 1000
                    else
                        if connected and gpuLevel == screenLevel then
                            gpuLevel = gpuLevel + 2000
                        elseif connected then
                            gpuLevel = gpuLevel + 1000
                        end

                        if gpuLevel == screenLevel then
                            gpuLevel = gpuLevel + 20
                        elseif gpuLevel > screenLevel then
                            gpuLevel = gpuLevel + 10
                        end
                    end
                end

                if gpuLevel > bestGpuLevel then
                    bestGpuLevel = gpuLevel
                    bestGpu = address
                end
            end
        end
    end
    
    if not topOnly then
        check()
    end
    check(true)

    bindCache[screen] = bestGpu
    return bestGpu
end

function graphic.findGpuProxy(screen, topOnly)
    local addr = graphic.findGpuAddress(screen, topOnly)
    if addr then
        return component.proxy(addr)
    end
end

function graphic.initGpu(screen, gpuaddress)
    local gpu = component.proxy(gpuaddress)

    if gpu.getScreen() ~= screen then
        gpu.bind(screen, false)
    end

    if isVGpuInstalled and not graphic.vgpus[screen] then
        if graphic.allowSoftwareBuffer then
            graphic.vgpus[screen] = require("vgpu").create(gpu, screen)
        elseif gpu.getDepth() == 1 then
            graphic.vgpus[screen] = require("vgpu").createStub(gpu)
        end
    end

    if gpu.setActiveBuffer then
        if graphic.allowHardwareBuffer then
            if not graphic.screensBuffers[screen] then
                gpu.setActiveBuffer(0)
                graphic.screensBuffers[screen] = gpu.allocateBuffer(gpu.getResolution())
            end

            if graphic.screensBuffers[screen] then
                gpu.setActiveBuffer(graphic.screensBuffers[screen])
            end
        else
            gpu.setActiveBuffer(0)
            gpu.freeAllBuffers()
        end
    end

    if graphic.vgpus[screen] then
        return graphic.vgpus[screen]
    else
        return gpu
    end
end

function graphic.findGpu(screen, topOnly)
    local gpu = graphic.findGpuAddress(screen, topOnly)
    if gpu then
        return graphic.initGpu(screen, gpu)
    end
end

function graphic.findNativeGpu(screen)
    local gpu = graphic.findGpuProxy(screen)
    if gpu then
        if gpu.getScreen() ~= screen then
            gpu.bind(screen, false)
        end
        pcall(gpu.setActiveBuffer, 0)
        return gpu
    end
end

------------------------------------

local function backBuffer(screen, ...)
    local gpu = graphic.findGpu(screen)
    if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
        gpu.setActiveBuffer(graphic.screensBuffers[screen] or 0)
    end
    return ...
end

function graphic.getResolution(screen)
    local gpu = graphic.findGpu(screen)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end
        return backBuffer(screen, gpu.getResolution())
    end
end

function graphic.maxResolution(screen)
    local gpu = graphic.findGpu(screen, true)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end
        return backBuffer(screen, gpu.maxResolution())
    end
end

function graphic.setResolution(screen, x, y)
    local gpu = graphic.findGpu(screen, true)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            local activeBuffer = gpu.getActiveBuffer()

            local palette
            if gpu.getDepth() > 1 then
                palette = {}
                for i = 0, 15 do
                    table.insert(palette, graphic.getPaletteColor(screen, i) or 0)
                end
            end
            
            local newBuffer = gpu.allocateBuffer(x, y)
            if newBuffer then
                graphic.screensBuffers[screen] = newBuffer

                gpu.bitblt(newBuffer, nil, nil, nil, nil, activeBuffer)
                gpu.freeBuffer(activeBuffer)

                if palette then
                    gpu.setActiveBuffer(0)
                    for i, color in ipairs(palette) do
                        gpu.setPaletteColor(i - 1, color)
                    end
                    
                    gpu.setActiveBuffer(newBuffer)
                    for i, color in ipairs(palette) do
                        gpu.setPaletteColor(i - 1, color)
                    end
                else
                    gpu.setActiveBuffer(newBuffer)
                end
            else
                gpu.setActiveBuffer(0)
                graphic.screensBuffers[screen] = nil
            end
        end

        if graphic.screensBuffers[screen] then
            gpu.setResolution(x, y)
            gpu.setActiveBuffer(0)
            return backBuffer(screen, gpu.setResolution(x, y))
        else
            return gpu.setResolution(x, y)
        end
    end
end

function graphic.isValidResolution(screen, x, y)
    local rx, ry = graphic.maxResolution(screen)
    return not (x > rx or y > rx or (x * y) > (rx * ry))
end

function graphic.setPaletteColor(screen, i, v)
    local gpu = graphic.findGpu(screen)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
            gpu.setPaletteColor(i, v)
            gpu.setActiveBuffer(graphic.screensBuffers[screen] or 0)
        end
        return gpu.setPaletteColor(i, v)
    end
end

function graphic.getPaletteColor(screen, i)
    local gpu = graphic.findGpu(screen)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end
        return backBuffer(screen, gpu.getPaletteColor(i))
    end
end

function graphic.setPalette(screen, palette, fromZero)
    local gpu = graphic.findGpu(screen)
    if gpu then
        local from = fromZero and 0 or 1
        
        local function set()
            for i = from, from + 15 do
                local index = i
                if not fromZero then
                    index = i - 1
                end
                
                if gpu.getPaletteColor(index) ~= palette[i] then
                    gpu.setPaletteColor(index, palette[i])
                end
            end
        end

        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
            set()
            gpu.setActiveBuffer(graphic.screensBuffers[screen] or 0)
        end
        set()
    end
end

function graphic.getPalette(screen, fromZero)
    local gpu = graphic.findGpu(screen)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end

        local palette = {}
        for i = 0, 15 do
            if fromZero then
                palette[i] = gpu.getPaletteColor(i)
            else
                palette[i + 1] = gpu.getPaletteColor(i)
            end
        end
        return backBuffer(screen, palette)
    end
end

function graphic.getDepth(screen)
    local gpu = graphic.findGpu(screen)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end
        return backBuffer(screen, gpu.getDepth())
    end
end

function graphic.setDepth(screen, v)
    local gpu = graphic.findGpu(screen, true)
    if gpu then
        graphic.vgpus[screen] = nil
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
            gpu.setDepth(v)
            gpu.setActiveBuffer(graphic.screensBuffers[screen] or 0)
        end
        return gpu.setDepth(v)
    end
end

function graphic.maxDepth(screen)
    local gpu = graphic.findGpu(screen, true)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end
        return backBuffer(screen, gpu.maxDepth())
    end
end

function graphic.getViewport(screen)
    local gpu = graphic.findGpu(screen)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end
        return backBuffer(screen, gpu.getViewport())
    end
end

function graphic.setViewport(screen, x, y)
    local gpu = graphic.findGpu(screen, true)
    if gpu then
        if gpu.setActiveBuffer and graphic.allowHardwareBuffer then
            gpu.setActiveBuffer(0)
        end
        return backBuffer(screen, gpu.setViewport(x, y))
    end
end

------------------------------------

function graphic.isAvailable(screen)
    if not component.isConnected(screen) then return false end
    return not not graphic.findGpuAddress(screen)
end

function graphic.forceUpdate(screen)
    if graphic.allowSoftwareBuffer or graphic.allowHardwareBuffer then
        if screen then
            graphic.updateFlag(screen)
            graphic.update(screen)
        else
            for lscreen, ctype in component.list("screen") do
                graphic.updateFlag(lscreen)
                graphic.update(lscreen)
            end
        end
    end
end

function graphic.update(screen)
    if graphic.updated[screen] then
        local gpuaddress = graphic.findGpuAddress(screen)
        if gpuaddress then
            if graphic.allowSoftwareBuffer then
                local gpu = graphic.initGpu(screen, gpuaddress)
                if gpu.update then --if this is vgpu
                    gpu.update()
                end
            elseif graphic.allowHardwareBuffer then
                local gpu = graphic.initGpu(screen, gpuaddress)
                if gpu.bitblt then
                    gpu.bitblt()
                end
            end
            graphic.updated[screen] = nil
        end
    end
end

function graphic.updateFlag(screen)
    graphic.updated[screen] = true
end

event.hyperListen(function(eventType, _, ctype)
    if (eventType == "component_added" or eventType == "component_removed") and (ctype == "screen" or ctype == "gpu") then
        graphic.bindCache = {}
        graphic.topBindCache = {}
        graphic.vgpus = {}
    end
end)

------------------------------------

function graphic.getDeviceTier(address)
    local capacity = lastinfo.deviceinfo[address].capacity
    if capacity == "8000" then
        return 3
    elseif capacity == "2000" then
        return 2
    elseif capacity == "800" then
        return 1
    else
        return -1
    end
end

function graphic.saveGpuSettings(gpu)
    if type(gpu) == "string" then
        gpu = component.proxy(gpu)
    end

    local screen = gpu.getScreen()
    if not screen then
        return function () end
    end

    local palette = graphic.getPalette(screen)
    local depth = gpu.getDepth()
    local rx, ry = gpu.getResolution()
    local buffer = gpu.getActiveBuffer and gpu.getActiveBuffer()

    return function ()
        graphic.setPalette(screen, palette)
        gpu.setDepth(depth)
        gpu.setResolution(rx, ry)
        if buffer then
            gpu.setActiveBuffer(buffer)
        end
    end
end

function graphic.screenshot(screen, x, y, sx, sy)
    local gpu = graphic.findGpu(screen)
    x = x or 1
    y = y or 1
    local rx, ry = gpu.getResolution()
    sx = sx or rx
    sy = sy or ry

    local index = 1
    local chars = {}
    local fores = {}
    local backs = {}
    for cy = y, y + (sy - 1) do
        for cx = x, x + (sx - 1) do
            local ok, char, fore, back = pcall(gpu.get, cx, cy)
            if ok then
                chars[index] = char
                fores[index] = fore
                backs[index] = back
            end
            index = index + 1
        end
    end

    return function()
        local gpu = graphic.findGpu(screen)

        local oldFore, oldBack, oldX, oldY = fores[1], backs[1], x, y
        local buff = ""

        local cx, cy = x, y
        for i = 1, index do
            local fore, back, char = fores[i], backs[i], chars[i]

            if char then
                if fore ~= oldFore or back ~= oldBack or oldY ~= cy then
                    gpu.setForeground(oldFore)
                    gpu.setBackground(oldBack)
                    gpu.set(oldX, oldY, buff)

                    oldFore = fore
                    oldBack = back
                    oldX = cx
                    oldY = cy
                    buff = char
                else
                    buff = buff .. char
                end
            end

            cx = cx + 1
            if cx >= x + sx then
                cx = x
                cy = cy + 1
            end
        end

        if oldFore then
            gpu.setForeground(oldFore)
            gpu.setBackground(oldBack)
            gpu.set(oldX, oldY, buff)
        end

        graphic.updated[screen] = true
    end
end

return graphicsystem/core/lib/hook.lua 2051 local component = require("component", true)
local hook = {}

----------------------------

local globalComponentHooks = {}
local localComponentHooks = {}
local invoke = component.invoke

function component.invoke(address, method, ...)
    checkArg(1, address, "string")
    checkArg(2, method, "string")

    local args = {...}
    local resultHooks = {}
    local resultHook
    for i, hook in ipairs(globalComponentHooks) do
        address, method, args, resultHook = hook(address, method, args) --можно вернуть два nil и потом фейковый результат в таблице
        if resultHook then
            table.insert(resultHooks, resultHook)
        end
    end
    if localComponentHooks[address] then
        for i, hook in ipairs(localComponentHooks[address]) do
            address, method, args, resultHook = hook(address, method, args)
            if resultHook then
                table.insert(resultHooks, resultHook)
            end
        end
    end

    if address then
        local result = {pcall(invoke, address, method, table.unpack(args))} --для правильного разположения ошибки
        for i, v in ipairs(resultHooks) do
            result = v(result)
        end
        if result[1] then
            return table.unpack(result, 2)
        else
            error(result[2], 2)
        end
    elseif args then
        return table.unpack(args)
    end
end

----------------------------

function hook.addGlobalComponentHook(func)
    table.insert(globalComponentHooks, func)
end

function hook.delGlobalComponentHook(func)
    table.clear(globalComponentHooks, func)
end

function hook.addComponentHook(address, func)
    if not localComponentHooks[address] then localComponentHooks[address] = {} end
    table.insert(localComponentHooks[address], func)
end

function hook.delComponentHook(address, func)
    if not localComponentHooks[address] then localComponentHooks[address] = {} end
    table.clear(localComponentHooks[address], func)
end

return hooksystem/core/lib/internet.lua 4867 local component = require("component")
local fs = require("filesystem")
local paths = require("paths")
local event = require("event")
local computer = require("computer")
local internet = {settings = {}}
internet.settings.timeout = 3
internet.settings.downloadPart = 1024 * 32
internet.settings.pingHost = "http://google.com"

local unknown = "unknown error"

local cardIterator
function internet.card() --поралелит нагрузку на несколько инетных карт, чтобы можно было открыть больше сокетов итд
    if cardIterator then
        local result = cardIterator()
        if result then
            return result
        end
    end

    cardIterator = component.list("internet", true)
    if cardIterator then
        return (cardIterator())
    end
end

function internet.cardProxy()
    return component.proxy(internet.card() or "")
end

function internet.check()
    local proxy = internet.cardProxy()
    if proxy then
        local handle = proxy.request(internet.settings.pingHost)
        if handle then
            local data = handle.read()
            pcall(handle.close)
            if data then
                return true
            end
        end
    end
    return false
end

function internet.wait(handle, waittime)
    local startTime = computer.uptime()
    while true do
        local successfully, err = handle.finishConnect()
        if successfully then
            return true
        elseif successfully == nil then
            return nil, tostring(err or unknown)
        end

        if computer.uptime() - startTime > (waittime or internet.settings.timeout) then
            return nil, "timeout error"
        end

        event.yield()
    end
end

function internet.readAll(handle)
    local data = {}
    while true do
        local result, reason = handle.read(math.huge) 
        if result then
            table.insert(data, result)
        else
            handle.close()
            
            if reason then
                return nil, reason
            else
                return table.concat(data)
            end
        end
    end
end

function internet.get(url)
    local inet = internet.cardProxy()
    if not inet then
        return nil, "no internet-card"
    end

    local handle, err = inet.request(url)
    if handle then
        local successfully, err = internet.wait(handle)
        if not successfully then
            return nil, err
        end

        return internet.readAll(handle)
    else
        return nil, tostring(err or unknown)
    end
end

function internet.download(url, path)
    local inet = internet.cardProxy()
    if not inet then
        return nil, "no internet-card"
    end

    local handle, err = inet.request(url)
    if handle then
        local successfully, err = internet.wait(handle)
        if not successfully then
            return nil, err
        end

        fs.makeDirectory(paths.path(path))
        local file, err = fs.open(path, "wb")
        if not file then
            return nil, err
        end
        
        local data = {}
        local dataSize = 0
        while true do
            local result, reason = handle.read(math.huge) 
            if result then
                table.insert(data, result)
                dataSize = dataSize + #result

                if dataSize >= internet.settings.downloadPart then
                    file.write(table.concat(data))
                    data = {}
                    dataSize = 0
                end
            else
                if #data > 0 then
                    file.write(table.concat(data))
                end
                file.close()
                handle.close()
                
                if reason then
                    return nil, reason
                else
                    return true
                end
            end
        end
    else
        return nil, tostring(err or unknown)
    end
end

local function removeTrues(results)
    for i, tbl in ipairs(results) do
        if tbl[1] == true then
            table.remove(tbl, 1)
        end
    end
    return results
end

function internet.downloads(downloads)
    local thread = require("thread")
    local threads = {}
    for _, download in ipairs(downloads) do
        local th = thread.create(internet.download, table.unpack(download))
        table.insert(threads, th)
        th:resume()
    end
    return removeTrues(thread.waitForAll(threads))
end

function internet.gets(gets)
    local thread = require("thread")
    local threads = {}
    for _, url in ipairs(gets) do
        local th = thread.create(internet.get, url)
        table.insert(threads, th)
        th:resume()
    end
    return removeTrues(thread.waitForAll(threads))
end

internet.getInternetFile = internet.get
internet.unloadable = true
return internetsystem/core/lib/lastinfo.lua 1243 local event = require("event")
local computer = require("computer")
local component = require("component")
local bootloader = require("bootloader")
local lastinfo = {keyboards = {}}

event.hyperListen(function (eventType, componentUuid, componentType)
    if bootloader.runlevel ~= "init" then
        if eventType == "component_added" then
            lastinfo.deviceinfo = nil

            if componentType == "keyboard" then
                table.clear(lastinfo.keyboards)
            elseif componentType == "screen" then
                lastinfo.keyboards[componentUuid] = nil
            end
        elseif eventType == "component_removed" then
            lastinfo.deviceinfo[componentUuid] = nil
            lastinfo.keyboards[componentUuid] = nil
        end
    end
end)

setmetatable(lastinfo, {__index = function(self, key)
    if key == "deviceinfo" then
        self.deviceinfo = computer.getDeviceInfo()
        return self.deviceinfo
    end
end})
setmetatable(lastinfo.keyboards, {__index = function(self, address)
    local result = {pcall(component.invoke, address, "getKeyboards")}
    if result[1] and type(result[2]) == "table" then
        self[address] = result[2]
        return result[2]
    end
end})
return lastinfosystem/core/lib/logs.lua 1492 local fs = require("filesystem")
local paths = require("paths")
local logs = {}
logs.defaultLogPath = "/data/errorlog.log"
logs.timeZone = 0

function logs.timetag()
    local result = "unknown-time"
    pcall(function ()
        local time = require("time")
        result = time.formatTime(time.addTimeZone(time.getRealTime(), logs.timeZone), true, true)
    end)
    return result
end

function logs.log(logdata, tag, path)
    path = path or logs.defaultLogPath
    fs.makeDirectory(paths.path(path))

    local file = assert(fs.open(path, "ab"))
    assert(file.write(logs.timetag() .. (tag and (" \"" .. tag .. "\"") or "") .. ": " .. tostring(logdata or "unknown error") .. "\n"))
    file.close()
end

function logs.logs(logsdata, tag, path)
    path = path or logs.defaultLogPath
    fs.makeDirectory(paths.path(path))

    local timetag = logs.timetag()
    local file = assert(fs.open(path, "ab", true))
    for i, logdata in ipairs(logsdata) do
        assert(file.write(timetag .. (tag and (" \"" .. tag .. "\"") or "") .. ": " .. tostring(logdata or "unknown error") .. "\n"))
    end
    file.close()
end

function logs.assert(ok, err)
    if not ok then
        logs.log(err)
    end
end

function logs.check(...)
    local ok, err = ...
    if not ok then
        logs.log(err)
    end
    return ...
end

function logs.checkWithTag(tag, ...)
    local ok, err = ...
    if not ok then
        logs.log(err, tag)
    end
    return ...
end

logs.unloadable = true
return logssystem/core/lib/natives.lua 1309 local natives = {}
--позваляет получить доступ к оригинальным методам библиотек computer и component
--например если нужно исключить влияния vcomponent

local function deepclone(tbl, newtbl)
    local cache = {}
    local function recurse(tbl, newtbl)
        local newtbl = newtbl or {}

        for k, v in pairs(tbl) do
            if type(v) == "table" then
                local ltbl = cache[v]
                if not ltbl then
                    cache[v] = {}
                    ltbl = cache[v]
                    recurse(v, cache[v])
                end
                newtbl[k] = ltbl
            else
                newtbl[k] = v
            end
        end

        return newtbl
    end

    return recurse(tbl, newtbl)
end

-- clone
natives.component = deepclone(component)
natives.computer = deepclone(computer)
natives.table = deepclone(table) --table и math в likeOS содержут дополнительные методы, данные же таблицы не содержут этих методов
natives.math = deepclone(math)
natives.pcall = pcall
natives.xpcall = xpcall
natives.pairs = pairs
natives.ipairs = ipairs

-- we remove the excess
natives.computer.runlevel = nil

return nativessystem/core/lib/note.lua 3434 --Provides all music notes in range of computer.beep in MIDI and frequency form
--Author: Vexatos
local computer = require("computer")

local note = {}
--The table that maps note names to their respective MIDI codes
local notes = {}
--The reversed table "notes"
local reverseNotes = {}

do
  --All the base notes
  local tempNotes = {
    "c",
    "c#",
    "d",
    "d#",
    "e",
    "f",
    "f#",
    "g",
    "g#",
    "a",
    "a#",
    "b"
    }
  --The table containing all the standard notes and # semitones in correct order, temporarily
  local sNotes = {}
  --The table containing all the b semitones
  local bNotes = {}

  --Registers all possible notes in order
  do
    table.insert(sNotes,"a0")
    table.insert(sNotes,"a#0")
    table.insert(bNotes,"bb0")
    table.insert(sNotes,"b0")
    for i = 1,6 do
      for _,v in ipairs(tempNotes) do
        table.insert(sNotes,v..tostring(i))
        if #v == 1 and v ~= "c" and v ~= "f" then
          table.insert(bNotes,v.."b"..tostring(i))
        end
      end
    end
  end
  for i=21,95 do
    notes[sNotes[i-20]]=tostring(i)
  end

  --Reversing the whole table in reverseNotes, used for note.get
  do
    for k,v in pairs(notes) do
      reverseNotes[tonumber(v)]=k
    end
  end

  --This is registered after reverseNotes to avoid conflicts
  for k,v in ipairs(bNotes) do
    notes[v]=tostring(notes[string.gsub(v,"(.)b(.)","%1%2")]-1)
  end
end

--Converts string or frequency into MIDI code
function note.midi(n)
  if type(n) == "string" then
    n = string.lower(n)
    if tonumber(notes[n])~=nil then
      return tonumber(notes[n])
    else
      error("Wrong input "..tostring(n).." given to note.midi, needs to be <note>[semitone sign]<octave>, e.g. A#0 or Gb4")
    end
  elseif type(n) == "number" then
    return math.floor((12*math.log(n/440,2))+69)
  else
    error("Wrong input "..tostring(n).." given to note.midi, needs to be a number or a string")
  end
end

--Converts String or MIDI code into frequency
function note.freq(n)
  if type(n) == "string" then
    n = string.lower(n)
    if tonumber(notes[n])~=nil then
      return math.pow(2,(tonumber(notes[n])-69)/12)*440
    else
      error("Wrong input "..tostring(n).." given to note.freq, needs to be <note>[semitone sign]<octave>, e.g. A#0 or Gb4",2)
    end
  elseif type(n) == "number" then
    return math.pow(2,(n-69)/12)*440
  else
    error("Wrong input "..tostring(n).." given to note.freq, needs to be a number or a string",2)
  end
end

--Converts a MIDI value back into a string
function note.name(n)
  n = tonumber(n)
  if reverseNotes[n] then
    return string.upper(string.match(reverseNotes[n],"^(.)"))..string.gsub(reverseNotes[n],"^.(.*)","%1")
  else
    error("Attempt to get a note for a non-exsisting MIDI code",2)
  end
end

--Converts Note block ticks (0-24) to MIDI code (34-58) and vice-versa
function note.ticks(n)
  if type(n) == "number" then
    if n>=0 and n<=24 then
      return n+34
    elseif n>=34 and n<=58 then
      return n-34
    else
      error("Wrong input "..tostring(n).." given to note.ticks, needs to be a number [0-24 or 34-58]",2)
    end
  else
    error("Wrong input "..tostring(n).." given to note.ticks, needs to be a number",2)
  end
end

--Plays a tone, input is either the note as a string or the MIDI code as well as the duration of the tone
function note.play(tone,duration)
  computer.beep(note.freq(tone),duration)
end

return note
system/core/lib/package.lua 6473 local bootloader = ...
local component = component
local computer = computer
local unicode = unicode

------------------------------------

local libenv = bootloader.createEnv()
local loadingNow = {}
local package = {
    paths = {"/data/lib", "/vendor/lib", "/system/lib", "/system/core/lib"}, --позиция по мере снижения приоритета(первый элемент это самый высокий приоритет)
    allowEnclosedLoadingCycle = false,
    hardAutoUnloading = false,
    hooks = {}
}

------------------------------------ adding static libraries to the list

package.loaded = {
    ["package"] = package,
    ["bootloader"] = bootloader
}

for key, value in pairs(_G) do
    if type(value) == "table" then
        package.loaded[key] = value
    end
end

------------------------------------ caches

package.cache = {}
package.libStubsCache = {}

------------------------------------

local function raw_require(name)
    if not package.loaded[name] and not package.cache[name] then
        local finded = package.find(name)
        if not finded then
            error("lib " .. name .. " is not found", 3)
        end

        loadingNow[name] = true
        local lib = assert(loadfile(finded, nil, libenv))()
        loadingNow[name] = nil

        if type(lib) ~= "table" or lib.unloadable then
            package.cache[name] = lib
        else
            package.loaded[name] = lib
        end
    end

    if not package.loaded[name] and not package.cache[name] then
        error("lib " .. name .. " is not found" , 3)
    end

    return package.loaded[name] or package.cache[name]
end

local function hooked_require(name)
    local lib = raw_require(name)
    for _, hook in ipairs(package.hooks) do
        lib = hook(name, lib)
    end
    return lib
end

------------------------------------

function package.find(name)
    local fs = require("filesystem")
    local paths = require("paths")

    local function resolve(path, deep)
        if fs.exists(path) then
            if fs.isDirectory(path) then
                local lpath = paths.concat(path, "init.lua")
                if fs.exists(lpath) and not fs.isDirectory(lpath) then
                    return lpath
                end
            else
                return path
            end
        end

        if not deep then
            return resolve(path .. ".lua", true)
        end
    end
    
    if unicode.sub(name, 1, 1) == "/" then
        return resolve(name)
    else
        for i, v in ipairs(package.paths) do
            local path = resolve(paths.concat(v, name))
            if path then
                return path
            end
        end
    end
end

function package.require(name, force)
    if force then
        return hooked_require(name)
    end

    local lib = package.loaded[name] or package.cache[name]
    if lib then
        return lib
    elseif package.hardAutoUnloading or loadingNow[name] then
        if package.hardAutoUnloading or package.allowEnclosedLoadingCycle then
            if package.libStubsCache[name] then
                return package.libStubsCache[name]
            else
                package.libStubsCache[name] = setmetatable({}, {__index = function (_, key)
                    return (hooked_require(name))[key]
                end, __newindex = function (_, key, value)
                    (hooked_require(name))[key] = value
                end})
                return package.libStubsCache[name]
            end
        else
            error("enclosed loading cycle is disabled", 2)
        end
    else
        return hooked_require(name)
    end
end

function package.get(name)
    return package.loaded[name] or package.cache[name]
end

function package.isLoaded(name)
    return not not package.get(name)
end

function package.isLoadingNow(name)
    return not not loadingNow[name]
end

function package.isInstalled(name)
    return not not package.find(name)
end

function package.applyHook(hook)
    table.insert(package.hooks, hook)
end

function package.cancelHook(hook)
    table.clear(package.hooks, hook)
end

function package.register(name, path)
    if bootloader.bootfs.exists(path) and not package.loaded[name] and not package.cache[name] then
        local lib = bootloader.dofile(path, nil, bootloader.createEnv())
        if type(lib) ~= "table" or lib.unloadable then
            package.cache[name] = lib
        else
            package.loaded[name] = lib
        end
        return lib
    end
end

function package.invoke(libname, method, ...)
    local lib = require(libname)
    local obj = lib[method]
    if type(obj) == "function" then
        return obj(...)
    else
        return obj
    end
end

function package.delay(lib, action)
    local mt = {}
    function mt.__index(tbl, key)
        mt.__index = nil
        if type(action) == "function" then
            action()
        else
            dofile(action)
        end
        return tbl[key]
    end
    if lib.internal then
       setmetatable(lib.internal, mt)
    end
    setmetatable(lib, mt)
end

function package.unload(name, force)
    if force then
        if package.loaded[name] then
            table.clear(package.loaded[name])
            package.loaded[name] = nil
        end

        if _G[name] then
            table.clear(_G[name])
            _G[name] = nil
        end
    end
    
    if package.cache[name] then
        table.clear(package.cache[name])
        package.cache[name] = nil
    end
end

local attachMeta = {__index = function(lib, key)
    if lib.functionCache[key] then
        return lib.functionCache[key]
    end

    local fs = require("filesystem")
    local paths = require("paths")

    local path = paths.concat(lib.functionFolder, key .. ".lua")
    if fs.exists(path) then
        local func = assert(loadfile(path, nil, libenv))
        lib.functionCache[key] = func
        return func
    end
end}
function package.attachFunctionFolder(lib, path) --позваляет сохранить малоиспользуемые функции библиотеки на HDD отдельным файлом чтобы загружать ее по необходимости и экономить память
    lib.functionFolder = require("system").getResourcePath(path)
    lib.functionCache = {}
    require("cache").attachUnloader(lib.functionCache)
    setmetatable(lib, attachMeta)
end

------------------------------------

return packagesystem/core/lib/parser.lua 2734 local unicode = require("unicode")
local text = require("text")
local parser = {}

function parser.split(tool, str, seps) --дробит строку по разделителям(сохраняяя пустые строки)
    local parts = {""}

    if type(seps) ~= "table" then
        seps = {seps}
    end

    local index = 1
    local strlen = tool.len(str)
    while index <= strlen do
        while true do
            local isBreak
            for i, sep in ipairs(seps) do
                if tool.sub(str, index, index + (tool.len(sep) - 1)) == sep then
                    table.insert(parts, "")
                    index = index + tool.len(sep)
                    isBreak = true
                    break
                end
            end
            if not isBreak then break end
        end

        parts[#parts] = parts[#parts] .. tool.sub(str, index, index)
        index = index + 1
    end

    return parts
end

function parser.change(tool, str, list)
    for from, to in pairs(list) do
        str = table.concat(parser.split(tool, str, from), to)
    end
    return str
end

function parser.fastChange(str, list)
    for from, to in pairs(list) do
        str = str:gsub(text.escapePattern(from), text.escapePattern(to))
    end
    return str
end

function parser.toParts(tool, str, max) --дробит строку на куски с максимальным размером
    local strs = {}
    while tool.len(str) > 0 do
        table.insert(strs, tool.sub(str, 1, max))
        str = tool.sub(str, tool.len(strs[#strs]) + 1)
    end
    return strs
end

function parser.toLines(str, max)
    return parser.toParts(unicode, str, max)
end

function parser.toLinesLn(str, max)
    local raw_lines = parser.split(unicode, str, "\n")
    local lines = {}
    for _, raw_line in ipairs(raw_lines) do
        if raw_line == "" then
            table.insert(lines, "")
        else
            local tmpLines = parser.toParts(unicode, raw_line, max or 50)
            for _, line in ipairs(tmpLines) do
                table.insert(lines, line)
            end
        end
    end
    return lines
end

function parser.parseTraceback(traceback, maxlen, maxlines, spaces)
    maxlen = maxlen or 50
    maxlines = maxlines or 15
    spaces = spaces or 2

    local tab = string.char(9)
    local space = string.rep(" ", spaces)

    local lines = {}
    for i, str in ipairs(parser.toLinesLn(traceback, maxlen)) do
        table.insert(lines, (str:gsub(tab, space)))
        if #lines >= maxlines then
            break
        end
    end
    
    return lines
end

function parser.formatTraceback(...)
    return table.concat(parser.parseTraceback(...), "\n")
end

parser.unloadable = true
return parsersystem/core/lib/paths.lua 4147 local unicode = require("unicode")
local paths = {}
paths.baseDirectory = "/data"
paths.unloadable = true

function paths.segments(path)
    local parts = {}
    for part in path:gmatch("[^\\/]+") do
        local current, up = part:find("^%.?%.$")
        if current then
            if up == 2 then
                table.remove(parts)
            end
        else
            table.insert(parts, part)
        end
    end
    return parts
end

------------------------------------

function paths.xconcat(...) --работает как concat но пути начинаюшиеся со / НЕ обрабатываються как отновительные а откидывают путь в начало
    local set = table.pack(...)
    for index, value in ipairs(set) do
        checkArg(index, value, "string")
    end
    for index, value in ipairs(set) do
        if unicode.sub(value, 1, 1) == "/" and index > 1 then
            local newset = {}
            for i = index, #set do
                table.insert(newset, set[i])
            end
            return paths.xconcat(table.unpack(newset))
        end
    end
    return paths.canonical(table.concat(set, "/"))
end

function paths.sconcat(main, ...) --работает так же как concat но если итоговый путь не указывает на целевой обьект первого путя то вернет false
    main = paths.canonical(main) .. "/"
    local path = paths.concat(main, ...) .. "/"
    if unicode.sub(path, 1, unicode.len(main)) == main then
        return paths.canonical(path)
    end
    return false
end

function paths.concat(...) --класический concat как в openOS
    local set = table.pack(...)
    for index, value in ipairs(set) do
        checkArg(index, value, "string")
    end
    return paths.canonical(table.concat(set, "/"))
end

------------------------------------

function paths.absolute(path) --работает как canonical но обрабатывает baseDirectory
    local result = table.concat(paths.segments(path), "/")
    if unicode.sub(path, 1, 1) == "/" then
        return "/" .. result
    else
        if paths.baseDirectory then
            return paths.concat(paths.baseDirectory, path)
        else
            return result
        end
    end
end

function paths.canonical(path)
    local result = table.concat(paths.segments(path), "/")
    if unicode.sub(path, 1, 1) == "/" then
        return "/" .. result
    end
    return result
end

function paths.equals(...)
    local pathsList = {...}
    for key, path in pairs(pathsList) do
        pathsList[key] = paths.canonical(path)
    end
    local mainPath = pathsList[1]
    for i = 2, #pathsList do
        if mainPath ~= pathsList[i] then
            return false
        end
    end
    return true
end

function paths.path(path)
    path = paths.canonical(path)
    local parts = paths.segments(path)
    local result = table.concat(parts, "/", 1, #parts - 1) .. "/"
    if unicode.sub(path, 1, 1) == "/" and unicode.sub(result, 1, 1) ~= "/" then
        return paths.canonical("/" .. result)
    else
        return paths.canonical(result)
    end
end
  
function paths.name(path)
    checkArg(1, path, "string")
    local parts = paths.segments(path)
    return parts[#parts]
end

function paths.extension(path)
    local name = paths.name(path)
    if not name then
        return
    end

	local exp
    for i = 1, unicode.len(name) do
        local char = unicode.sub(name, i, i)
        if char == "." then
            if i ~= 1 then
                exp = {}
            end
        elseif exp then
            table.insert(exp, char)
        end
    end

    if exp and #exp > 0 then
        return table.concat(exp)
    end
end

function paths.changeExtension(path, exp)
    return paths.hideExtension(path) .. (exp and ("." .. exp) or "")
end

function paths.hideExtension(path)
    path = paths.canonical(path)

    local exp = paths.extension(path)
    if exp then
        return unicode.sub(path, 1, unicode.len(path) - (unicode.len(exp) + 1))
    else
        return path
    end
end

return pathssystem/core/lib/programs.lua 2336 local fs = require("filesystem")
local unicode = require("unicode")
local paths = require("paths")
local package = require("package")
local bootloader = require("bootloader")
local event = require("event")

------------------------------------

local programs = {}
programs.paths = {"/data/bin", "/vendor/bin", "/system/bin", "/system/core/bin"} --позиция по мере снижения приоритета(первый элемент это самый высокий приоритет)
programs.mainFile = "main.lua"
programs.extension = ".app"

function programs.find(name)
    if unicode.sub(name, 1, 1) == "/" then
        if fs.exists(name) then
            if fs.isDirectory(name) then
                local executeFile = paths.concat(name, programs.mainFile)
                if fs.exists(executeFile) and not fs.isDirectory(executeFile) then
                    return executeFile
                end
            else
                return name
            end
        end
    else
        for i, v in ipairs(programs.paths) do
            local path = paths.concat(v, name)
            if fs.exists(path .. ".lua") and not fs.isDirectory(path .. ".lua") then
                return path .. ".lua"
            else
                if fs.exists(path .. programs.extension) and fs.isDirectory(path .. programs.extension) then
                    path = paths.concat(path .. programs.extension, programs.mainFile)
                    if fs.exists(path) and not fs.isDirectory(path) then
                        return path
                    end
                end
            end
        end
    end
end

function programs.load(name, mode, env)
    local path = programs.find(name)
    if not path then return nil, "no such program" end
    return loadfile(path, mode, env or bootloader.createEnv())
end

function programs.execute(name, ...)
    local code, err = programs.load(name)
    if not code then return nil, err end
    
    local thread = package.get("thread")
    if not thread then
        return pcall(code, ...)
    else
        local t = thread.create(code, ...)
        t:resume() --потому что по умолчанию поток спит
        while t:status() ~= "dead" do event.yield() end
        return table.unpack(t.out or {true})
    end
end

programs.unloadable = true
return programssystem/core/lib/registry.lua 2265 local fs = require("filesystem")
local serialization = require("serialization")

--------------------------------

local function new(path, data)
    checkArg(1, path, "string")
    checkArg(2, data, "table", "nil")

    local lreg = {path = path, data = data or {}}
    if fs.exists(lreg.path) then
        local tbl = serialization.load(lreg.path)
        if tbl then
            lreg.data = tbl
        end
    end

    function lreg.save()
        return serialization.save(lreg.path, lreg.data)
    end

    function lreg.apply(tbl)
        if type(tbl) == "string" then
            local ntbl, err = serialization.load(tbl)
            if not ntbl then
                return nil, err
            end
            tbl = ntbl
        end
        local bl = {
            ["reg_rm_list"] = true,
            ["reg_rm_all"] = true
        }
        local function recurse(ltbl, native)
            for _, reg_rm in ipairs(ltbl.reg_rm_list or {}) do
                native[reg_rm] = nil
            end
            if ltbl.reg_rm_all then
                for key in pairs(native) do
                    native[key] = nil
                end
            end
            for key, value in pairs(ltbl) do
                if not bl[key] then
                    if type(value) == "table" then
                        if type(native[key]) ~= "table" then
                            native[key] = {}
                        end
                        recurse(value, native[key])
                    else
                        native[key] = value
                    end
                end
            end
        end
        recurse(tbl, lreg.data)
        return true
    end

    function lreg.hotReload()
        local tbl = serialization.load(lreg.path)
        if tbl then
            lreg.data = tbl
        else
            lreg.data = {}
        end
    end
    
    setmetatable(lreg, {__newindex = function(_, key, value)
        if lreg.data[key] ~= value then
            lreg.data[key] = value
            lreg.save()
        end
    end, __index = function(_, key)
        return lreg.data[key]
    end})

    return lreg
end

local registry = new("/data/registry.dat")
rawset(registry, "new", new)
rawset(registry, "unloadable", true)
return registrysystem/core/lib/serialization.lua 5939 local fs = require("filesystem")
local serialization = {}

-- Important: pretty formatting will allow presenting non-serializable values
-- but may generate output that cannot be unserialized back.
function serialization.serialize(value, pretty)
    local kw = {
        ["and"] = true,
        ["break"] = true,
        ["do"] = true,
        ["else"] = true,
        ["elseif"] = true,
        ["end"] = true,
        ["false"] = true,
        ["for"] = true,
        ["function"] = true,
        ["goto"] = true,
        ["if"] = true,
        ["in"] = true,
        ["local"] = true,
        ["nil"] = true,
        ["not"] = true,
        ["or"] = true,
        ["repeat"] = true,
        ["return"] = true,
        ["then"] = true,
        ["true"] = true,
        ["until"] = true,
        ["while"] = true
    }
    local id = "^[%a_][%w_]*$"
    local ts = {}
    local result_pack = {}
    local function recurse(current_value, depth)
        local t = type(current_value)
        if t == "number" then
            if current_value ~= current_value then
                table.insert(result_pack, "0/0")
            elseif current_value == math.huge then
                table.insert(result_pack, "math.huge")
            elseif current_value == -math.huge then
                table.insert(result_pack, "-math.huge")
            else
                table.insert(result_pack, tostring(current_value))
            end
        elseif t == "string" then
            table.insert(result_pack, (string.format("%q", current_value):gsub("\\\n", "\\n")))
        elseif
            t == "nil" or t == "boolean" or pretty and (t ~= "table" or (getmetatable(current_value) or {}).__tostring)
         then
            table.insert(result_pack, tostring(current_value))
        elseif t == "table" then
            if ts[current_value] then
                if pretty then
                    table.insert(result_pack, "recursion")
                    return
                else
                    error("tables with cycles are not supported")
                end
            end
            ts[current_value] = true
            local f
            if pretty then
                local ks, sks, oks = {}, {}, {}
                for k in pairs(current_value) do
                    if type(k) == "number" then
                        table.insert(ks, k)
                    elseif type(k) == "string" then
                        table.insert(sks, k)
                    else
                        table.insert(oks, k)
                    end
                end
                table.sort(ks)
                table.sort(sks)
                for _, k in ipairs(sks) do
                    table.insert(ks, k)
                end
                for _, k in ipairs(oks) do
                    table.insert(ks, k)
                end
                local n = 0
                f =
                    table.pack(
                    function()
                        n = n + 1
                        local k = ks[n]
                        if k ~= nil then
                            return k, current_value[k]
                        else
                            return nil
                        end
                    end
                )
            else
                f = table.pack(pairs(current_value))
            end
            local i = 1
            local first = true
            table.insert(result_pack, "{")
            for k, v in table.unpack(f) do
                if not first then
                    table.insert(result_pack, ",")
                    if pretty then
                        table.insert(result_pack, "\n" .. string.rep(" ", depth))
                    end
                end
                first = nil
                local tk = type(k)
                if tk == "number" and k == i then
                    i = i + 1
                    recurse(v, depth + 1)
                else
                    if tk == "string" and not kw[k] and string.match(k, id) then
                        table.insert(result_pack, k)
                    else
                        table.insert(result_pack, "[")
                        recurse(k, depth + 1)
                        table.insert(result_pack, "]")
                    end
                    table.insert(result_pack, "=")
                    recurse(v, depth + 1)
                end
            end
            ts[current_value] = nil -- allow writing same table more than once
            table.insert(result_pack, "}")
        else
            error("unsupported type: " .. t)
        end
    end
    recurse(value, 1)
    local result = table.concat(result_pack)
    if pretty then
        local limit = type(pretty) == "number" and pretty or 10
        local truncate = 0
        while limit > 0 and truncate do
            truncate = string.find(result, "\n", truncate + 1, true)
            limit = limit - 1
        end
        if truncate then
            return result:sub(1, truncate) .. "..."
        end
    end
    return result
end

function serialization.unserialize(data)
    checkArg(1, data, "string")

    local result, reason = load("return " .. data, "=unserialize", nil, {math = {huge = math.huge}})
    if not result then
        return nil, reason
    end
    
    local ok, output = pcall(result)
    if not ok then
        return nil, output
    end
    
    if type(output) == "table" then
        return output
    end
    return nil, "type error, input data is not a table"
end

function serialization.load(path)
    checkArg(1, path, "string")
    
    local content, err = fs.readFile(path)
    if not content then return nil, err end

    return serialization.unserialize(content)
end

function serialization.save(path, data)
    checkArg(1, path, "string")
    checkArg(2, data, "table")
    return fs.writeFile(path, serialization.serialize(data))
end

serialization.unloadable = true
return serializationsystem/core/lib/sha256.lua 8358 local component = require("component")
local sha256 = {}
sha256.datacardSupport = true
--многие говорят что data карта медленее чем software решения, но в моих текстах она окозалась гораздо быстрее
--толь я криворукий, толь чего-то не понимаю, по этому и добавил варянт вырубить

-------------------------------------------------

local preproc, initH256, digestblock, str2hexa, num2s
local function a(b,c,d,...)b=b%2^32;c=c%2^32;local e=(b%0x00000002>=0x00000001 and c%0x00000002>=0x00000001 and 0x00000001 or 0)+(b%0x00000004>=0x00000002 and c%0x00000004>=0x00000002 and 0x00000002 or 0)+(b%0x00000008>=0x00000004 and c%0x00000008>=0x00000004 and 0x00000004 or 0)+(b%0x00000010>=0x00000008 and c%0x00000010>=0x00000008 and 0x00000008 or 0)+(b%0x00000020>=0x00000010 and c%0x00000020>=0x00000010 and 0x00000010 or 0)+(b%0x00000040>=0x00000020 and c%0x00000040>=0x00000020 and 0x00000020 or 0)+(b%0x00000080>=0x00000040 and c%0x00000080>=0x00000040 and 0x00000040 or 0)+(b%0x00000100>=0x00000080 and c%0x00000100>=0x00000080 and 0x00000080 or 0)+(b%0x00000200>=0x00000100 and c%0x00000200>=0x00000100 and 0x00000100 or 0)+(b%0x00000400>=0x00000200 and c%0x00000400>=0x00000200 and 0x00000200 or 0)+(b%0x00000800>=0x00000400 and c%0x00000800>=0x00000400 and 0x00000400 or 0)+(b%0x00001000>=0x00000800 and c%0x00001000>=0x00000800 and 0x00000800 or 0)+(b%0x00002000>=0x00001000 and c%0x00002000>=0x00001000 and 0x00001000 or 0)+(b%0x00004000>=0x00002000 and c%0x00004000>=0x00002000 and 0x00002000 or 0)+(b%0x00008000>=0x00004000 and c%0x00008000>=0x00004000 and 0x00004000 or 0)+(b%0x00010000>=0x00008000 and c%0x00010000>=0x00008000 and 0x00008000 or 0)+(b%0x00020000>=0x00010000 and c%0x00020000>=0x00010000 and 0x00010000 or 0)+(b%0x00040000>=0x00020000 and c%0x00040000>=0x00020000 and 0x00020000 or 0)+(b%0x00080000>=0x00040000 and c%0x00080000>=0x00040000 and 0x00040000 or 0)+(b%0x00100000>=0x00080000 and c%0x00100000>=0x00080000 and 0x00080000 or 0)+(b%0x00200000>=0x00100000 and c%0x00200000>=0x00100000 and 0x00100000 or 0)+(b%0x00400000>=0x00200000 and c%0x00400000>=0x00200000 and 0x00200000 or 0)+(b%0x00800000>=0x00400000 and c%0x00800000>=0x00400000 and 0x00400000 or 0)+(b%0x01000000>=0x00800000 and c%0x01000000>=0x00800000 and 0x00800000 or 0)+(b%0x02000000>=0x01000000 and c%0x02000000>=0x01000000 and 0x01000000 or 0)+(b%0x04000000>=0x02000000 and c%0x04000000>=0x02000000 and 0x02000000 or 0)+(b%0x08000000>=0x04000000 and c%0x08000000>=0x04000000 and 0x04000000 or 0)+(b%0x10000000>=0x08000000 and c%0x10000000>=0x08000000 and 0x08000000 or 0)+(b%0x20000000>=0x10000000 and c%0x20000000>=0x10000000 and 0x10000000 or 0)+(b%0x40000000>=0x20000000 and c%0x40000000>=0x20000000 and 0x20000000 or 0)+(b%0x80000000>=0x40000000 and c%0x80000000>=0x40000000 and 0x40000000 or 0)+(b>=0x80000000 and c>=0x80000000 and 0x80000000 or 0)return d and a(e,d,...)or e end;local function f(b,c,d,...)local e=(b%0x00000002>=0x00000001~=(c%0x00000002>=0x00000001)and 0x00000001 or 0)+(b%0x00000004>=0x00000002~=(c%0x00000004>=0x00000002)and 0x00000002 or 0)+(b%0x00000008>=0x00000004~=(c%0x00000008>=0x00000004)and 0x00000004 or 0)+(b%0x00000010>=0x00000008~=(c%0x00000010>=0x00000008)and 0x00000008 or 0)+(b%0x00000020>=0x00000010~=(c%0x00000020>=0x00000010)and 0x00000010 or 0)+(b%0x00000040>=0x00000020~=(c%0x00000040>=0x00000020)and 0x00000020 or 0)+(b%0x00000080>=0x00000040~=(c%0x00000080>=0x00000040)and 0x00000040 or 0)+(b%0x00000100>=0x00000080~=(c%0x00000100>=0x00000080)and 0x00000080 or 0)+(b%0x00000200>=0x00000100~=(c%0x00000200>=0x00000100)and 0x00000100 or 0)+(b%0x00000400>=0x00000200~=(c%0x00000400>=0x00000200)and 0x00000200 or 0)+(b%0x00000800>=0x00000400~=(c%0x00000800>=0x00000400)and 0x00000400 or 0)+(b%0x00001000>=0x00000800~=(c%0x00001000>=0x00000800)and 0x00000800 or 0)+(b%0x00002000>=0x00001000~=(c%0x00002000>=0x00001000)and 0x00001000 or 0)+(b%0x00004000>=0x00002000~=(c%0x00004000>=0x00002000)and 0x00002000 or 0)+(b%0x00008000>=0x00004000~=(c%0x00008000>=0x00004000)and 0x00004000 or 0)+(b%0x00010000>=0x00008000~=(c%0x00010000>=0x00008000)and 0x00008000 or 0)+(b%0x00020000>=0x00010000~=(c%0x00020000>=0x00010000)and 0x00010000 or 0)+(b%0x00040000>=0x00020000~=(c%0x00040000>=0x00020000)and 0x00020000 or 0)+(b%0x00080000>=0x00040000~=(c%0x00080000>=0x00040000)and 0x00040000 or 0)+(b%0x00100000>=0x00080000~=(c%0x00100000>=0x00080000)and 0x00080000 or 0)+(b%0x00200000>=0x00100000~=(c%0x00200000>=0x00100000)and 0x00100000 or 0)+(b%0x00400000>=0x00200000~=(c%0x00400000>=0x00200000)and 0x00200000 or 0)+(b%0x00800000>=0x00400000~=(c%0x00800000>=0x00400000)and 0x00400000 or 0)+(b%0x01000000>=0x00800000~=(c%0x01000000>=0x00800000)and 0x00800000 or 0)+(b%0x02000000>=0x01000000~=(c%0x02000000>=0x01000000)and 0x01000000 or 0)+(b%0x04000000>=0x02000000~=(c%0x04000000>=0x02000000)and 0x02000000 or 0)+(b%0x08000000>=0x04000000~=(c%0x08000000>=0x04000000)and 0x04000000 or 0)+(b%0x10000000>=0x08000000~=(c%0x10000000>=0x08000000)and 0x08000000 or 0)+(b%0x20000000>=0x10000000~=(c%0x20000000>=0x10000000)and 0x10000000 or 0)+(b%0x40000000>=0x20000000~=(c%0x40000000>=0x20000000)and 0x20000000 or 0)+(b%0x80000000>=0x40000000~=(c%0x80000000>=0x40000000)and 0x40000000 or 0)+(b>=0x80000000~=(c>=0x80000000)and 0x80000000 or 0)return d and f(e,d,...)or e end;local function g(h)return 4294967295-h end;local function i(h,j)h=h%2^32;local k=h/2^j;return k-k%1 end;local function l(h,j)h=h%2^32;local k=h/2^j;local m=k%1;return k-m+m*2^32 end;local n={0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2}function str2hexa(o)local p=string.gsub(o,".",function(q)return string.format("%02x",string.byte(q))end)return p end;function num2s(r,s)local o=""for t=1,s do local u=r%256;o=string.char(u)..o;r=(r-u)/256 end;return o end;local function v(o,t)local s=0;for t=t,t+3 do s=s*256+string.byte(o,t)end;return s end;function preproc(w,x)local y=64-(x+1+8)%64;x=num2s(8*x,8)w=w.."\128"..string.rep("\0",y)..x;return w end;function initH256(z)z[1]=0x6a09e667;z[2]=0xbb67ae85;z[3]=0x3c6ef372;z[4]=0xa54ff53a;z[5]=0x510e527f;z[6]=0x9b05688c;z[7]=0x1f83d9ab;z[8]=0x5be0cd19;return z end;function digestblock(w,t,z)local A={}for B=1,16 do A[B]=v(w,t+(B-1)*4)end;for B=17,64 do local C=A[B-15]local D=f(l(C,7),l(C,18),i(C,3))C=A[B-2]local E=f(l(C,17),l(C,19),i(C,10))A[B]=A[B-16]+D+A[B-7]+E end;local F,G,q,H,I,J,K,p=z[1],z[2],z[3],z[4],z[5],z[6],z[7],z[8]for t=1,64 do local D=f(l(F,2),l(F,13),l(F,22))local L=f(a(F,G),a(F,q),a(G,q))local M=D+L;local E=f(l(I,6),l(I,11),l(I,25))local N=f(a(I,J),a(g(I),K))local O=p+E+N+n[t]+A[t]p,K,J,I,H,q,G,F=K,J,I,H+O,q,G,F,O+M end;z[1]=(z[1]+F)%2^32;z[2]=(z[2]+G)%2^32;z[3]=(z[3]+q)%2^32;z[4]=(z[4]+H)%2^32;z[5]=(z[5]+I)%2^32;z[6]=(z[6]+J)%2^32;z[7]=(z[7]+K)%2^32;z[8]=(z[8]+p)%2^32 end

function sha256.sha256bin(msg)
    local datauuid = component.list("data")()
    if datauuid and sha256.datacardSupport then
        local result = {pcall(component.invoke, datauuid, "sha256", msg)}
        if result[1] and type(result[2]) == "string" then
            return result[2]
        end
    end

    msg = preproc(msg, #msg)
    local H = initH256({})
    for i = 1, #msg, 64 do digestblock(msg, i, H) end
    return num2s(H[1], 4) .. num2s(H[2], 4) .. num2s(H[3], 4) .. num2s(H[4], 4) .. num2s(H[5], 4) .. num2s(H[6], 4) .. num2s(H[7], 4) .. num2s(H[8], 4)
end

function sha256.sha256hex(msg)
    return str2hexa(sha256.sha256bin(msg))
end

-------------------------------------------------

sha256.sha256 = sha256.sha256hex --legacy method
sha256.str2hexa = str2hexa
sha256.unloadable = true
return sha256system/core/lib/sides.lua 1157 local sides = {
    [0] = "bottom",
    [1] = "top",
    [2] = "back",
    [3] = "front",
    [4] = "right",
    [5] = "left",
  
    bottom = 0,
    top = 1,
    back = 2,
    front = 3,
    right = 4,
    left = 5,
  
    down = 0,
    up = 1,
    north = 2,
    south = 3,
    west = 4,
    east = 5,
  
    negy = 0,
    posy = 1,
    negz = 2,
    posz = 3,
    negx = 4,
    posx = 5,
  
    forward = 3
}
  
local metatable = getmetatable(sides) or {}

-- sides[0..5] are mapped to itertable[1..6].
local itertable = {
    sides[0],
    sides[1],
    sides[2],
    sides[3],
    sides[4],
    sides[5]
}

-- Future-proofing against the possible introduction of additional
-- logical sides (e.g. [7] = "all", [8] = "none", etc.).
function metatable.__len(sides)
return #itertable
end

-- Allow `sides` to be iterated over like a normal (1-based) array.
function metatable.__ipairs(sides)
    return ipairs(itertable)
end

function metatable.__index(self, key)
    local dtype = type(key)
    if dtype == "string" then
        return -1
    else
        return "unknown"
    end
end

setmetatable(sides, metatable)

sides.unloadable = true
return sidessystem/core/lib/syntax.lua 3195 local unicode = require("unicode")
local colors = require("colors")
local parser = require("parser")
local syntax = {}
syntax.keywords = {
    ["function"] = colors.magenta,
    ["return"] = colors.magenta,

    ["true"] = colors.blue,
    ["false"] = colors.blue,
    ["nil"] = colors.blue,
    
    ["local"] = colors.blue,

    ["until"] = colors.purple,
    ["repeat"] = colors.purple,
    ["while"] = colors.purple,
    ["for"] = colors.purple,
    ["if"] = colors.purple,
    ["in"] = colors.purple,
    ["then"] = colors.purple,
    ["end"] = colors.purple,
    ["do"] = colors.purple
}

function syntax.parse(code)
    local function spl(str)
        local lst = {}
        local oldChrType
        for i = 1, unicode.len(str) do
            local chr = unicode.sub(str, i, i)
            local chrType
            if chr >= "0" and chr <= "9" then
                chrType = 1
            elseif (chr >= "A" and chr <= "Z") or (chr >= "a" and chr <= "z") then
                chrType = 2
            elseif chr == "[" then
                chrType = 3
            elseif chr == "]" then
                chrType = 4
            elseif  chr == "-" then
                chrType = 5
            end

            if not chrType or oldChrType ~= chrType or #lst == 0 then
                table.insert(lst, "")
                oldChrType = chrType
            end

            lst[#lst] = lst[#lst] .. chr
        end
        return lst
    end

    local obj = {}
    local gcomment = false
    local counter = 1
    for posY, str in ipairs(parser.split(unicode, code, {"\n"})) do
        local posX = 1
        local lcomment = false
        local lostr = false
        local lostr2 = false
        for _, lstr in ipairs(spl(str)) do
            if lstr ~= "" then
                local lcolor

                if lstr == "--" then
                    lcomment = true
                elseif lstr == "[[" then
                    gcomment = true
                end

                local isred = lostr or lostr2
                if lstr == "\"" then
                    lostr = not lostr
                elseif lstr == "'" then
                    lostr2 = not lostr2
                end

                if lcomment or gcomment then
                    lcolor = colors.green
                elseif lostr or lostr2 or isred then
                    lcolor = colors.orange
                else
                    lcolor = syntax.keywords[lstr] or colors.white
                end
                
                if lstr == "]]" then
                    gcomment = false
                end

                table.insert(obj, {posX, posY, lstr, lcolor, counter})
            end
            posX = posX + unicode.len(lstr)
            counter = counter + unicode.len(lstr)
        end
        counter = counter + 1
    end
    return obj
end

function syntax.draw(x, y, obj, gpu, palette)
    for index, value in ipairs(obj) do
        if palette then
            gpu.setForeground(palette[value[4]] or 0)
        else
            gpu.setForeground(value[4], true)
        end
        gpu.set((x - 1) + value[1], (y - 1) + value[2], value[3])
    end
end

syntax.unloadable = true
return syntaxsystem/core/lib/system.lua 5136 local natives = require("natives")
local computer = require("computer")
local package = require("package")
local cache = require("cache")
local event = require("event")
local lastinfo = require("lastinfo")
local component = require("component")
local fs = require("filesystem")
local paths = require("paths")
local unicode = require("unicode")
local system = {unloadable = true}

-------------------------------------------------

function system.stub()
end

function system.getResourcePath(name)
    if unicode.sub(name, 1, 1) == "/" then
        return name
    end
    
    return paths.concat(paths.path(system.getSelfScriptPath()), name)
end

function system.getSelfScriptPath()
    for runLevel = 0, math.huge do
        local info = debug.getinfo(runLevel)

        if info then
            if info.what == "main" then
                return info.source:sub(2, -1)
            end
        else
            error("Failed to get debug info for runlevel " .. runLevel)
        end
    end
end

function system.getCpuLoadLevel(waitTime)
    waitTime = waitTime or 1
    local clock1 = os.clock()
    os.sleep(waitTime)
    local clock2 = os.clock()
    return math.clamp((clock2 - clock1) / waitTime, 0, 1)
end

function system.getDeviceType()
    local function isType(ctype)
        return natives.component.list(ctype)() and ctype
    end
    
    local function isServer()
        local obj = lastinfo.deviceinfo[computer.address()]
        if obj and obj.description and obj.description:lower() == "server" then
            return "server"
        end
    end
    
    return isType("tablet") or isType("microcontroller") or isType("drone") or isType("robot") or isServer() or isType("computer") or "unknown"
end

function system.getCpuLevel()
    local processor, isAPU, isCreative = -1, false, false

    for _, value in pairs(lastinfo.deviceinfo) do
        if value.clock and value.class == "processor" then
            local creativeApu = value.clock == "1500+2560/2560/320/5120/1280/2560"
            local apu3 = value.clock == "1000+1280/1280/160/2560/640/1280"
            local apu2 = value.clock == "500+640/640/40/1280/320/640"
            
            if creativeApu then
                isCreative = true
                isAPU = true
                processor = 3
                break
            elseif value.clock == "1500" or apu3 then
                isAPU = apu3
                processor = 3
                break
            elseif value.clock == "1000" or apu2 then
                isAPU = apu2
                processor = 2
                break
            elseif value.clock == "500" then
                processor = 1
                break
            end
        end
    end

    return processor, isAPU, isCreative
end

function system.getCurrentComponentCount()
    local count = 0
    for _, ctype in natives.component.list() do
        if ctype == "filesystem" then --файловые системы жрут 0.25 бюджета компанентов, и их можно подключить в читыри раза больше чем других компанентов
            count = count + 0.25
        else
            count = count + 1
        end
    end
    return count - 1 --свой комп не учитываеться в opencomputers
end

function system.getMaxComponentCount() --пока что не учитывает компанентные шины, так как они не детектяться в getDeviceInfo
    local cpu = system.getCpuLevel()
    if cpu == 1 then
        return 8
    elseif cpu == 2 then
        return 12
    elseif cpu == 3 then
        return 16
    else
        return -1
    end
end

function system.getDiskLevel(address) --fdd, tier1, tier2, tier3, raid, tmp, unknown
    local info = lastinfo.deviceinfo[address]
    local clock = info and info.clock

    if address == computer.tmpAddress() then
        return "tmp"
    elseif clock == "20/20/20" then
        return "fdd"
    elseif clock == "300/300/120" then
        return "raid"
    elseif clock == "80/80/40" then
        return "tier1"
    elseif clock == "140/140/60" then
        return "tier2"
    elseif clock == "200/200/80" then
        return "tier3"
    else
        return "unknown"
    end
end

function system.isLikeOSDisk(address)
    local signature = "--likeOS core"

    local file = component.invoke(address, "open", "/init.lua", "rb")
    if file then
        local data = component.invoke(address, "read", file, #signature)
        component.invoke(address, "close", file)
        return signature == data
    end
    return false
end

function system.checkExitinfo(...)
    local result = {...}
    if not result[1] and type(result[2]) == "table" and result[2].reason == "interrupted" then
        if result[2].code == 0 then
            return true
        else
            return false, "terminated with exit-code: " .. tostring(result[2].code)
        end
    end
    return table.unpack(result)
end

function system.getCharge()
    return math.clamp(math.round(math.map(computer.energy(), 0, computer.maxEnergy(), 0, 100)), 0, 100)
end

return systemsystem/core/lib/term.lua 3435 local parser = require("parser")
local unicode = require("unicode")
local graphic = require("graphic")
local event = require("event")
local term = {}

function term.create(screen, x, y, sizeX, sizeY, selected, isPal)
    local obj = {}
    obj.window = graphic.createWindow(screen, x, y, sizeX, sizeY, selected, isPal)
    obj.screen = screen
    obj.cursorX = 1
    obj.cursorY = 1
    obj.bg = isPal and 15 or 0x000000
    obj.fg = isPal and 0  or 0xffffff

    obj.x = x
    obj.y = y
    obj.sizeX = sizeX
    obj.sizeY = sizeY
    obj.selected = selected
    obj.isPal = isPal
    obj.defaultPrintTab = 8

    setmetatable(obj, {__index = term})
    return obj
end


function term:print(...)
    local args = table.pack(...)
    local len = args.n
    local printResult = ""
    
    for i = 1, len do
        local str = tostring(args[i])
        printResult = printResult .. str
        if i ~= len then
            local strlen = #str
            local dtablen = self.defaultPrintTab
            local tablen = 0
            while tablen <= 0 do
                tablen = dtablen - strlen
                dtablen = dtablen + self.defaultPrintTab
            end
            printResult = printResult .. string.rep(" ", tablen)
        end
    end

    self:writeLn(printResult)
end

function term:setColors(bg, fg)
    self.bg = bg
    self.fg = fg
end

function term:setCursor(x, y)
    self.cursorX = x
    self.cursorY = y
end

function term:getColors()
    return self.bg, self.fg
end

function term:getCursor()
    return self.cursorX, self.cursorY
end

function term:clear()
    self.window:clear(self.bg)
    self:setCursor(1, 1)
end

function term:newLine()
    self.cursorX = 1
    if self.cursorY < self.sizeY then
        self.cursorY = self.cursorY + 1
    else
        self.window:copy(1, 2, self.sizeX, self.sizeY - 1, 0, -1)
        self.window:fill(1, self.sizeY, self.sizeX, 1, self.bg, 0, " ")
    end
end

function term:write(str)
    str = tostring(str)
    for i, lstr in ipairs(parser.split(unicode, str, "\n")) do
        if i > 1 then
            self:newLine()
        end
        for i2, line in ipairs(parser.toLines(lstr, self.sizeX - (self.cursorX - 1))) do
            if i2 > 1 then
                self:newLine()
            end
            self.window:set(self.cursorX, self.cursorY, self.bg, self.fg, line)
            self.cursorX = self.cursorX + unicode.wlen(line)
            --[[
            if self.cursorX > self.sizeX then
                self:newLine()
            elseif i > 1 or i2 > 1 then
                self:newLine()
            end
            ]]
        end
    end
end

function term:writeLn(str)
    self:write(tostring(str) .. "\n")
end

function term:read(hidden, buffer, syntax, disHistory)
    local reader = self.window:read(self.cursorX, self.cursorY, self.sizeX - (self.cursorX - 1), self.bg, self.fg, nil, hidden, buffer, false, syntax, disHistory)
    while true do
        local eventData = {event.pull()}
        local windowEventData = self.window:uploadEvent(eventData)
        local out = reader.uploadEvent(windowEventData)
        if out == true then
            return false
        elseif type(out) == "string" then
            return out
        end
    end
end

function term:readLn(hidden, buffer, syntax, disHistory)
    local out = self:read(hidden, buffer, syntax, disHistory)
    self:newLine()
    return out
end

term.unloadable = true
return termsystem/core/lib/text.lua 1479 local text = {trimLetters = {" ", "\t", "\r", "\n"}}

function text.startwith(tool, str, startCheck)
    return tool.sub(str, 1, tool.len(startCheck)) == startCheck
end

function text.endwith(tool, str, endCheck)
    return tool.sub(str, tool.len(str) - (tool.len(endCheck) - 1), tool.len(str)) == endCheck
end

function text.trimLeft(tool, str, list)
    list = list or text.trimLetters

    local newstr = ""
    local allowTrim = true
    for i = 1, tool.len(str) do
        local char = tool.sub(str, i, i)
        if allowTrim then
            if not table.exists(list, char) then
                newstr = newstr .. char
                allowTrim = false
            end
        else
            newstr = newstr .. char
        end
    end
    return newstr
end

function text.trimRight(tool, str, list)
    list = list or text.trimLetters

    local newstr = ""
    local allowTrim = true
    for i = tool.len(str), 1, -1 do
        local char = tool.sub(str, i, i)
        if allowTrim then
            if not table.exists(list, char) then
                newstr = char .. newstr
                allowTrim = false
            end
        else
            newstr = char .. newstr
        end
    end
    return newstr
end

function text.trim(tool, str, list)
    str = text.trimLeft(tool, str, list)
    str = text.trimRight(tool, str, list)
    return str
end

function text.escapePattern(str)
    return str:gsub("([^%w])", "%%%1")
end

text.unloadable = true
return textsystem/core/lib/thread.lua 5176 local system = require("system")
local computer = require("computer")
local event = require("event")
local thread = {}
thread.threads = {}
thread.mainthread = coroutine.running()

function thread.decode(th)
    if th:status() ~= "dead" then
        error("thread.decode only works with dead thread", 2)
    end

    local out = th.out or {true}
    if out[1] then
        return table.unpack(out)
    else
        return nil, (tostring(out[2]) or "unknown error") .. "\n" .. (tostring(out[3]) or "")
    end
end

function thread.stub(func, ...)
    local th = thread.create(func, ...)
    th:resume()
    
    while th:status() ~= "dead" do
        event.yield()
    end

    return thread.decode(th)
end

function thread.xpcall(co, ...)
    local output = {system.checkExitinfo(coroutine.resume(co, ...))}
    if not output[1] then
        return nil, output[2], debug.traceback(co)
    end
    return table.unpack(output)
end

function thread.current()
    local currentT = coroutine.running()
    local function find(tbl)
        local parsetbl = tbl.childs
        if not parsetbl then parsetbl = tbl end
        for i = #parsetbl, 1, -1 do
            local v = parsetbl[i]
            if v.thread then
                if v.thread == currentT then
                    return v
                else
                    local obj = find(v)
                    if obj then
                        return obj
                    end
                end
            end
        end
    end
    return find(thread.threads)
end

function thread.all()
    local list = {}
    
    local function find(tbl)
        local parsetbl = tbl.childs
        if not parsetbl then parsetbl = tbl end
        for i = #parsetbl, 1, -1 do
            local v = parsetbl[i]
            if v.thread then
                table.insert(list, v)

                local obj = find(v)
                if obj then
                    return obj
                end
            end
        end
    end
    find(thread.threads)

    return list
end

function thread.attachThread(t, obj)
    if obj then
        t.parentData = table.deepclone(obj.parentData)
        t.parent = obj
        if obj.childs then
            table.insert(obj.childs, t)
        else
            table.insert(obj, t)
        end
        return true
    end
    table.insert(thread.threads, t)
    return true
end

local function create(func, ...)
    local t = coroutine.create(func)
    local obj = {
        args = {...},
        childs = {},
        thread = t,
        enable = false,
        raw_kill = raw_kill,
        kill = kill,
        resume = resume,
        suspend = suspend,
        status = status,
        decode = thread.decode,
        parentData = {},

        func = func,
    }
    return obj
end

function thread.create(func, ...)
    local obj = create(func, ...)
    thread.attachThread(obj, thread.current())
    return obj
end

function thread.createBackground(func, ...)
    local obj = create(func, ...)
    thread.attachThread(obj)
    return obj
end

function thread.createTo(func, connectTo, ...)
    local obj = create(func, ...)
    thread.attachThread(obj, connectTo)
    return obj
end

function thread.listen(eventType, func)
    return event.listen(eventType, func, thread.current())
end

function thread.timer(time, func, times)
    return event.timer(time, func, times, thread.current())
end

local function wait(forAny, threads, timeout)
    local startTime = computer.uptime()
    while true do
        local deadCount = 0
        for _, th in ipairs(threads) do
            if th:status() == "dead" then
                if forAny then
                    break
                end
                deadCount = deadCount + 1
            end
        end

        if deadCount >= #threads or (timeout and computer.uptime() - startTime > timeout) then
            break
        end

        event.yield()
    end

    local results = {}
    for _, th in ipairs(threads) do
        th:kill()
        table.insert(results, {th:decode()})
    end
    return results
end

function thread.waitForAll(threads, timeout)
    return wait(false, threads, timeout)
end

function thread.waitForAny(threads, timeout)
    return wait(true, threads, timeout)
end

------------------------------------thread functions

function raw_kill(t) --не стоит убивать паток через raw_kill
    t.dead = true
    t.enable = false
end

function kill(t) --вы сможете переопределить это в своем потоке, наример чтобы закрыть таймеры
    t:raw_kill()
end

function resume(t)
    t.enable = true
end

function suspend(t)
    t.enable = false
end

function status(t)
    if t.dead or not t.thread or coroutine.status(t.thread) == "dead" then
        t:kill()
        return "dead"
    end
    if t.parent then
        local status = t.parent:status()
        if status == "dead" then
            t:kill()
            return "dead"
        elseif status == "suspended" then
            return "suspended"
        end
    end
    if t.enable then
        return "running"
    else
        return "suspended"
    end
end

return threadsystem/core/lib/time.lua 1396 local fs = require("filesystem")
local time = {unloadable = true}

function time.getRealTime()
    local file = assert(fs.open("/tmp/null", "wb"))
    file.close()

    local unixTime = fs.lastModified("/tmp/null")
    fs.remove("/tmp/null")

    return unixTime
end

function time.getGameTime() --везврашяет игровые милисикунды
    return os.time() * 1000
end

------------------------------------------

function time.addTimeZone(unixTime, timezone)
    return ((unixTime / 1000) + (timezone * 60 * 60)) * 1000
end

function time.parseSecond(unixTime)
    return math.floor((unixTime / 1000) % 60)
end

function time.parseMinute(unixTime)
    return math.floor((unixTime / 1000 / 60) % 60)
end

function time.parseHours(unixTime)
    return math.floor((unixTime / 1000 / (60 * 60)) % 24)
end

function time.formatTime(unixTime, withSecond, withData)
    local str = ""

    local hours = tostring(time.parseHours(unixTime))
    if #hours < 2 then hours = "0" .. hours end
    str = str .. hours .. ":"

    local minute = tostring(time.parseMinute(unixTime))
    if #minute < 2 then minute = "0" .. minute end
    str = str .. minute

    if withSecond then
        str = str .. ":"
        local second = tostring(time.parseSecond(unixTime))
        if #second < 2 then second = "0" .. second end
        str = str .. second
    end

    return str
end

return timesystem/core/lib/utils.lua 1167 local utils = {}

function utils.check(func, ...)
    local result = {pcall(func, ...)}
    if result[1] then
        return table.unpack(result, 2)
    else
        return nil, result[2] or "unknown error"
    end
end

function utils.openPort(modem, port)
    local result, err = modem.open(port)
    if result == nil then --если открыто больше портов чем поддерживает модем(false означает что выбраный порт уже открыт, по этому проверка явная, на nil)
        modem.close()
        return modem.open(port)
    end
    return result, err
end

function utils.safeExec(func, errorOutput, tag) --для event.hyperHook или других hyper методов, обрабатывает ошибку и пишет в лог в случаи чего
    local result = {xpcall(func, debug.traceback)}
    if not result[1] then
        require("logs").log(result[2], tag or "safe exec error")
        if errorOutput then
            return table.unpack(errorOutput)
        end
    else
        return table.unpack(result, 2)
    end
end

utils.unloadable = true
return utilssystem/core/lib/uuid.lua 777 local uuid = {}
uuid.null = "00000000-0000-0000-0000-000000000000"

function uuid.next()
    local r = math.random
    return string.format("%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
    r(0,255),r(0,255),r(0,255),r(0,255),
    r(0,255),r(0,255),
    r(64,79),r(0,255),
    r(128,191),r(0,255),
    r(0,255),r(0,255),r(0,255),r(0,255),r(0,255),r(0,255))
end

function uuid.isValid(str)
    if #str ~= #uuid.null then
        return false
    end

    for i = 1, #uuid.null do
        local need = uuid.null:sub(i, i)
        local char = str:sub(i, i)

        if xor(need == "-", char == "-") or (need ~= "-" and not tonumber(char, 16)) then
            return false
        end
    end
    
    return true
end

uuid.unloadable = true
return uuidsystem/core/lib/vcomponent.lua 6530 --было довно от куда-то стырино(с github, но теперь его на github и нет вроде)
--данная либа позваляет регать виртуальные компаненты
--подгружаеться автоматически на этапе загрузки ядра, чтобы избежать проблем с неопределениям виртуальных компонентов
--нада добавить: возможность подключения к getDeviceInfo(сделал)

local component = require("component")
local computer = require("computer")

-------------------------------- storage

local proxylist = {}
local proxyobjs = {}
local typelist = {}
local doclist = {}
local infolist = {}

-------------------------------- hooks

local getDeviceInfo = computer.getDeviceInfo
function computer.getDeviceInfo()
    local info = getDeviceInfo()
    for addr, cinfo in pairs(infolist) do
        info[addr] = cinfo
    end
    return info
end

local oproxy = component.proxy
function component.proxy(address)
    checkArg(1, address, "string")
    if proxyobjs[address] ~= nil then
        return proxyobjs[address]
    end
    return oproxy(address)
end

local olist = component.list
function component.list(filter, exact)
    checkArg(1, filter, "string", "nil")
    local result = {}
    local data = {}
    for k, v in olist(filter, exact) do
        data[#data + 1] = k
        data[#data + 1] = v
        result[k] = v
    end
    for k, v in pairs(typelist) do
        if filter == nil or (exact and v == filter) or (not exact and v:find(filter, nil, true)) then
            data[#data + 1] = k
            data[#data + 1] = v
            result[k] = v
        end
    end
    local place = 1
    return setmetatable(result,
        {
            __call = function()
                local addr, type = data[place], data[place + 1]
                place = place + 2
                return addr, type
            end
        }
    )
end

local otype = component.type
function component.type(address)
    checkArg(1, address, "string")
    if typelist[address] ~= nil then
        return typelist[address]
    end
    return otype(address)
end

local odoc = component.doc
function component.doc(address, method)
    checkArg(1, address, "string")
    checkArg(2, method, "string")
    if proxylist[address] ~= nil then
        if proxylist[address][method] == nil then
            error("no such method", 2)
        end
        if doclist[address] ~= nil then
            return doclist[address][method]
        end
        return nil
    end
    return odoc(address, method)
end

local oslot = component.slot
function component.slot(address)
    checkArg(1, address, "string")
    if proxylist[address] ~= nil then
        return -1 -- vcomponents do not exist in a slot
    end
    return oslot(address)
end

local omethods = component.methods
function component.methods(address)
    checkArg(1, address, "string")
    if proxylist[address] ~= nil then
        local methods = {}
        for k, v in pairs(proxylist[address]) do
            if type(v) == "function" then
                methods[k] = true -- All vcomponent methods are direct
            end
        end
        return methods
    end
    return omethods(address)
end

local oinvoke = component.invoke
function component.invoke(address, method, ...)
    checkArg(1, address, "string")
    checkArg(2, method, "string")
    if proxylist[address] ~= nil then
        if proxylist[address][method] == nil then
            error("no such method", 2)
        end
        return proxylist[address][method](...)
    end
    return oinvoke(address, method, ...)
end

local ofields = component.fields
function component.fields(address)
    checkArg(1, address, "string")
    if proxylist[address] ~= nil then
        return {} -- What even is this?
    end
    return ofields(address)
end

-------------------------------- control

local vcomponent = {}
local componentCallback =
{
    __call = function(self, ...) return proxylist[self.address][self.name](...) end,
    __tostring = function(self) return (doclist[self.address] ~= nil and doclist[self.address][self.name] ~= nil) and
        doclist[self.address][self.name] or "function" end
}

function vcomponent.register(address, ctype, proxy, doc, info)
    checkArg(1, address, "string")
    checkArg(2, ctype, "string")
    checkArg(3, proxy, "table")
    checkArg(4, doc, "table", "nil")
    checkArg(5, info, "table", "nil")

    if proxylist[address] ~= nil then
        return nil, "component already at address"
    elseif component.type(address) ~= nil then
        return nil, "cannot register over real component"
    end
    proxy.address = address
    proxy.type = ctype
    local proxyobj = {}
    for k, v in pairs(proxy) do
        if type(v) == "function" then
            proxyobj[k] = setmetatable({ name = k, address = address }, componentCallback)
        else
            proxyobj[k] = v
        end
    end
    proxylist[address] = proxy
    proxyobjs[address] = proxyobj
    typelist[address] = ctype
    doclist[address] = doc
    infolist[address] = info
    computer.pushSignal("component_added", address, ctype)
    return true
end

function vcomponent.unregister(address)
    checkArg(1, address, "string")
    if proxylist[address] == nil then
        if component.type(address) ~= nil then
            return nil, "cannot unregister real component"
        else
            return nil, "no component at address"
        end
    end
    local thetype = typelist[address]
    proxylist[address] = nil
    proxyobjs[address] = nil
    typelist[address] = nil
    doclist[address] = nil
    infolist[address] = nil
    computer.pushSignal("component_removed", address, thetype)
    return true
end

function vcomponent.list()
    local list = {}
    for k, v in pairs(proxylist) do
        list[#list + 1] = { k, typelist[k], v }
    end
    return list
end

function vcomponent.resolve(address, componentType)
    checkArg(1, address, "string")
    checkArg(2, componentType, "string", "nil")
    for k, v in pairs(typelist) do
        if componentType == nil or v == componentType then
            if k:sub(1, #address) == address then
                return k
            end
        end
    end
    return nil, "no such component"
end

function vcomponent.uuid()
    return require("uuid").next()
end

function vcomponent.isVirtual(address)
    return not not proxylist[address]
end

return vcomponentsystem/core/lib/vcursor.lua 6325 local lastinfo = require("lastinfo")
local utils = require("utils")
local event = require("event")
local graphic = require("graphic")
local vcursor = {}
local hooked = {}
local enabled = {}

function vcursor.hook(screen)
    if hooked[screen] then return false end
    hooked[screen] = true

    local active = false
    local pressed1 = false
    local pressed2 = false
    local invertFlag = false
    local posx, posy = 1, 1

    local function invertPos(x, y)
        pcall(function ()
            local char, fore, back = graphic.get(screen, x or posx, y or posy)
            if char then
                graphic.set(screen, x or posx, y or posy, 0xffffff - back, 0xffffff - fore, char)
            end
        end)
    end

    event.hyperHook(function (...)
        local eventData = {...}

        return utils.safeExec(function ()
            if not enabled[screen] then
                if active and not invertFlag then
                    invertPos()
                end
                active = false
                invertFlag = false
                return
            end

            if (eventData[1] == "key_down" or eventData[1] == "key_up") and table.exists(lastinfo.keyboards[screen], eventData[2]) then
                if eventData[1] == "key_up" and invertFlag then
                    invertPos()
                    invertFlag = false
                end

                if eventData[3] == 0 and eventData[4] == 56 then
                    if eventData[1] == "key_down" then
                        active = true
                        invertPos()
                    else
                        active = false
                        pressed1 = false
                        pressed2 = false
                        invertPos()
                    end
                end

                if active then
                    if eventData[1] == "key_down" then
                        local rx, ry = graphic.getResolution(screen)
                        local newposx, newposy = posx, posy
                        local cursorMove, cursorAction, replaceEvent = false, false, false

                        if eventData[4] == 17 then
                            cursorMove = true
                            replaceEvent = true
                            newposy = newposy - 1
                            if newposy < 1 then newposy = 1 end
                        elseif eventData[4] == 31 then
                            cursorMove = true
                            replaceEvent = true
                            newposy = newposy + 1
                            if newposy > ry then newposy = ry end
                        elseif eventData[4] == 30 then
                            cursorMove = true
                            replaceEvent = true
                            newposx = newposx - 1
                            if newposx < 1 then newposx = 1 end
                        elseif eventData[4] == 32 then
                            cursorMove = true
                            replaceEvent = true
                            newposx = newposx + 1
                            if newposx > rx then newposx = rx end
                        elseif eventData[4] == 16 then
                            replaceEvent = true
                            if not pressed1 then
                                event.push("touch", screen, posx, posy, 0, eventData[5])
                                cursorAction = true
                            end
                            pressed1 = true
                        elseif eventData[4] == 18 then
                            replaceEvent = true
                            if not pressed2 then
                                event.push("touch", screen, posx, posy, 1, eventData[5])
                                cursorAction = true
                            end
                            pressed2 = true
                        end

                        if newposx ~= posx or newposy ~= posy then
                            if not invertFlag then
                                invertPos()
                            end
                            posx, posy = newposx, newposy
                            invertPos()

                            if cursorMove then
                                invertFlag = false

                                if pressed1 then
                                    event.push("drag", screen, posx, posy, 0, eventData[5])
                                end
            
                                if pressed2 then
                                    event.push("drag", screen, posx, posy, 1, eventData[5])
                                end
                            end
                        end

                        if cursorAction then
                            invertPos()
                            invertFlag = true
                        end

                        if replaceEvent then
                            eventData[1] = "vcursor_" .. eventData[1]
                        end
                    elseif eventData[1] == "key_up" then
                        if eventData[4] == 16 then
                            if pressed1 then
                                event.push("drop", screen, posx, posy, 0, eventData[5])
                            end
                            pressed1 = false
                        elseif eventData[4] == 18 then
                            if pressed2 then
                                event.push("drop", screen, posx, posy, 1, eventData[5])
                            end
                            pressed2 = false
                        end
                    end
                else
                    if pressed1 then
                        event.push("drop", screen, posx, posy, 0, eventData[5])
                    end

                    if pressed2 then
                        event.push("drop", screen, posx, posy, 1, eventData[5])
                    end
                    
                    pressed1 = false
                    pressed2 = false
                end
            end

            return table.unpack(eventData)
        end, eventData, "vcursor error")
    end)

    return true
end

function vcursor.setEnable(screen, state)
    enabled[screen] = state
end

return vcursorsystem/core/lib/vgpu.lua 16002 local unicode = require("unicode")
local graphic = require("graphic")
local vgpu = {}

local pairs = pairs
local floor = math.floor
local concat = table.concat
local huge = math.huge

local unicode_len = unicode.len
local unicode_sub = unicode.sub

local gradients = {"░", "▒", "▓"}
local function formatColor(gpu, back, backPal, fore, forePal, text, noPalIndex)
    local depth = gpu.getDepth()
    if not graphic.colorAutoFormat or depth > 1 then
        return back, backPal, fore, forePal, text
    end

    local function getGradient(col, pal)
        if pal and col >= 0 and col <= 15 then
            col = gpu.getPaletteColor(col)
        end
        
        local r, g, b = require("colors").unBlend(col or 0x000000)
        local step = math.round(255 / #gradients)
        local val = ((r + g + b) / 3)
        local index = 1
        for i = 0, 255, step do
            if i > val then
                return gradients[math.min(index - 1, #gradients)]
            end
            index = index + 1
        end
        return gradients[#gradients]
    end

    local function formatCol(col, pal)
        if depth == 1 then
            if pal and col >= 0 and col <= 15 then
                col = gpu.getPaletteColor(col)
            end

            if col == 0x000000 then
                return 0x000000
            elseif col == 0xffffff then
                return 0xffffff
            end
        else
            return col, pal
        end
    end

    local oldEquals = back == fore
    local newBack, newBackPal = formatCol(back, backPal)
    local newFore, newForePal = formatCol(fore, forePal)
    local gradient, gradientEmpty = nil, true

    if not newBack then
        newBack = 0x000000
        gradient = getGradient(back, backPal)
        local buff = {}
        local buffI = 1
        for i = 1, unicode.len(text) do
            local char = unicode.sub(text, i, i)
            if char == " " then
                buff[buffI] = gradient
            else
                buff[buffI] = char
                gradientEmpty = false
            end
            buffI = buffI + 1
        end
        text = table.concat(buff)
    end

    if not newFore then
        newFore = 0xffffff
    end

    if depth == 1 then
        if not oldEquals and newBack == newFore then
            if gradient and gradientEmpty then
                newBack = 0x000000
                newFore = 0xffffff
            else
                if newFore == 0 then
                    newBack = 0xffffff
                else
                    newFore = 0
                end
            end
        end
    elseif noPalIndex then
        if newBackPal then
            if newBack >= 0 and newBack <= 15 then
                newBack = gpu.getPaletteColor(newBack)
            end
            newBackPal = false
        end

        if newForePal then
            if newFore >= 0 and newFore <= 15 then
                newFore = gpu.getPaletteColor(newFore)
            end
            newForePal = false
        end
    end

    return newBack, newBackPal, newFore, newForePal, text
end

function vgpu.create(gpu, screen)
    local obj = {}

    local getScreen = gpu.getScreen
    local bind = gpu.bind
    local setActiveBuffer = gpu.setActiveBuffer
    local getActiveBuffer = gpu.getActiveBuffer
    local getResolution = gpu.getResolution
    local getBackground = gpu.getBackground
    local getForeground = gpu.getForeground
    local setBackground = gpu.setBackground
    local setForeground = gpu.setForeground
    local getPaletteColor = gpu.getPaletteColor
    local setPaletteColor = gpu.setPaletteColor
    local setResolution = gpu.setResolution
    local copy = gpu.copy
    local set = gpu.set
    
    local function init()
        if getScreen() ~= screen then
            bind(screen, false)
        end
        if setActiveBuffer and getActiveBuffer() ~= 0 then
            setActiveBuffer(0)
        end
    end
    init()

    local updated = false
    local forceUpdate = true

    local currentBackgrounds = {}
    local currentForegrounds = {}
    local currentChars = {}

    local backgrounds = {}
    local foregrounds = {}
    local chars = {}

    local currentBack, currentBackPal = getBackground()
    local currentFore, currentForePal = getForeground()
    local origCurrentBack, origCurrentFore = currentBack, currentFore

    local rx, ry = getResolution()
    local rsmax = rx + ((ry - 1) * rx)

    for i = 1, rsmax do
        backgrounds[i] = 0
        foregrounds[i] = 0xffffff
        chars[i] = " "
    end

    for key, value in pairs(gpu) do
        obj[key] = value
    end

    local vpal = {}
    local depth = gpu.getDepth()

    function obj.getSoftwareBuffers()
        return chars, foregrounds, backgrounds
    end

    function obj.updateFlag()
        updated = true
    end

    function obj.setDepth(d)
        local out = gpu.setDepth(d)
        depth = d
        if d > 1 then
            for i = 0, 15 do
                vpal[i] = getPaletteColor(i)
            end
        else
            for i = 0, 15 do
                vpal[i] = 0
            end
        end
        return out
    end
    obj.setDepth(depth)

    function obj.getDepth()
        return depth
    end

    function obj.getPaletteColor(i)
        return vpal[i]
    end

    function obj.setPaletteColor(i, v)
        local out
        if depth > 1 then
            out = setPaletteColor(i, v)
        else
            out = vpal[i]
        end
        vpal[i] = v
        --forceUpdate = true
        return out
    end



    function obj.getBackground()
        return origCurrentBack, currentBackPal
    end

    function obj.getForeground()
        return origCurrentFore, currentForePal
    end

    local old, oldPal
    function obj.setBackground(col, isPal)
        --checkArg(1, col, "number")
        --checkArg(2, isPal, "boolean", "nil")

        old = currentBack
        oldPal = currentBackPal
        if isPal then
            currentBack = vpal[col]
        else
            currentBack = col
        end
        origCurrentBack = col
        currentBackPal = not not isPal
        return old, oldPal
    end

    function obj.setForeground(col, isPal)
        --checkArg(1, col, "number")
        --checkArg(2, isPal, "boolean", "nil")
        
        old = currentFore
        oldPal = currentForePal
        if isPal then
            currentFore = vpal[col]
        else
            currentFore = col
        end
        origCurrentFore = col
        currentForePal = not not isPal
        return old, oldPal
    end

    function obj.getResolution()
        return rx, ry
    end

    function obj.setResolution(x, y)
        x = floor(x)
        y = floor(y)

        init()
        setResolution(x, y)

        rx, ry = x, y
        rsmax = rx + ((ry - 1) * rx)
        
        for i = 1, rsmax do
            if not backgrounds[i] then
                backgrounds[i] = 0
                foregrounds[i] = 0xffffff
                chars[i] = " "
            end
        end
        for i = rsmax + 1, huge do
            if backgrounds[i] then
                backgrounds[i] = nil
                foregrounds[i] = nil
                chars[i] = nil
            else
                break
            end
        end
    end

    local index
    function obj.get(x, y)
        x = floor(x)
        y = floor(y)

        index = x + ((y - 1) * rx)
        return chars[index], foregrounds[index], backgrounds[index]
    end

    function obj.set(x, y, text, vertical)
        local currentBack, _, currentFore, _, text = formatColor(obj, currentBack, currentBackPal, currentFore, currentForePal, text, true)
        x = floor(x)
        y = floor(y)

        if vertical then
            for i = 1, unicode_len(text) do
                if y + (i - 1) > ry then break end
                index = ((x - 1) * rx) + y + (i - 1)
                backgrounds[index] = currentBack
                foregrounds[index] = currentFore
                chars[index] = unicode_sub(text, i, i)
            end
        else
            for i = 1, unicode_len(text) do
                if x + (i - 1) > rx then break end
                index = x + (i - 1) + ((y - 1) * rx)
                backgrounds[index] = currentBack
                foregrounds[index] = currentFore
                chars[index] = unicode_sub(text, i, i)
            end
        end

        updated = true
    end

    function obj.fill(x, y, sizeX, sizeY, char)
        local currentBack, _, currentFore, _, char = formatColor(obj, currentBack, currentBackPal, currentFore, currentForePal, char, true)
        x = floor(x)
        y = floor(y)
        sizeX = floor(sizeX)
        sizeY = floor(sizeY)

        for ix = x, x + (sizeX - 1) do
            if ix > rx then break end
            for iy = y, y + (sizeY - 1) do
                if iy > ry then break end
                index = ix + ((iy - 1) * rx)
                backgrounds[index] = currentBack
                foregrounds[index] = currentFore
                chars[index] = char
            end
        end

        updated = true
    end

    local newB, newF, newC, index, newindex
    function obj.copy(x, y, sx, sy, ox, oy)
        x = floor(x)
        y = floor(y)
        sx = floor(sx)
        sy = floor(sy)
        ox = floor(ox)
        oy = floor(oy)

        --обновляем картинку на экране
        if updated then
            obj.update()
        else
            init()
        end

        --фактически копируем картинку
        copy(x, y, sx, sy, ox, oy)

        --капируем картинку в буфере
        newB, newF, newC = {}, {}, {}
        --local newBP, newFP = {}, {}
        for ix = x, x + (sx - 1) do 
            for iy = y, y + (sy - 1) do
                index = ix + ((iy - 1) * rx)
                newindex = ix + ox + (((iy + oy) - 1) * rx)

                newB[newindex] = backgrounds[index]
                newF[newindex] = foregrounds[index]
                newC[newindex] = chars[index]
            end
        end

        for newindex in pairs(newC) do
            backgrounds[newindex] = newB[newindex]
            foregrounds[newindex] = newF[newindex]
            chars[newindex] = newC[newindex]
            
            currentBackgrounds[newindex] = newB[newindex] --чтобы это не требовалось перерисовывать(так как этот метод применяет изображения сразу)
            currentForegrounds[newindex] = newF[newindex]
            currentChars[newindex] = newC[newindex]
        end
    end

    --------------------------------

    local oldBg, oldFg
    function obj.update()
        if updated or forceUpdate then
            init()

            local index, buff, buffI, back, fore
            local i = 1
            local pixels = {}
            local chr
            while i <= rsmax do
                if forceUpdate or backgrounds[i] ~= currentBackgrounds[i] or
                    foregrounds[i] ~= currentForegrounds[i] or
                    chars[i] ~= currentChars[i] or
                    i % rx == 0 then
                    
                    back = backgrounds[i]
                    fore = foregrounds[i]

                    buff = {}
                    buffI = 1
                    index = i
                    while true do
                        chr = chars[i]
                        
                        buff[buffI] = chr
                        buffI = buffI + 1
                        if i % rx ~= 0 and
                        back == backgrounds[i + 1] and
                        (chars[i + 1] == " " or fore == foregrounds[i + 1]) then
                            currentBackgrounds[i] = backgrounds[i]
                            currentForegrounds[i] = foregrounds[i]
                            currentChars[i] = chr
                            i = i + 1
                        else
                            break
                        end
                    end

                    pixels[back] = pixels[back] or {}
                    pixels[back][fore] = pixels[back][fore] or {}
                    pixels[back][fore][index - 1] = concat(buff)
                end

                currentBackgrounds[i] = backgrounds[i]
                currentForegrounds[i] = foregrounds[i]
                currentChars[i] = chars[i]
                i = i + 1
            end

            for bg, fgs in pairs(pixels) do
                if bg ~= oldBg then
                    setBackground(bg)
                    oldBg = bg
                end

                for fg, sets in pairs(fgs) do
                    if fg ~= oldFg then
                        setForeground(fg)
                        oldFg = fg
                    end

                    for idx, text in pairs(sets) do
                        set((idx % rx) + 1, (idx // rx) + 1, text)
                    end
                end
            end

            updated = false
            forceUpdate = false
        end
    end

    return obj
end

function vgpu.createStub(gpu)
    local obj = {}
    for key, value in pairs(gpu) do
        obj[key] = value
    end

    local back, backPal = gpu.getBackground()
    local fore, forePal = gpu.getForeground()
    local bgUpdated, fgUpdated = false, false

    local vpal = {}
    local depth = gpu.getDepth()

    function obj.setDepth(d)
        local out = gpu.setDepth(d)
        depth = d
        if d > 1 then
            for i = 0, 15 do
                vpal[i] = gpu.getPaletteColor(i)
            end
        else
            for i = 0, 15 do
                vpal[i] = 0
            end
        end
        return out
    end
    obj.setDepth(depth)

    function obj.getDepth()
        return depth
    end

    function obj.getPaletteColor(i)
        return vpal[i]
    end

    function obj.setPaletteColor(i, v)
        local out
        if depth > 1 then
            out = gpu.setPaletteColor(i, v)
        else
            out = vpal[i]
        end
        vpal[i] = v
        return out
    end




    function obj.getBackground()
        return back, backPal
    end

    function obj.getForeground()
        return fore, forePal
    end

    function obj.setBackground(col, pal)
        bgUpdated = true
        local old, oldPal = fore, forePal
        back, backPal = col, pal
        return old, oldPal
    end

    function obj.setForeground(col, pal)
        fgUpdated = true
        local old, oldPal = fore, forePal
        fore, forePal = col, pal
        return old, oldPal
    end


    local function formatPal(col, isPal)
        if depth == 1 and isPal then
            return vpal[col] or 0
        end
        return col, isPal
    end

    function obj.set(x, y, text, vertical)
        local newBack, newBackPal, newFore, newForePal, text = formatColor(obj, back, backPal, fore, forePal, text)
        newBack, newBackPal = formatPal(newBack, newBackPal)
        newFore, newForePal = formatPal(newFore, newForePal)

        if fgUpdated then
            gpu.setForeground(newFore, newForePal)            
            fgUpdated = false
        end
        if bgUpdated then
            gpu.setBackground(newBack, newBackPal)
            bgUpdated = false
        end
        gpu.set(x, y, text, vertical)
    end

    function obj.fill(x, y, sx, sy, char)
        local newBack, newBackPal, newFore, newForePal, char = formatColor(obj, back, backPal, fore, forePal, char)
        newBack, newBackPal = formatPal(newBack, newBackPal)
        newFore, newForePal = formatPal(newFore, newForePal)

        if fgUpdated then
            gpu.setForeground(newFore, newForePal)            
            fgUpdated = false
        end
        if bgUpdated then
            gpu.setBackground(newBack, newBackPal)
            bgUpdated = false
        end
        gpu.fill(x, y, sx, sy, char)
    end

    return obj
end

vgpu.unloadable = true
return vgpusystem/core/logo.lua 923 bootloader.initScreen(gpu, screen, 50, 16)
gpu.fill(1, 1, 50, 16, " ")
gpu.set(1, 4 , [[ ▒       ▒  ▒   ▒   ▒▒▒▒▒▒   █████████  █████████   ]])
gpu.set(1, 5 , [[ ▒          ▒  ▒    ▒        █       █  █           ]])
gpu.set(1, 6 , [[ ▒       ▒  ▒ ▒     ▒        █       █  █           ]])
gpu.set(1, 7 , [[ ▒       ▒  ▒▒      ▒        █       █  █           ]])
gpu.set(1, 8 , [[ ▒       ▒  ▒▒      ▒▒▒▒▒▒   █       █  █████████   ]])
gpu.set(1, 9 , [[ ▒       ▒  ▒ ▒     ▒        █       █          █   ]])
gpu.set(1, 10, [[ ▒       ▒  ▒  ▒    ▒        █       █          █   ]])
gpu.set(1, 11, [[ ▒▒▒▒▒▒  ▒  ▒   ▒   ▒▒▒▒▒▒   █████████  █████████   ]])
gpu.set(1, 16, text or "")system/core/luaenv/a_base.lua 693 function _G.loadfile(path, mode, env)
    local fs = require("filesystem")
    local content, err = fs.readFile(path)
    if not content then return nil, err end
    return load(content, "=" .. path, mode, env or require("bootloader").createEnv())
end

--вы не должны запускать им проги! это вызовет проблеммы с обработкой ошибок и потоками в целевой программе, для запуска программ используйте programs.execute
function _G.dofile(path, ...)
    local code, err = loadfile(path)
    if not code then
        return error(err .. ":" .. path, 0)
    end
    return code(...)
endsystem/core/luaenv/b_os.lua 1150 local fs = require("filesystem")
local programs = require("programs")
local paths = require("paths")
local system = require("system")

------------------------------------------------

local osenv = {}

os.remove = fs.remove
os.rename = fs.rename

function os.execute(command) --в системе пока-что нет консоли
    if not command then return true end
    return programs.execute(command)
end

function os.tmpname()
    local name = ""
    for i = 1, 16 do
        name = name .. tostring(math.floor(math.random(0, 9)))
    end
    name = name .. ".tmp"

    return paths.concat("/tmp", name)
end

function os.getenv(varname)
    return osenv[varname]
end

function os.setenv(varname, value)
    osenv[varname] = value
    return value --так работает в openOS
end

------------------------------------------------

function os.exit(code)
    error({reason = "interrupted", code = code or 0}, 0)
end

local native_pcall = pcall
local native_xpcall = xpcall

function _G.pcall(...)
    return system.checkExitinfo(native_pcall(...))
end

function _G.xpcall(...)
    return system.checkExitinfo(native_xpcall(...))
endsystem/core/unittests/a_readbit.lua 1952 local values = {
    {
        [0] = 0,
        false,
        false,
        false,
        false,
        false,
        false,
        false,
        false
    },
    {
        [0] = 255,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        true
    },
    {
        [0] = 1,
        true,
        false,
        false,
        false,
        false,
        false,
        false,
        false
    },
    {
        [0] = 2,
        false,
        true,
        false,
        false,
        false,
        false,
        false,
        false
    },
    {
        [0] = 3,
        true,
        true,
        false,
        false,
        false,
        false,
        false,
        false
    },
    {
        [0] = 4,
        false,
        false,
        true,
        false,
        false,
        false,
        false,
        false
    },
    {
        [0] = 5,
        true,
        false,
        true,
        false,
        false,
        false,
        false,
        false
    },
    {
        [0] = 6,
        false,
        true,
        true,
        false,
        false,
        false,
        false,
        false
    },
    {
        [0] = 127,
        true,
        true,
        true,
        true,
        true,
        true,
        true,
        false
    },
}

local okcount, errs = 0, {}
for i, v in ipairs(values) do
    local isErr

    for i = 1, 8 do
        local out = bit32.readbit(v[0], i - 1)
        if out ~= v[i] then
            table.insert(errs,
                "value " .. tostring(math.floor(v[0])) .. ", \n" ..
                "index " .. tostring(math.floor(i)) .. ", \n" ..
                "out " .. tostring(out) .. ", \n" ..
                "target " .. tostring(v[i])
            )
            isErr = true
        end
    end

    if not isErr then
        okcount = okcount + 1
    end
end

return okcount == #values, table.concat(errs, ", \n\n")system/core/unittests/b_writebit.lua 345 for i = 1, 16 do
    local bytes = {}
    local byte = math.random(0, 255)
    for i = 1, 8 do
        bytes[i] = math.random(0, 1) == 0
        byte = bit32.writebit(byte, i - 1, bytes[i])
    end
    
    for i, v in ipairs(bytes) do
        if bit32.readbit(byte, i - 1) ~= v then
            return false
        end
    end
end

return truesystem/core/unittests/c_split.lua 120 return table.concat(require("parser").split(string, ";asd;;123123;00;;;;0l;;;", ";"), " ") == " asd  123123 00    0l   "system/core/unittests/d_toParts.lua 129 return table.concat(require("parser").toParts(string, ";asd;;123123;00;;;;0l;;;asd", 8), " ") == ";asd;;12 3123;00; ;;;0l;;; asd"system/core/unittests/e_sha256.lua 188 local result = require("sha256").sha256hex("TEST SHA256 INPUT DATA") == "08719f850b98037569a57205d9dc7b6a62d4fbf1a1ebcafefefa947e91bf05e9"
require("package").unload("sha256")
return resultsystem/images/account.t2p 1450          ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀5⡿5⠿5⠛5⠛5⠛5⠛5⠛5⠛5⠿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀5⡿5⠛S⣾U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀S⣶5⠻5⢿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀S⣴U⠀U⠀U⠀U⠀U⠀U⠀⣴⣶⣶P⠻U⠀U⠀U⠀U⠀U⠀U⠀5⠻ ⠀ ⠀ ⠀ ⠀ ⠀S⣼U⠀U⠀U⠀U⠀U⠀U⠀P⣧⣿⣿⣿⣿U⠀U⠀U⠀U⠀U⠀U⠀U⠀S⣧ ⠀ ⠀ ⠀S⣸U⠀U⠀U⠀U⠀U⠀U⠀U⠀P⠟⣬⣙⣫⣥P⠻U⠀U⠀U⠀U⠀U⠀U⠀U⠀5⢹ ⠀ ⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀⣾⣿⣿⣿⣿⣿⣿⣧U⠀U⠀U⠀U⠀U⠀U⠀S⣧ ⠀ ⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀P⣶P⣶P⣶P⣶P⣶P⣶P⣶P⣶U⠀U⠀U⠀U⠀U⠀U⠀S⡟ ⠀ ⠀5⣇U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀5⣼ ⠀ ⠀ ⠀S⠹U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀S⠏ ⠀ ⠀ ⠀ ⠀ ⠀5⣦S⢿U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀S⡿5⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀5⣶S⠻S⢿U⠀U⠀U⠀U⠀U⠀U⠀U⠀U⠀S⠿S⠛5⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀5⣶5⣶5⣶5⣶5⣶5⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀system/images/account.t3p 2026 3f         ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀7: ⡿=? ⠿=? ⠛=? ⠛=? ⠛=? ⠛=? ⠛=? ⠛=? ⠿   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀=? ⡿=? ⠛آ?⠿آ?⠛ ? ⣶ ? ⣶   ⠀   ⠀   ⠀   ⠀ ? ⣶ ? ⣦آ?⠛  ?⣶=? ⠻7: ⢿   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀  ?⣴ p?⠟]pu⣰]vu⣶]vu⣶U u⣶X u⣾  ⣴  ⣶  ⣶  ⣄U u⣶U u⣶U u⣾]vu⣷]qu⣾ p?⢻=? ⠻   ⠀   ⠀   ⠀   ⠀   ⠀  ?⣼]?D⣴]pt⣤Utu⠛Utu⠻Uut⣴Uut⣶P y⣧  ⣿  ⣿  ⣿  ⣿Uty⢢Uut⣶Uut⣶Uut⣦Utu⠛ tp⠛ D?⠹  ?⣧   ⠀   ⠀   ⠀  ?⣸]?D⣼UID⡏UIt⣶UIt⣾Uty⣴Uty⣾Uyy⠀P y⠟y ⣬y ⣙y ⣫y ⣥P y⠻U y⢿Uyy⠀Uty⣮Uyt⠻UIt⣶UID⢻]?D⣇=? ⢹   ⠀   ⠀ D?⣟UtD⡿UIt⣼Uty⣴Uyy⠀Uyy⠀Uyy⠀  ⣾  ⣿  ⣿  ⣿  ⣿  ⣿  ⣿y ⣧Uyy⠀Uyy⠀Uyy⠀Uty⣧Utt⠀UoD⢹  ?⣧   ⠀   ⠀ D?⡇UtD⡇Uyt⡇Uyy⠀Uyy⠀Uyy⠀U y⡿P y⣶P y⣶P y⣶P y⣶Uy ⡛P y⣶P y⣶P y⣶U y⢿Uyy⠀Uyy⠀Uyy⠀Uyt⣽UtD⢸S D⡟   ⠀   ⠀5D ⣇UoD⠇Uyt⣷Uyy⠀Uyy⠀U y⡿U y⣻U y⡾U y⠿U y⠫Uy ⣾U  ⠀U y⠿Uy ⣖Uy ⣕U y⢿Uyy⠀Uyy⠀Uyy⠀Utt⠀UoD⢸5D ⣼   ⠀   ⠀   ⠀5D ⣆Uot⠹Uyt⣧U y⡿U y⣷Uyy⠀U y⣯U  ⠀Uy ⣻U  ⠀Uy ⢿Uy ⡿Uy ⠟Uy ⠛Uy ⢗Uyy⠀Uty⣼Uyt⣸Uot⠏5o ⣰   ⠀   ⠀   ⠀   ⠀   ⠀5o ⣦Uto⣧Uyt⣷Uty⠻Uy ⣵Uy ⣥U y⠏Uy ⣝Uy ⠧Uy ⢹U y⢞U y⢳Uy ⣱Uy ⣶Ut ⠞Uyt⣾Uto⣼5o ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀5o ⣶S t⠻U t⣷U t⣦Ut ⠳Ut ⠿Ut ⠿Ut ⠿Ut ⠿Ut ⠞U t⣴S t⠿5t ⣤5o ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀5o ⣶5t ⣶5t ⣶5t ⣶5t ⣶5o ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀system/images/accountLock.t2p 1450          ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀1⡿1⠿1⠛1⠛1⠛1⠛1⠛1⠛1⠿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀1⡿1⠛⣾⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣶1⠻1⢿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀⣴⠀⠀⠀⠀⠀⠀⣴⣶⣶⠻⠀⠀⠀⠀⠀⠀1⠻ ⠀ ⠀ ⠀ ⠀ ⠀⣼⠀⠀⠀⠀⠀⠀⣧⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⣧ ⠀ ⠀ ⠀⣸⠀⠀⠀⠀⠀⠀⠀⠟⣬⣙⣫⣥⠻⠀⠀⠀⠀⠀⠀⠀1⢹ ⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣾⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⣧ ⠀ ⠀⠀⠀⠀⠀⠀⠀⠀⣶⣶⣶⣶⣶⣶⣶⣶⠀⠀⠀⠀⠀⠀⡟ ⠀ ⠀1⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀1⣼ ⠀ ⠀ ⠀⠹⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠏ ⠀ ⠀ ⠀ ⠀ ⠀1⣦⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡿1⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀1⣶⠻⢿⠀⠀⠀⠀⠀⠀⠀⠀⠿⠛1⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀1⣶1⣶1⣶1⣶1⣶1⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀system/images/accountLock.t3p 2026 3f         ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀<e ⡿5  ⠿5  ⠛5  ⠛5  ⠛5  ⠛5  ⠛5  ⠛5  ⠿   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀5  ⡿5  ⠛S  ⣾T͖⠛E  ⣶E  ⣶D  ⠀D  ⠀D  ⠀D  ⡿E  ⣶E  ⣦T͖⠛S  ⣶5  ⠻<e ⢿   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀5  ⠋Qǖ⠟  ⣾D  ⣶D  ⣶D  ⠀A  ⡟  ⣴  ⣶  ⣶  ⠻A  ⠻D  ⠀D  ⣷D  ⣷  ⣾Qǖ⢻5  ⠻   ⠀   ⠀   ⠀   ⠀   ⠀S  ⣼QƖ⡟  ⠛  ⣤A  ⠻  ⣴  ⣶  ⣧  ⣿  ⣿  ⣿  ⣿  ⣶  ⣶  ⣶  ⣦A  ⢇  ⠛Q  ⢿\  ⣆   ⠀   ⠀   ⠀S  ⣸Q  ⡟  ⣼  ⠟  ⣴  ⠀  ⠀  ⡿  ⠟  ⣬  ⣙  ⣫  ⣥  ⠻  ⠀  ⠀  ⣷  ⣷  ⠻  ⣧Q  ⢻5  ⢹   ⠀   ⠀U  ⠀  ⣺  ⡟  ⠀  ⠀  ⠀  ⠀  ⣾  ⣿  ⣿  ⣿  ⣿  ⣿  ⣿  ⣧  ⠀  ⠀  ⠀  ⣽  ⢻  ⣷S  ⣧   ⠀   ⠀U  ⠀  ⣧  ⡇  ⠀  ⠀  ⠀  ⠀  ⣶  ⣶  ⣶  ⣶  ⣶  ⣶  ⣶  ⣶  ⠀  ⠀  ⠀  ⠀  ⡇  ⣾S  ⡟   ⠀   ⠀5  ⣇  ⣟  ⣇  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⣼  ⡿5  ⣼   ⠀   ⠀   ⠀5  ⣆  ⣷  ⠻  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠏  ⣾1  ⣰   ⠀   ⠀   ⠀   ⠀   ⠀<  ⣦  ⢿  ⣦  ⢿  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⠀  ⡿  ⣴  ⠟1  ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀1  ⣶  ⠻  ⣷  ⣤  ⠛  ⠛  ⠿  ⠛  ⠿  ⠛  ⣤  ⠿  ⠛1  ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀5  ⣶1  ⣶1  ⣶1  ⣶1  ⣶1  ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀system/images/accountLogin.t2p 1450          ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀;⡿;⠿;⠛;⠛;⠛;⠛;⠛;⠛;⠿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀;⡿;⠛ ⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⣶;⠻;⢿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⣴ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀
⣴
⣶
⣶ ⠻ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀;⠻ ⠀ ⠀ ⠀ ⠀ ⠀ ⣼ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⣧⣿⣿⣿⣿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⣧ ⠀ ⠀ ⠀ ⣸ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠟
⣬
⣙
⣫
⣥ ⠻ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀;⢹ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀
⣾⣿⣿⣿⣿⣿⣿
⣧ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⣧ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⣶ ⣶ ⣶ ⣶ ⣶ ⣶ ⣶ ⣶ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⡟ ⠀ ⠀;⣇ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀;⣼ ⠀ ⠀ ⠀ ⠹ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠏ ⠀ ⠀ ⠀ ⠀ ⠀;⣦ ⢿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⡿;⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀;⣶ ⠻ ⢿ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠿ ⠛;⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀;⣶;⣶;⣶;⣶;⣶;⣾ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀ ⠀system/images/accountLogin.t3p 2026 3f         ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀7- ⡿7- ⠿7- ⠛7- ⠛7- ⠛7- ⠛7- ⠛7- ⠛7- ⠿   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀7- ⡿7- ⠛7- ⠁w--⠁ - ⣶ --⠁:  ⣷   ⣤:  ⠁   ⣶ --⣷w--⣷w--⣷7- ⠉7- ⠻72 ⢿   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀7- ⠋w--⠁ h-⠁   ⠁   ⠁ hd⣴   ⠁
i ⣴
i ⣶
i ⣶
d ⣄ d ⠉ dd⠛ hd⣤  h⣷ -h⣷w--⣦7- ⠻   ⠀   ⠀   ⠀   ⠀   ⠀7- ⠃{--⠁ ^^⠁ ^^⠁ _^⣷ d_⣷ _4⣶
_ ⠘  ⣿  ⣿  ⣿  ⣿ __⠁ ^_⣷ _/⣦ __⣷ ^^⣷ ^^⣷ --⣷7- ⠘   ⠀   ⠀   ⠀7- ⠇ .-⠃ ..⠃ ./⣾ ./⣶ //⠁ //⠁ ⠱
 ⣠
/ ⣬
4 ⣙
 ⣫
/ ⣥
 ⣄ ⣷ //⣷ //⣷ //⣶ ..⣧ ..⣆ ..⣷7- ⢹   ⠀   ⠀{.-⠇ ..⡇ ..⠁ /⣠ ⠋ ⣾ ⢅
 ⣾  ⣿  ⣿  ⣿  ⣿  ⣿  ⣿
 ⣧ ⢅ ⣷ ⣷ //⣷ ..⣷ ..⣇;. ⠘   ⠀   ⠀ .-⡇ ..⡇ /.⡇ ⠁ ⢴ ⠕ ⠑
 ⠉  ⣶
 ⠉
 ⠉
 ⠉  ⣶
 ⠉
 ⠉ ⠣ ⢡ ⡑ ⣄ ⢸ .⢸;. ⢠   ⠀   ⠀;. ⣇ ⣇ ⣇ ⣲ ⣶ ⡬ ⣊ ⢍ ⣸ ⣔ ⣩ ⣽ ⣮ ⠿ ⠯ ⢣ ⣆ ⡟ ⠋ ⣸ ⠇; ⣼   ⠀   ⠀   ⠀; ⣆ ⣧ ⠘ ⠛ ⣧ ⡿ ⠧ ⠟ ⣻ ⡛ ⢿ ⣃ ⠛ ⠛ ⠇ ⣻ ⣼ ⠃ ⠃; ⣰   ⠀   ⠀   ⠀   ⠀   ⠀7 ⣦ ⣷ ⣷ ⣗ ⣵ ⣥ ⠇ ⣝ ⣺ ⡾ ⢞ ⢳ ⣱ ⠁ ⠟ ⠁ ⠁; ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀; ⣶; ⣄ ⣷ ⣷ ⣷ ⣷ ⠁ ⡾ ⢩ ⠁ ⠁; ⣀; ⣤; ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀; ⣶; ⣶; ⣶; ⣶; ⣶; ⣾   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀   ⠀system/images/internet.t2p 1930 (                                                                                                                                                                                                                                                                
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
           
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                 
 
 
 
   
               
   
 
 
 
 
           
 
 
 
 
        
               
   
 
 
 
 
           
 
 
 
 
 
 
 
 
 
   
               
   
 
 
 
 
           
 
 
 
 
 
 
 
 
 
   
               
   
 
 
 
 
                       
               
   
 
 
 
 
           
 
 
 
 
 
 
 
 
 
   
               
   
 
 
 
 
           
 
 
 
 
 
 
 
 
 
   
               
   
 
 
 
 
                                        
 
 
 
 
 
           
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                                                                                                                                            system/images/noInternet.t2p 1930 (                                                                                                                                                                                                                                               
     
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 
 
 
 
 
 
           
 
 
 
    
 
 
 
 
 
 
 
 
 
 
 
 
 
 
     
 
 
 
 
 
 
 
 
                       
               
   
 
 
 
 
           
 
 
 
 
                       
   
 
 
 
 
           
 
 
 
 
 
 
 
 
 
   
               
   
 
 
 
 
           
 
 
 
 
 
 
 
 
 
                  
   
 
 
 
 
                       
               
   
 
 
 
 
           
 
 
 
    
 
 
   
               
   
 
 
 
 
           
 
   
 
 
 
 
 
   
                  
 
 
 
 
                                          
 
 
 
           
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
 
 
                                                                                                                                  system/images/switch_off.t2p 782                                                                                                                                                                                                                                                                                              ◖ ◗                                                                                                                                                                                                                    system/images/switch_on.t2p 782                                                                                                                                                                                                                                                                         S◖S◗                                                                                                                                                                                                                                    system/lib/advLabeling.lua 1236 local registry = require("registry")
local component = require("component")
local advLabeling = {}

function advLabeling.setLabel(address, label)
    local result = {pcall(component.invoke, address, "setLabel", label)}
    if not result[1] or type(result[2]) ~= "string" then --если например в tape_drive нет касеты, но установиться label самого tape_drive, а если есть касета то тогда label касеты установиться
        if not registry.advLabeling then registry.advLabeling = {} end
        registry.advLabeling[address] = label
        registry.save()
        return 2
    elseif result[1] then
        return 1
    end
end

function advLabeling.getLabel(address)
    local result = {pcall(component.invoke, address, "getLabel")}

    local label
    if result[1] and type(result[2]) == "string" then
        label = result[2]
    elseif registry.advLabeling and registry.advLabeling[address] then
        label = registry.advLabeling[address]
    end
    return label
end

function advLabeling.getNameTag(address)
    return address:sub(1, 8) .. "-" .. (advLabeling.getLabel(address) or "no label")
end

advLabeling.unloadable = true
return advLabelingsystem/lib/apps.lua 14327 local liked = require("liked")
local paths = require("paths")
local programs = require("programs")
local fs = require("filesystem")
local serialization = require("serialization")
local palette = require("palette")
local screensaver = require("screensaver")
local graphic = require("graphic")
local sysinit = require("sysinit")
local thread = require("thread")
local event = require("event")
local registry = require("registry")
local gui = require("gui")
local gui_container = require("gui_container")
local archiver = require("archiver")
local component = require("component")
local text = require("text")
local unicode = require("unicode")
local apps = {}

local installedInfo = registry.new("/data/installedInfo.dat")
local appsPath = "/data/apps/"
local vendorAppsPath = "/vendor/apps/"
local shadowPath = "/data/applicationsShadow/"

local function appList(folder)
    local list = {}
    for _, name in ipairs(fs.list(folder)) do
        local fullpath = paths.concat(folder, name)
        if fs.isDirectory(fullpath) then
            list[paths.name(name)] = true
        end
    end
    return list
end

local function createShadow(appName)
    fs.makeDirectory(paths.concat(shadowPath, appName))

    local function move(file)
        fs.copy(paths.concat(appsPath, appName, file), paths.concat(shadowPath, appName, file))
    end
    
    move("unreg.reg")
    move("formats.cfg")
    move("uninstall.lua")
end

local function doFormats(appPath, path, delete)
    local data = assert(serialization.load(path))

    if not registry.data.gui_container then registry.data.gui_container = {} end
    if not registry.data.gui_container.knownExps then registry.data.gui_container.knownExps = {} end
    if not registry.data.gui_container.typecolors then registry.data.gui_container.typecolors = {} end
    if not registry.data.gui_container.typenames then registry.data.gui_container.typenames = {} end
    if not registry.data.gui_container.editable then registry.data.gui_container.editable = {} end
    if not registry.data.gui_container.openVia then registry.data.gui_container.openVia = {} end
    if not registry.data.icons then registry.data.icons = {} end
    
    local function rmData(extension, key)
        registry.data.gui_container[key][extension] = nil
        gui_container[key][extension] = nil
    end

    for extension, formatInfo in pairs(data) do
        if delete then
            rmData(extension, "knownExps")
        else
            registry.data.gui_container.knownExps[extension] = true
        end

        if formatInfo.color and not delete then
            registry.data.gui_container.typecolors[extension] = formatInfo.color
        else
            rmData(extension, "typecolors")
        end

        if formatInfo.name and not delete then
            registry.data.gui_container.typenames[extension] = formatInfo.name
        else
            rmData(extension, "typenames")
        end

        if formatInfo.editable and not delete then
            registry.data.gui_container.editable[extension] = true
        else
            rmData(extension, "editable")
        end

        if formatInfo.program and not delete then
            registry.data.gui_container.openVia[extension] = paths.xconcat(appPath, formatInfo.program)
        else
            rmData(extension, "openVia")
        end

        if formatInfo.icon and not delete then
            registry.data.icons[extension] = paths.xconcat(appPath, formatInfo.icon)
        else
            registry.data.icons[extension] = nil
        end
    end

    registry.save()
    gui_container.refresh()
end

--------------------------------------------

function apps.load(name, screen, nickname, mainEnv, exitEnv)
    checkArg(1, name, "string")
    checkArg(2, screen, "string", "nil")
    checkArg(3, nickname, "string", "nil")

    local path = programs.find(name)
    if not path then
        return nil, "failed to launch application"
    end

    if not liked.isExecuteAvailable(path) then
        return nil, "application cannot be started"
    end

    local isMain = paths.name(path) == "main.lua"

    --------------------------------

    local exitFile = paths.concat(paths.path(path), "exit.lua")
    if not isMain or not fs.exists(exitFile) or fs.isDirectory(exitFile) then
        exitFile = nil
    end


    local paletteFile = paths.concat(paths.path(path), "palette.plt")
    if not isMain or not fs.exists(paletteFile) or fs.isDirectory(paletteFile) then
        paletteFile = nil
    end


    local configFile = paths.concat(paths.path(path), "config.cfg")
    if not isMain or not fs.exists(configFile) or fs.isDirectory(configFile) then
        configFile = nil
    end

    --------------------------------

    local mainCode, err = programs.load(path, nil, mainEnv)
    if not mainCode then return nil, err end

    local exitCode
    if exitFile then
        exitCode, err = programs.load(exitFile, nil, exitEnv)
        if not exitCode then return nil, err end
    end

    local configTbl = {}
    if configFile then
        configTbl, err = serialization.load(configFile)
        if not configTbl then return nil, err end

        if configTbl.palette then
            paletteFile = configTbl.palette
        end
    end

    local oldScreenSaverState
    local oldPrecise

    --------------------------------

    local function log(tbl)
        if not tbl[1] then
            event.errLog("application error: " .. tostring(tbl[2] or "unknown error"))
        end
        return tbl
    end

    local function appStart()
        if screen then
            if paletteFile then
                palette.fromFile(screen, paletteFile, configTbl.dontRegPalette)
            elseif configTbl.blackWhite then
                palette.blackWhite(screen, true)
            elseif configTbl.advancedColors then
                local depth = graphic.getDepth(screen)
                if depth == 4 then
                    palette.fromFile(screen, "/system/t2advanced.plt", true)
                elseif depth == 8 then
                    palette.blackWhite(screen, true)
                end
            end

            if configTbl.noScreenSaver then
                oldScreenSaverState = screensaver.isEnabled(screen)
                screensaver.setEnabled(screen, false)
            end

            if configTbl.res then
                graphic.setResolution(screen, table.unpack(configTbl.res))
            end

            if configTbl.precise ~= nil and graphic.getDeviceTier(screen) == 3 then
                oldPrecise = not not component.invoke(screen, "isPrecise")
                component.invoke(screen, "setPrecise", configTbl.precise)
            end
        end
    end

    local function appEnd()
        if screen then
            if configTbl.restoreGraphic then
                log{pcall(sysinit.initScreen, screen)}
            else
                if paletteFile or configTbl.restorePalette or configTbl.blackWhite or configTbl.advancedColors then
                    palette.system(screen)
                end

                if configTbl.restoreResolution or configTbl.res then
                    graphic.setResolution(screen, sysinit.getResolution(screen))
                end
            end

            if configTbl.noScreenSaver then
                screensaver.setEnabled(screen, oldScreenSaverState)
            end

            if oldPrecise ~= nil then
                component.invoke(screen, "setPrecise", oldPrecise)
            end
        end
    end

    return function (...)
        appStart()
        local result = log{thread.stub(mainCode, screen, nickname, ...)}
        appEnd()
        if exitCode then
            local result2 = log{thread.stub(exitCode, screen, nickname, ...)}
            if not result2[1] then
                if result[1] then
                    result[1] = false
                    result[2] = ""
                end
                result[2] = result[2] .. "; exit.lua err: " .. tostring(result2[2] or "unknown error")
            end
        end
        return table.unpack(result)
    end
end

function apps.execute(name, screen, nickname, ...)
    local code, err = apps.load(name, screen, nickname)
    if code then
        local programTh = thread.create(code, ...) --запуск программы в потоке чтобы созданые в ней потоки закрылись вместе с ней
        programTh.parentData.screen = screen
        programTh:resume()
        local ok = true
        local err, out
        while true do
            if programTh:status() == "dead" then
                if not programTh.out[1] then --если ошибка произошла в функции которую возврашяет apps.load (чего быть не должно)
                    ok, err = false, "osError: " .. (programTh.out[2] or "unknown error")
                elseif not programTh.out[2] then --если ошибка произошла в целевой программе
                    if programTh.out[3] then
                        ok, err = false, programTh.out[3]
                    end
                end
                out = {table.unpack(programTh.out, 2)}
                break
            end

            event.yield()
        end
        programTh:kill()

        if not ok then
            return nil, tostring(err or "unknown error")
        elseif out then
            return table.unpack(out)
        else
            return true
        end
    else
        return nil, tostring(err or "unknown error")
    end
end

function apps.executeWithWarn(name, screen, nickname, ...)
    local result = {apps.execute(name, screen, nickname, ...)}
    if screen and not result[1] then
        local clear = gui.saveBigZone(screen)
        gui.bigWarn(screen, nil, nil, tostring(result[2] or "unknown error"))
        clear()
    end
    return table.unpack(result)
end

function apps.postInstall(screen, nickname, path, version)
    local normalAppPath = text.startwith(unicode, path, appsPath)

    local function lassert(...)
        if screen then
            liked.assert(screen, ...)
        end
    end

    version = tostring(version or "unknown")
    local pname = paths.name(path)
    if installedInfo.data[pname] and installedInfo.data[pname] == version then
        return false
    end

    local regPath = paths.concat(path, "reg.reg")
    if fs.exists(regPath) then
        liked.applyReg(regPath)
    end

    local formatsPath = paths.concat(path, "formats.cfg")
    if fs.exists(formatsPath) then
        doFormats(path, formatsPath)
    end

    local installPath = paths.concat(path, "install.lua")
    if fs.exists(installPath) then
        lassert(apps.execute(installPath, screen, nickname))
    end

    local autorunPath = paths.concat(path, "autorun.lua")
    if fs.exists(autorunPath) then
        require("autorun").reg("system", autorunPath)
        lassert(apps.execute(autorunPath, screen, nickname))
    end

    if normalAppPath then
        createShadow(pname)
        installedInfo.data[pname] = version
        installedInfo.save()
    end

    registry.save()
    return true
end

function apps.uninstall(screen, nickname, path, hide)
    apps.check(screen, nickname)
    local pname = paths.name(path)

    local function lassert(...)
        if screen then
            liked.assert(screen, ...)
        end
    end
    
    local vendorApp = text.startwith(unicode, path, vendorAppsPath)
    if fs.get(path).address ~= fs.bootaddress then
        if screen then
            gui.warn(screen, nil, nil, "it is not possible to uninstall the application from another disk.\nuse the \"remove\" operation")
        end
        return
    elseif not text.startwith(unicode, path, appsPath) and not text.startwith(unicode, path, shadowPath) and not vendorApp then
        if screen then
            gui.warn(screen, nil, nil, "it is not possible to uninstall applications from here.\nuse the \"remove\" operation")
        end
        return
    elseif not hide and screen then
        gui.status(screen, nil, nil, "uninstalling \"" .. gui.hideExtension(screen, path) .. "\"...")
    end

    --------------------------------

    local unregPath = paths.concat(path, "unreg.reg")
    if fs.exists(unregPath) then
        liked.applyReg(unregPath)
    end

    local formatsPath = paths.concat(path, "formats.cfg")
    if fs.exists(formatsPath) then
        doFormats(path, formatsPath, true)
    end

    local autorunPath = paths.concat(path, "autorun.lua")
    if fs.exists(autorunPath) then
        require("autorun").reg("system", autorunPath, true)
    end

    local uninstallPath = paths.concat(path, "uninstall.lua")
    if fs.exists(uninstallPath) then
        lassert(apps.execute(uninstallPath, screen, nickname))
    end

    if vendorApp then
        fs.remove(path)
    else
        fs.remove(paths.concat(shadowPath, pname))
        fs.remove(paths.concat(appsPath, pname))
        installedInfo.data[pname] = nil
        installedInfo.save()
    end

    registry.save()
    return true
end

function apps.install(screen, nickname, path, hide)
    if not hide then
        local name = gui.hideExtension(screen, path)
        if not gui.yesno(screen, nil, nil, "Are you sure you want to install the \"" .. name .."\" package?") then return false, "cancel" end
        gui.status(screen, nil, nil, "installing \"" .. name .. "\"...")
    end

    local ok, err = archiver.unpack(path, "/data")
    if ok then
        apps.check(screen, nickname)
    end
    return ok, err
end

function apps.check(screen, nickname)
    if liked.recoveryMode then return end
    
    local installedApps = appList(appsPath)
    local shadowApps = appList(shadowPath)

    for name in pairs(installedApps) do
        if not shadowApps[name] then
            createShadow(name)
        end

        if not installedInfo.data[name] then
            apps.postInstall(screen, nickname, paths.concat(appsPath, name))
        end
    end

    for name in pairs(installedInfo.data) do
        if not installedApps[name] then
            local lpath = paths.concat(shadowPath, name)
            if fs.isDirectory(lpath) then
                apps.uninstall(screen, nickname, lpath)
            end
        end
    end
end

apps.unloadable = true
return appssystem/lib/autorun.lua 1409 local registry = require("registry")
local fs = require("filesystem")
local programs = require("programs")
local logs = require("logs")
local autorun = {}

function autorun.autorun()
    if registry.autorun then
        local function doAutorun(tbl)
            local needSave
            for i = #tbl, 1, -1 do
                local path = tbl[i]
                if path and fs.exists(path) then
                    logs.assert(programs.execute(path))
                else
                    table.clear(tbl, path)
                    needSave = true
                end
            end
            return needSave
        end

        local needSave
        if registry.autorun.system then
            needSave = doAutorun(registry.autorun.system)
        end
        if registry.autorun.user then
            if doAutorun(registry.autorun.user) then
                needSave = true
            end
        end
        if needSave then
            registry.save()
        end
    end
    autorun.autorun = nil
end

function autorun.reg(group, path, rm)
    if not registry.data.autorun then registry.data.autorun = {} end
    if not registry.data.autorun[group] then registry.data.autorun[group] = {} end
    table.clear(registry.data.autorun[group], path)
    if not rm then
        table.insert(registry.data.autorun[group], path)
    end
    registry.save()
end

autorun.unloadable = true
return autorunsystem/lib/calls.lua 5119 --ЛЮТАЯ ЛЕГАСИ ДИЧ, раньше была в ядре но я ее от туда еле как выкарчивал. надеюсь скоро смогу выпелить полностью

local fs = require("filesystem")
local unicode = require("unicode")
local paths = require("paths")
local bootloader = require("bootloader")

------------------------------------

local calls = {} --calls позваляет вызывать функции с жеского диска, что экономит оперативную память
calls.paths = {"/data/calls", "/vendor/calls", "/system/calls", "/system/core/calls"} --позиция по мере снижения приоритета(первый элемент это самый высокий приоритет)
calls.loaded = { --тут записаны функции которые раньше были hdd функциями, но стали перемешены в библиотеки
    map = math.map,
    constrain = math.clamp,

    deepclone = table.deepclone,

    getPath = function ()
        return require("system").getSelfScriptPath()
    end,
    getDeviceType = function ()
        return require("system").getDeviceType()
    end,

    getFile = fs.readFile,
    saveFile = fs.writeFile,

    serialization = function (...)
        return require("serialization").serialize(...)
    end,
    unserialization = function (...)
        return require("serialization").unserialize(...)
    end,

    uuid = function ()
        return require("uuid").next()
    end,
    sha256 = function (msg)
        return require("sha256").sha256(msg)
    end,

    getInternetFile = function (url)
        return require("internet").getInternetFile(url)
    end,

    createEnv = bootloader.createEnv,
    writebit = bit32.writebit,
    readbit = bit32.readbit,

    getGameTime = function ()
        local time = require("time")
        local gametime = time.getGameTime()
        return time.parseHours(gametime), time.parseMinute(gametime), time.parseSecond(gametime)
    end,
    getRawRealtime = function ()
        return require("time").getRealTime()
    end,
    getRealTime = function (timezone)
        local time = require("time")
        local realtime = time.addTimeZone(time.getRealTime(), timezone or 0)
        return time.parseHours(realtime), time.parseMinute(realtime), time.parseSecond(realtime)
    end,

    split = function (str, sep)
        return require("parser").split(string, str, sep)
    end,
    split2 = function (tool, str, seps)
        return require("parser").split(tool, str, seps)
    end,
    toParts = function (str, max)
        return require("parser").toParts(string, str, max)
    end,
    toPartsUnicode = function (str, max)
        return require("parser").toParts(unicode, str, max)
    end,

    isLikeOsDisk = function (address)
        return require("system").isLikeOSDisk(address)
    end,

    screenshot = function (screen, x, y, sx, sy)
        return require("graphic").screenshot(screen, x, y, sx, sy)
    end,

    gui_filepicker = function (screen, cx, cy, dir, exp, save, dirmode, dircombine, defname)
        local iowindows = require("iowindows")
        if dirmode then
            if save then
                return iowindows.savefolder(screen, exp)
            else
                return iowindows.selectfolder(screen, exp)
            end
        else
            if save then
                return iowindows.savefile(screen, exp)
            else
                return iowindows.selectfile(screen, exp)
            end
        end
    end
} --вы можете записать сюда функции которые не должны выгружаться
calls.cache = {}

function calls.find(name)
    if unicode.sub(name, 1, 1) == "/" then
        return name
    else
        for i, v in ipairs(calls.paths) do
            local path = paths.concat(v, name .. ".lua")
            if fs.exists(path) then
                return path
            end
        end
    end
end

function calls.load(name)
    if calls.loaded[name] or calls.cache[name] then
        local lib = calls.loaded[name] or calls.cache[name]
        if lib then
            if lib == true then
                return
            end
            return lib
        end
    end

    local path = calls.find(name)
    if not path then
        calls.cache[name] = true
        return nil, "no such call"
    end

    local file, err = fs.open(path, "rb")
    if not file then return nil, err end
    local data = file.readAll()
    file.close()

    local code, err = load(data, "=" .. path, nil, _G) --не _ENV потому что там "личьные" глобалы в _G то что нужно системным вызовам
    if not code then return nil, err end

    calls.cache[name] = code
    return code
end

function calls.call(name, ...)
    local code = calls.load(name)
    if not code then
        error("call \"" .. name .. "\" not found", 2)
    end
    return code(...)
end

setmetatable(_G, {__index = function(self, key)
    return calls.load(key)
end})

return callssystem/lib/format.lua 1663 local unicode = require("unicode")
local graphic = require("graphic")
local colorlib = require("colors")
local text = require("text")
local format = {}

function format.smartConcat()
    local smart = {}
    smart.buff = {}
    smart.idx = 0

    function smart.add(x, text, reverse)
        if reverse then
            x = x - (unicode.len(text) - 1)
        end

        local len = unicode.len(text)
        local last = x + (len - 1)
        local index = 1
        for i = x, last do
            smart.buff[i] = unicode.sub(text, index, index)
            index = index + 1
        end
        if last > smart.idx then
            smart.idx = last
        end
    end

    function smart.makeSize(size)
        smart.idx = size
    end

    function smart.get()
        for i = 1, smart.idx do
            if not smart.buff[i] then
                smart.buff[i] = " "
            end
        end
        return table.concat(smart.buff)
    end

    return smart
end

function format.visionProtectionConvert(color)
    local r, g, b = colorlib.unBlend(color)
    return colorlib.blend(r * 0.8, g * 0.7, b * 0.3)
end

------ legacy

format.escape_pattern = text.escapePattern

function format.raw_objectPos(rx, ry, sx, sy, offsetX, offsetY)
    local cx, cy = math.round(rx / 2), math.round(ry / 2)
    local px, py = cx - math.round(sx / 2), cy - math.round(sy / 2)
    return math.round(px + offsetX) + 1, math.round(py + offsetY) + 1
end

function format.objectPos(screen, sx, sy, offsetX, offsetY)
    local rx, ry = graphic.getResolution(screen)
    return format.raw_objectPos(rx, ry, sx, sy, offsetX, offsetY)
end

format.unloadable = true
return formatsystem/lib/gobjs.lua 3695 local uix = require("uix")
local parser = require("parser")
local unicode = require("unicode")
local graphic = require("graphic")
local gobjs = {}

-------------------------------- scroll text

gobjs.scrolltext = {}

function gobjs.scrolltext:onCreate(sizeX, sizeY, text)
    self.sizeX = sizeX
    self.sizeY = sizeY
    self.text = text or ""
    self.scroll = 0
    self.w = self.gui.window

    self.bg = uix.colors.white
    self.fg = uix.colors.gray
    self.padding = true
    self.scrollBar = false
end

function gobjs.scrolltext:onEvent(eventData)
    eventData = uix.objEvent(self, eventData)
    if eventData and eventData[1] == "scroll" then
        self:reLines()
        local max = #self.lines

        local oldScroll = self.scroll
        self.scroll = self.scroll - eventData[5]
        if self.scroll < 0 then self.scroll = 0 end
        if self.scroll >= max then self.scroll = max - 1 end
        if self.scroll ~= oldScroll then
            self:draw()
        end
    end
end

function gobjs.scrolltext:onDraw()
    self:reLines()
    self.w:fill(self.x, self.y, self.sizeX, self.sizeY, self.bg, 0, " ")
    for i, str in ipairs(self.lines) do
        local linePos = (self.y + (i - 1)) - self.scroll
        local minLinePos = self.y
        local maxLinePos = self.y + self.sizeY
        if self.padding then
            maxLinePos = maxLinePos - 1
            minLinePos = minLinePos + 1
            linePos = linePos + 1
        end
        if linePos >= minLinePos and linePos < maxLinePos then
            local maxSize = self.sizeX
            if self.padding then
                maxSize = maxSize - 2
            end
            str = unicode.sub(str, 1, maxSize)
            
            local linePosX = self.x
            if self.padding then
                linePosX = linePosX + 1
            end
            self.w:set(linePosX, linePos, self.bg, self.fg, str)
        end
    end
end



function gobjs.scrolltext:reLines()
    self.lines = self.lines or parser.split(unicode, self.text, "\n")
end

function gobjs.scrolltext:setText(text)
    self.scroll = 0
    self.text = text
    self.lines = nil
end

-------------------------------- layout manager

gobjs.manager = {}

function gobjs.manager:onCreate(sizeX, sizeY)
    self.sizeX = sizeX
    self.sizeY = sizeY
    self.screen = self.gui.window.screen
    self.current = nil
end

function gobjs.manager:onDraw()
    if self.current then
        self.current:draw()
    end
end

function gobjs.manager:onEvent(eventData)
    if self.current then
        self.current:uploadEvent(eventData)
    end
end



function gobjs.manager:fullStop()
    if self.current then
        self.current:fullStop()
    end
end

function gobjs.manager:fullStart()
    if self.current then
        self.current:fullStart()
    end
end

function gobjs.manager:select(layout)
    if self.current then
        self.current:fullStop()
    end

    self.current = layout
    if self.current then
        self.current.smartGuiManager = self
        self.current.allowAutoActive = nil
        self.current:fullStart()
        if self.current.onSelect then
            self.current:onSelect()
        end
        self.current:draw()
    end
end

function gobjs.manager:create(bgcolor, style)
    local window = graphic.create(self.screen, self.x, self.y, self.sizeX, self.sizeY)
    local layout = uix.createSimpleLayout(window, bgcolor, style)
    layout.bgWork = false
    layout.allowAutoActive = nil
    if not self.current then
        self:select(layout)
    end
    return layout
end

function gobjs.manager:size()
    return self.sizeX, self.sizeY
end

--------------------------------

gobjs.unloadable = true
return gobjssystem/lib/gui.lua 53033 local gui_container = require("gui_container")
local registry = require("registry")
local colorslib = require("colors")
local colors = gui_container.colors
local calls = require("calls")
local graphic = require("graphic")
local event = require("event")
local computer = require("computer")
local unicode = require("unicode")
local component = require("component")
local thread = require("thread")
local paths = require("paths")
local system = require("system")
local sound = require("sound")
local fs = require("filesystem")
local programs = require("programs")
local clipboard = require("clipboard")
local parser = require("parser")
local lastinfo = require("lastinfo")
local gui = {colors = colors}
gui.blackMode = false
gui.smartShadowsColors = {
    colorslib.lightGray, --1)  white
    colorslib.brown,     --2)  orange
    colorslib.purple,    --3)  magenta
    colorslib.cyan,      --4)  lightBlue
    colorslib.orange,    --5)  yellow
    colorslib.green,     --6)  lime
    colorslib.magenta,   --7)  pink
    colorslib.black,     --8)  gray
    colorslib.gray,      --9)  lightGray
    colorslib.blue,      --10) cyan
    colorslib.blue,      --11) purple
    colorslib.brown,     --12) blue
    colorslib.black,     --13) brown
    colorslib.gray,      --14) green
    colorslib.brown,     --15) red
    colorslib.gray       --16) black
}

function gui.hideExtension(screen, path)
    local name = paths.name(path)
    if gui_container.viewFileExps[screen] then
        return name
    else
        return paths.hideExtension(name)
    end
end

function gui.hideExtensionPath(screen, path)
    if gui_container.viewFileExps[screen] then
        return path
    else
        return paths.hideExtension(path)
    end
end

function gui.fpath(screen, path)
    return gui.hideExtensionPath(screen, gui_container.toUserPath(screen, path))
end

function gui.isVisible(screen, path)
    return gui_container.hiddenFiles[screen] or not fs.getAttribute(path, "hidden")
end

------------------------------------

local shot = graphic.screenshot
function graphic.screenshot(screen, x, y, sx, sy)
    local rx, ry = graphic.getResolution(screen)
    x = x or 1
    y = y or 1
    sx = sx or rx
    sy = sy or ry
    if x and sx and y and sy and screen then
        if registry.shadowMode == "round" then
            x = x - 2
            y = y - 1
            sx = sx + 2
            sy = sy + 1
        elseif registry.shadowMode == "screen" then
            x = 1
            y = 1
            sx = rx
            sy = ry
        end
    end
    if x < 1 then x = 1 end
    if y < 1 then y = 1 end
    return shot(screen, x, y, sx, sy)
end

------------------------------------

gui.zoneX = 32
gui.zoneY = 8

gui.bigZoneX = 50
gui.bigZoneY = 16

gui.veryBigZoneX = 60
gui.veryBigZoneY = 18

gui.scrShadow = {}

function gui.hideScreen(screen)
    pcall(component.invoke, screen, "turnOff")    
    return function ()
        pcall(component.invoke, screen, "turnOn")
    end
end

function gui.bwSize(screen)
    local rx, ry = graphic.getResolution(screen)
    if rx <= 50 then
        return 50, 16
    else
        return 60, 18
    end
end

function gui.getZone(screen)
    local cx, cy = graphic.getResolution(screen)
    cx = cx / 2
    cy = cy / 2
    cx = cx - 16
    cy = cy - 4
    cx = math.round(cx) + 1
    cy = math.round(cy) + 1
    return cx, cy, 34, 9
end

function gui.getBigZone(screen)
    local cx, cy = graphic.getResolution(screen)
    cx = cx / 2
    cy = cy / 2
    cx = cx - 25
    cy = cy - 8
    cx = math.round(cx) + 1
    cy = math.round(cy) + 1
    return cx, cy, 52, 17
end

function gui.getCustomZone(screen, sx, sy)
    local cx, cy = graphic.getResolution(screen)
    cx = cx / 2
    cy = cy / 2
    cx = cx - math.round(sx / 2)
    cy = cy - math.round(sy / 2)
    cx = math.round(cx) + 1
    cy = math.round(cy) + 1
    return cx, cy, sx + 2, sy + 1
end

function gui.saveZone(screen)
    return graphic.screenshot(screen, gui.getZone(screen))
end

function gui.saveBigZone(screen)
    local bwSizeX, bwSizeY = gui.bwSize(screen)
    return graphic.screenshot(screen, gui.getCustomZone(screen, bwSizeX, bwSizeY))
end

------------------------------------

function gui.shadow(screen, x, y, sx, sy, mul, full, noSaveShadowState)
    if gui.skipShadow then
        gui.skipShadow = nil
        return
    end

    local gpu
    if type(screen) == "table" then
        gpu = screen
        screen = gpu.getScreen()
    else
        gpu = graphic.findGpu(screen)
    end
    local depth = graphic.getDepth(screen)

    mul = mul or 0.4
    local scr
    if not full and registry.shadowMode == "screen" then
        local rx, ry = gpu.getResolution()
        x = 1
        y = 1
        sx = rx
        sy = ry
        full = true

        if not noSaveShadowState then
            scr = true
            gui.scrShadow[screen] = (gui.scrShadow[screen] or 0) + 1
        end
    end

    local function getPoses()
        local shadowPosesX = {}
        local shadowPosesY = {}

        if full then
            for cx = x, x + (sx - 1) do
                for cy = y, y + (sy - 1) do
                    table.insert(shadowPosesX, cx)
                    table.insert(shadowPosesY, cy)
                end
            end
        else
            if registry.shadowMode == "round" then
                for i = x, (x + sx) - 1 do
                    table.insert(shadowPosesX, i)
                    table.insert(shadowPosesY, y - 1)
                end
                for i = x, (x + sx) - 1 do
                    table.insert(shadowPosesX, i)
                    table.insert(shadowPosesY, y + sy)
                end
                for i = y - 1, y + sy do
                    table.insert(shadowPosesX, x - 1)
                    table.insert(shadowPosesY, i)

                    table.insert(shadowPosesX, x - 2)
                    table.insert(shadowPosesY, i)

                    table.insert(shadowPosesX, x + sx)
                    table.insert(shadowPosesY, i)

                    table.insert(shadowPosesX, x + sx + 1)
                    table.insert(shadowPosesY, i)
                end
            else
                for i = x + 1, (x + sx) - 1 do
                    table.insert(shadowPosesX, i)
                    table.insert(shadowPosesY, y + sy)
                end
                for i = y + 1, y + sy do
                    table.insert(shadowPosesX, x + sx)
                    table.insert(shadowPosesY, i)
    
                    if registry.shadowMode == "full" then
                        table.insert(shadowPosesX, x + sx + 1)
                        table.insert(shadowPosesY, i)
                    end
                end
            end
        end

        return shadowPosesX, shadowPosesY
    end

    local origsX = {}
    local origsY = {}
    local origsC = {}
    local origsF = {}
    local origsB = {}
    if not require("liked").recoveryMode then
        if registry.shadowType == "advanced" then
            local shadowPosesX, shadowPosesY = getPoses()

            for i = 1, #shadowPosesX do
                local ok, char, fore, back = pcall(gpu.get, shadowPosesX[i], shadowPosesY[i])
                if ok and char and fore and back then
                    table.insert(origsX, shadowPosesX[i])
                    table.insert(origsY, shadowPosesY[i])
                    table.insert(origsC, char)
                    table.insert(origsF, fore)
                    table.insert(origsB, back)

                    gpu.setForeground(colorslib.colorMul(fore, mul))
                    gpu.setBackground(colorslib.colorMul(back, mul))
                    gpu.set(shadowPosesX[i], shadowPosesY[i], char)
                end
            end
        elseif registry.shadowType == "smart" then
            if depth > 1 then
                local shadowPosesX, shadowPosesY = getPoses()

                local function getPalCol(source)
                    for i = 0, 15 do
                        if gui_container.indexsColors[i + 1] == source then
                            return i
                        end
                    end
                end

                for i = 1, #shadowPosesX do
                    local ok, char, fore, back = pcall(gpu.get, shadowPosesX[i], shadowPosesY[i])
                    if ok and char and fore and back then
                        table.insert(origsX, shadowPosesX[i])
                        table.insert(origsY, shadowPosesY[i])
                        table.insert(origsC, char)
                        table.insert(origsF, fore)
                        table.insert(origsB, back)

                        local forePal = getPalCol(fore)
                        if forePal then
                            gpu.setForeground(gui_container.indexsColors[gui.smartShadowsColors[forePal + 1] + 1])
                        else
                            gpu.setForeground(colorslib.colorMul(fore, mul))
                        end
                        
                        local backPal = getPalCol(back)
                        if backPal then
                            gpu.setBackground(gui_container.indexsColors[gui.smartShadowsColors[backPal + 1] + 1])
                        else
                            gpu.setBackground(colorslib.colorMul(back, mul))
                        end

                        gpu.set(shadowPosesX[i], shadowPosesY[i], char)
                    end
                end
            end
        elseif registry.shadowType == "simple" then
            local shadowPosesX, shadowPosesY = getPoses()
            for i = 1, #shadowPosesX do
                local ok, char, fore, back, forePal, backPal = pcall(gpu.get, shadowPosesX[i], shadowPosesY[i])
                if ok and char and fore and back then
                    table.insert(origsX, shadowPosesX[i])
                    table.insert(origsY, shadowPosesY[i])
                    table.insert(origsC, char)
                    table.insert(origsF, fore)
                    table.insert(origsB, back)
                end
            end

            gpu.setBackground(colors.gray)
            if full then
                gpu.fill(x, y, sx, sy, " ")
            else
                if registry.shadowMode == "compact" then
                    gpu.fill(x + 1, y + 1, sx, sy, " ")
                elseif registry.shadowMode == "full" then
                    gpu.fill(x + 1, y + 1, sx + 1, sy, " ")
                elseif registry.shadowMode == "round" then
                    gpu.fill(x - 2, y - 1, sx + 4, sy + 2, " ")
                end
            end
        end
    end

    return function ()
        if scr then
            gui.scrShadow[screen] = gui.scrShadow[screen] - 1
        end

        local gpu = graphic.findGpu(screen)
        for i, x in ipairs(origsX) do
            gpu.setForeground(origsF[i])
            gpu.setBackground(origsB[i])
            gpu.set(x, origsY[i], origsC[i])
        end
    end
end

function gui.pleaseType(screen, str, tostr)
    tostr = tostr or "confirm"
    while true do
        local input = gui.input(screen, nil, nil, "TYPE '" .. str .. "' TO " .. tostr:upper())
        if input then
            if input == str then
                return true
            else
                gui.warn(screen, nil, nil, "to " .. tostr .. ", you need to type '" .. str .. "'")
            end
        else
            return false
        end
    end
end

function gui.smallWindow(screen, cx, cy, str, backgroundColor, icon, sx, sy, noSaveShadowState)
    sx = sx or 32
    sy = sy or 8

    if not cx or not cy then
        cx, cy = gui.getCustomZone(screen, sx, sy)
    end

    local window = graphic.createWindow(screen, cx, cy, sx, sy, true)

    local color = backgroundColor or colors.lightGray

    --window:fill(2, 2, window.sizeX, window.sizeY, colors.gray, 0, " ")
    local noShadow = gui.shadow(screen, window.x, window.y, window.sizeX, window.sizeY, nil, nil, noSaveShadowState)
    window:clear(color)

    local textColor = colors.white
    if color == textColor then
        textColor = colors.black
    end
    if str then
        for i, v in ipairs(parser.parseTraceback(str, sx - 9, sy - 3)) do
            window:set(8, i + 1, color, textColor, v)
        end
    end

    if icon then
        icon(window, color)
    end

    return window, noShadow
end

function gui.customWindow(screen, sx, sy)
    sx = sx or 50
    sy = sy or 16

    local cx, cy = gui.getCustomZone(screen, sx, sy)
    local clear = graphic.screenshot(screen, cx, cy, sx, sy)
    local window = graphic.createWindow(screen, cx, cy, sx, sy, true)
    gui.shadow(screen, cx, cy, sx, sy)

    return window, clear
end

function gui.status(screen, cx, cy, str, backgroundColor)
    gui.smallWindow(screen, cx, cy, str, backgroundColor or colors.lightGray, function (window, color)
        window:set(2, 1, color, colors.blue, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.blue, " ◢█◣ ")
        window:set(2, 3, color, colors.blue, "◢███◣")
        window:set(4, 2, colors.blue, colors.white, "P")
    end, nil, nil, true)
    graphic.forceUpdate(screen)
    event.yield()
end

function gui.warn(screen, cx, cy, str, backgroundColor)
    local window, noShadow = gui.smallWindow(screen, cx, cy, str, backgroundColor, function (window, color)
        window:set(2, 1, color, colors.orange, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.orange, " ◢█◣ ")
        window:set(2, 3, color, colors.orange, "◢███◣")
        window:set(4, 2, colors.orange, colors.white, "!")
    end)

    window:set(32 - 4, 7, colors.lightBlue, colors.white, " OK ")
    local function drawYes()
        window:set(32 - 4, 7, colors.blue, colors.white, " OK ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        sound.warn()
    end

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (32 - 5) and windowEventData[3] <= ((32 - 5) + 4) then
                drawYes()
                break
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            break
        end
    end
    noShadow()
end

function gui.done(screen, cx, cy, str, backgroundColor)
    local window, noShadow = gui.smallWindow(screen, cx, cy, str, backgroundColor, function (window, color)
        window:set(2, 1, color, colors.green, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.green, " ◢█◣ ")
        window:set(2, 3, color, colors.green, "◢███◣")
        window:set(4, 2, colors.green, colors.white, "~")
    end)

    window:set(32 - 4, 7, colors.lightBlue, colors.white, " OK ")
    local function drawYes()
        window:set(32 - 4, 7, colors.blue, colors.white, " OK ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        sound.done()
    end

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (32 - 5) and windowEventData[3] <= ((32 - 5) + 4) then
                drawYes()
                break
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            break
        end
    end
    noShadow()
end

function gui.bigWarn(screen, cx, cy, str, backgroundColor)
    local bwSizeX, bwSizeY = gui.bwSize(screen)

    local window, noShadow = gui.smallWindow(screen, cx, cy, str, backgroundColor, function (window, color)
        window:set(2, 1, color, colors.orange, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.orange, " ◢█◣ ")
        window:set(2, 3, color, colors.orange, "◢███◣")
        window:set(4, 2, colors.orange, colors.white, "!")
    end, bwSizeX, bwSizeY)

    window:set(bwSizeX - 4, bwSizeY - 1, colors.lightBlue, colors.white, " OK ")
    local function drawYes()
        window:set(bwSizeX - 4, bwSizeY - 1, colors.blue, colors.white, " OK ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        sound.warn()
    end

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == (bwSizeY - 1) and windowEventData[3] > (bwSizeX - 5) and windowEventData[3] <= ((bwSizeX - 5) + 4) then
                drawYes()
                break
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            break
        end
    end
    noShadow()
end

function gui.pleaseCharge(screen, minCharge, str)
    minCharge = minCharge or 40
    str = str or "this action"

    if system.getCharge() >= minCharge then return true end

    local clear = gui.saveZone(screen)

    local window = gui.smallWindow(screen, nil, nil, "in order to make " .. str .. ",\nthe charge level of the device must be at least " .. tostring(math.floor(minCharge)) .. "%", nil, function (window, color)
        window:set(2, 1, color, colors.red, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.red, " ◢█◣ ")
        window:set(2, 3, color, colors.red, "◢███◣")
        window:set(4, 2, colors.red, colors.white, "!")
    end)

    window:set(32 - 4, 7, colors.lightBlue, colors.white, " OK ")
    local function drawYes()
        window:set(32 - 4, 7, colors.blue, colors.white, " OK ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        sound.warn()
    end

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (32 - 5) and windowEventData[3] <= ((32 - 5) + 4) then
                drawYes()
                clear()
                return false
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            clear()
            return false
        end
    end
end

function gui.pleaseSpace(screen, minSpace, str)
    minSpace = minSpace or 64
    str = str or "this action"

    local root = fs.get("/")
    if (root.spaceTotal() - root.spaceUsed()) >= minSpace then return true end

    local clear = gui.saveZone(screen)

    local window = gui.smallWindow(screen, nil, nil, "in order to make " .. str .. ",\nyou need a minimum " .. tostring(math.floor(minSpace)) .. "KB space", nil, function (window, color)
        window:set(2, 1, color, colors.red, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.red, " ◢█◣ ")
        window:set(2, 3, color, colors.red, "◢███◣")
        window:set(4, 2, colors.red, colors.white, "!")
    end)

    window:set(32 - 4, 7, colors.lightBlue, colors.white, " OK ")
    local function drawYes()
        window:set(32 - 4, 7, colors.blue, colors.white, " OK ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        sound.warn()
    end

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (32 - 5) and windowEventData[3] <= ((32 - 5) + 4) then
                drawYes()
                clear()
                return false
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            clear()
            return false
        end
    end
end

function gui.selectcolor(screen, cx, cy, str)
    --◢▲◣▲▴▴
    local gpu = graphic.findGpu(screen)

    if not cx or not cy then
        cx, cy = gpu.getResolution()
        cx = cx / 2
        cy = cy / 2
        cx = cx - 12
        cy = cy - 6
        cx = math.round(cx) + 1
        cy = math.round(cy) + 1
    end

    local window = graphic.createWindow(screen, cx, cy, 24, 12, true)
    local noShadow = gui.shadow(screen, window.x, window.y, window.sizeX, window.sizeY)
    window:clear(colors.gray)
    window:fill(3, 2, 20, 10, colors.brown, colors.white, "▒")
    window:set(2, 1, colors.gray, colors.white, str or "select color")
    window:set(window.sizeX, 1, colors.red, colors.white, "X")

    local cols = {}
    for i = 1, 12 do
        cols[i] = {}
    end
    for x = 0, 3 do
        for y = 0, 3 do
            local colNum = x + (y * 4)
            local col = colors[colorslib[colNum]]
            local setX, setY = 5 + (x * 4), 3 + (y * 2)
            window:set(setX, setY, col, 0, "    ")
            window:set(setX, setY + 1, col, 0, "    ")
            for addY = 0, 1 do
                for addX = 0, 3 do
                    cols[setY + addY][setX + addX] = colNum
                end
            end
        end
    end
    graphic.forceUpdate(screen)

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" then
            if windowEventData[3] == window.sizeX and windowEventData[4] == 1 then
                noShadow()
                return
            elseif cols[windowEventData[4]] and cols[windowEventData[4]][windowEventData[3]] then
                noShadow()
                return cols[windowEventData[4]][windowEventData[3]]
            end
        end
    end
end

function gui.selectfullcolor(screen, cx, cy, str)
    local col = gui.selectcolor(screen, cx, cy, str)
    if col and colorslib[col] and colors[colorslib[col]] then
        return colors[colorslib[col]]
    end
end

function gui.input(screen, cx, cy, str, hidden, backgroundColor, default, disableStartSound, noCancel)
    local gpu = graphic.findGpu(screen)

    if not cx or not cy then
        cx, cy = gui.getZone(screen)
    end

    local window = graphic.createWindow(screen, cx, cy, 32, 8, true)

    --window:fill(2, 2, window.sizeX, window.sizeY, colors.gray, 0, " ")
    local noShadow = gui.shadow(screen, window.x, window.y, window.sizeX, window.sizeY)
    window:clear(backgroundColor or colors.lightGray)

    local pos = math.round((window.sizeX / 2) - (unicode.wlen(str) / 2)) + 1
    window:fill(1, 1, window.sizeX, 1, colors.gray, 0, " ")
    window:set(pos, 1, colors.gray, colors.white, str)

    window:set(32 - 4 - 3, 7, colors.lightBlue, colors.white, " enter ")
    if not noCancel then
        window:set(2, 7, colors.red, colors.white, " cancel ")
    end

    local reader = window:read(2, 3, window.sizeX - 2, colors.gray, colors.white, nil, hidden, default)

    graphic.forceUpdate(screen)
    if registry.soundEnable and not disableStartSound then
        sound.input()
    end

    local function drawOk()
        window:set(32 - 4 - 3, 7, colors.blue, colors.white, " enter ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    local function drawCancel()
        window:set(2, 7, colors.brown, colors.white, " cancel ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    while true do
        local eventData = {event.pull()}
        local windowEventData = window:uploadEvent(eventData)
        local out = reader.uploadEvent(eventData)
        if out then
            if out == true then
                if not noCancel then
                    drawCancel()
                    noShadow()
                    return false
                end
            else
                drawOk()
                noShadow()
                return out
            end
        end

        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (32 - 5 - 3) and windowEventData[3] <= ((32 - 5) + 4) then
                drawOk()
                noShadow()
                return reader.getBuffer()
            elseif windowEventData[4] == 7 and windowEventData[3] >= 2 and windowEventData[3] <= (2 + 7) then
                if not noCancel then
                    drawCancel()
                    noShadow()
                    return false
                end
            end
        end
    end
end

function gui.contextPos(screen, posX, posY, strs)
    local gpu = graphic.findGpu(screen)
    local rx, ry = gpu.getResolution()
    local drawStrs = gui.contextStrs(strs)

    local sizeX, sizeY = 0, #drawStrs
    for i, v in ipairs(drawStrs) do
        if type(v) == "string" and unicode.wlen(v) > sizeX then
            sizeX = unicode.wlen(v)
        end
    end
    sizeX = sizeX + 1
    while posX + (sizeX - 1) > rx do
        posX = posX - 1
    end
    while posY + (sizeY - 1) > ry do
        posY = posY - 1
    end

    return posX, posY, sizeX, sizeY
end

function gui.contextStrs(strs)
    local drawStrs = {}
    for index, value in ipairs(strs) do
        if type(value) == "string" then
            if value:sub(1, 2) ~= "  " then
                drawStrs[index] = "  " .. value
            else
                drawStrs[index] = value
            end
        else
            drawStrs[index] = value
        end
    end
    return drawStrs
end

function gui.blackCall(func, ...)
    local oldBlackState = gui.blackMode
    gui.blackMode = true
    func(...)
    gui.blackMode = oldBlackState
end

function gui.context(screen, posX, posY, strs, active, disShadow)
    local white, black = colors.white, colors.black
    if gui.blackMode then
        white, black = black, white
    end

    local gpu = graphic.findGpu(screen)
    local drawStrs = gui.contextStrs(strs)
    local posX, posY, sizeX, sizeY = gui.contextPos(screen, posX, posY, drawStrs)
    local sep = string.rep(gui_container.chars.splitLine, sizeX)

    local window = graphic.createWindow(screen, posX, posY, sizeX, sizeY)
    --window:fill(2, 2, window.sizeX, window.sizeY, colors.gray, 0, " ")
    local clearShadow
    if not disShadow then
        clearShadow = gui.shadow(screen, window.x, window.y, window.sizeX, window.sizeY)
    end

    local function redrawStrs(selected)
        for i, str in ipairs(drawStrs) do
            local isSep
            if str == true then
                isSep = true
                str = sep
            end

            local color = white
            local color2 = black
            if (not active or active[i]) and not isSep then
                if selected == i then
                    color = colors.blue
                    color2 = colors.white
                end
                window:set(1, i, color, color2, str .. (string.rep(" ", sizeX - unicode.wlen(str))))
            else
                window:set(1, i, color, colors.lightGray, str .. (string.rep(" ", sizeX - unicode.wlen(str))))
            end
        end
        graphic.forceUpdate(screen)
    end
    redrawStrs()

    local selectedNum
    while true do
        local eventData = {computer.pullSignal()}
        if eventData[2] == screen then
            local windowEventData = window:uploadEvent(eventData)
            if windowEventData[1] == "drop" and windowEventData[5] == 0 then
                local num = windowEventData[4]
                if not active or active[num] then
                    event.sleep(0.05)
                    if clearShadow then clearShadow() end
                    return strs[num], num
                end
            elseif (windowEventData[1] == "touch" or windowEventData[1] == "drag") and windowEventData[5] == 0 then
                if windowEventData[1] == "touch" and selectedNum and selectedNum == windowEventData[4] then
                    if not active or active[selectedNum] then
                        event.sleep(0.05)
                        if clearShadow then clearShadow() end
                        return strs[selectedNum], selectedNum
                    end
                end
                redrawStrs(windowEventData[4])
                selectedNum = windowEventData[4]
            elseif eventData[1] == "drag" then
                selectedNum = nil
                redrawStrs()
            elseif eventData[1] == "touch" or eventData[1] == "scroll" then
                event.push(table.unpack(eventData))
                if clearShadow then clearShadow() end
                return nil, nil
            end
        end
    end
end

function gui.contextAuto(screen, posX, posY, strs, active)
    local posX, posY, sizeX, sizeY = gui.contextPos(screen, posX, posY, strs)
    local clear = graphic.screenshot(screen, posX, posY, sizeX + 2, sizeY + 1)
    local result = {gui.context(screen, posX, posY, strs, active)}
    clear()
    return table.unpack(result)
end

function gui.contextFunc(screen, posX, posY, strs, active, funcs)
    local posX, posY, sizeX, sizeY = gui.contextPos(screen, posX, posY, strs)
    local clear = graphic.screenshot(screen, posX, posY, sizeX + 2, sizeY + 1)
    local _, num = gui.context(screen, posX, posY, strs, active)
    clear()
    if num and funcs and funcs[num] then
        funcs[num]()
    end
end

function gui.drawtext(screen, posX, posY, foreground, text)
    local gpu = graphic.findGpu(screen)

    ------------------------------------

    gpu.setForeground(foreground)

    local buff = ""
    local oldBack, oldI
    for i = 1, unicode.wlen(text) do
        local ok, char, fore, back = pcall(gpu.get, posX + (i - 1), posY)
        if ok then
            oldI = oldI or i
            oldBack = oldBack or back
            if back ~= oldBack then
                gpu.setBackground(oldBack)
                gpu.set(posX + (oldI - 1), posY, buff)

                buff = ""
                oldBack = back
                oldI = i
            end
            buff = buff .. unicode.sub(text, i, i)
        end
    end

    if oldBack then
        gpu.setBackground(oldBack)
        gpu.set(posX + (oldI - 1), posY, buff)
    end
end

function gui.select(screen, cx, cy, label, actions, scroll, noCloseButton, overlay, windowEventCallback, noCleanShadow, disableShadow, alwaysConfirm)
    --=gui_select(screen, nil, nil, "LOLZ", {"test 1", "test 2", "test 3"})

    local gpu = graphic.findGpu(screen)
    if not cx or not cy then
        cx, cy = gui.getBigZone(screen)
    end

    local window = graphic.createWindow(screen, cx, cy, 50, 16, true)
    local noShadow
    if not disableShadow then
        noShadow = gui.shadow(screen, cx, cy, 50, 16)
    end

    --------------------------------------------

    scroll = scroll or 0
    local addrs
    local addrsIdx
    local sel

    local function drawScrollBar()
        window:fill(window.sizeX, 2, 1, window.sizeY - 2, colors.brown, 0, " ")
        if #actions == 1 then
            window:set(window.sizeX, 2, colors.white, 0, " ")
        else
            window:set(window.sizeX, math.round(math.map(scroll, 0, #actions - 1, 2, window.sizeY - 1)), colors.white, 0, " ")
        end
    end

    local function redrawButton()
        window:set(window.sizeX - 9, window.sizeY, (sel or alwaysConfirm) and colors.lime or colors.green, colors.white, " CONFIRM ")
    end

    local function drawBase()
        --window:clear(colors.brown)
        window:fill(1, 1, window.sizeX, 1, colors.lightGray, 0, " ")
        if label then
            window:set(2, 1, colors.lightGray, colors.white, label)
        end
        if not noCloseButton then
            window:set(window.sizeX - 2, 1, colors.red, colors.white, " X ")
        end
        window:fill(1, window.sizeY, window.sizeX, 1, colors.lightGray, 0, " ")
        if overlay then
            local ret = overlay(window)
            if ret ~= nil then
                alwaysConfirm = ret
            end
        end
        redrawButton()
    end

    local function getCol(idx, color)
        return sel == idx and colors.blue or color
    end

    local function parseAction(action)
        if type(action) == "table" then
            return action[1], action[2]
        else
            return action, colors.black
        end
    end

    local function draw(pos)
        if not pos then
            drawBase()
        end
        
        addrs = {}
        addrsIdx = {}
        local lastLine = 1
        for index, action in ipairs(actions) do
            local y = (index + 1) - scroll
            if y >= 2 and y < window.sizeY then
                local astr, acol = parseAction(action)

                if not pos or pos == index then
                    window:fill(1, y, window.sizeX - 1, 1, getCol(index, acol), colors.white, " ")
                    window:set(2, y, getCol(index, acol), colors.white, astr)
                    lastLine = y
                end

                addrs[y] = astr
                addrsIdx[y] = index
            end
        end
        if not pos then
            lastLine = lastLine + 1
            window:fill(1, lastLine, window.sizeX - 1, window.sizeY - lastLine, colors.gray, 0, " ")
        end

        if not pos then
            drawScrollBar()
        end
    end

    local function drawUp()
        scroll = scroll - 1
        window:copy(1, 2, window.sizeX - 1, 13, 0, 1)
        
        addrs = {}
        addrsIdx = {}
        for index, action in ipairs(actions) do
            local y = (index + 1) - scroll
            if y >= 2 and y < window.sizeY then
                local astr, acol = parseAction(action)

                if y == 2 then
                    window:fill(1, y, window.sizeX - 1, 1, getCol(index, acol), colors.white, " ")
                    window:set(2, y, getCol(index, acol), colors.white, astr)
                end

                addrs[y] = astr
                addrsIdx[y] = index
            end
        end

        drawScrollBar()
    end

    local function drawDown()
        scroll = scroll + 1
        window:copy(1, 3, window.sizeX - 1, 13, 0, -1)
        
        local noDraw
        addrs = {}
        addrsIdx = {}
        for index, action in ipairs(actions) do
            local y = (index + 1) - scroll
            if y >= 2 and y < window.sizeY then
                local astr, acol = parseAction(action)

                if y == window.sizeY - 1 then
                    window:fill(1, y, window.sizeX, 1, getCol(index, acol), 0, " ")
                    window:set(2, y, getCol(index, acol), colors.white, astr)
                    noDraw = true
                end

                addrs[y] = astr
                addrsIdx[y] = index
            end
        end
        if not noDraw then
            window:fill(1, window.sizeY - 1, window.sizeX - 1, 1, colors.gray, 0, " ")
        end

        drawScrollBar()
    end

    draw()

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventCallback then
            local ret, lAlwaysConfirm = windowEventCallback(windowEventData, window)
            if ret ~= nil then
                if not noCleanShadow and noShadow then noShadow() end
                return ret, nil, nil, nil, nil, noShadow
            end
            if alwaysConfirm ~= lAlwaysConfirm then
                alwaysConfirm = lAlwaysConfirm
                drawBase()
            end
        end

        if windowEventData[1] == "touch" then
            if windowEventData[3] >= window.sizeX - 2 and windowEventData[4] == 1 then
                if not noCloseButton then
                    if not noCleanShadow and noShadow then noShadow() end
                    return nil, scroll, windowEventData[5], windowEventData, nil, noShadow
                end
            elseif windowEventData[3] >= window.sizeX - 9 and windowEventData[3] < window.sizeX and windowEventData[4] == window.sizeY then
                if sel or alwaysConfirm then
                    if not noCleanShadow and noShadow then noShadow() end
                    return sel, scroll, windowEventData[5], windowEventData, true, noShadow
                end
            end
        end

        if windowEventData[1] == "touch" or windowEventData[1] == "drag" then
            if addrsIdx[windowEventData[4]] and windowEventData[3] < window.sizeX and windowEventData[4] < window.sizeY then
                if windowEventData[5] == 1 and (not sel or sel ~= addrsIdx[windowEventData[4]]) then
                    local oldsel = sel
                    sel = addrsIdx[windowEventData[4]]
                    if sel ~= oldsel then
                        if oldsel then
                            draw(oldsel)
                        end
                        if sel then
                            draw(sel)
                        end
                        redrawButton()
                    end
                end
                if windowEventData[1] == "touch" and sel and sel == addrsIdx[windowEventData[4]] then
                    draw(sel)
                    redrawButton()
                    if not noCleanShadow and noShadow then noShadow() end
                    return sel, scroll, windowEventData[5], windowEventData, nil, noShadow
                end
                local oldsel = sel
                sel = addrsIdx[windowEventData[4]]
                if sel ~= oldsel then
                    if oldsel then
                        draw(oldsel)
                    end
                    if sel then
                        draw(sel)
                    end
                    redrawButton()
                end
            elseif sel then
                local lsel = sel
                sel = nil
                draw(lsel)
                redrawButton()
            end

            if windowEventData[3] == window.sizeX and windowEventData[4] < window.sizeY and windowEventData[4] > 1 then
                scroll = math.mapRound(windowEventData[4], 2, window.sizeY - 1, 0, #actions - 1)
                if scroll > #actions - 1 then scroll = #actions - 1 end
                if scroll < 0 then scroll = 0 end
                draw()
            end
        end

        if windowEventData[1] == "scroll" then
            if windowEventData[5] > 0 then
                if scroll > 0 then
                    drawUp()
                end
            else
                if scroll < #actions - 1 then
                    drawDown()
                end
            end
        end
    end
end

function gui.selectcomponent(screen, cx, cy, types, allowAutoConfirm, control, callbacks, blacklist, disableShadow) --=gui_selectcomponent(screen, nil, nil, {"computer"}, true)
    local advLabeling = require("advLabeling")
    local vcomponent = require("vcomponent")

    if types and type(types) ~= "table" then
        types = {types}
    end

    if not cx or not cy then
        cx, cy = gui.getBigZone(screen)
    end
    local checkWindow = graphic.createWindow(screen, cx, cy, 50, 16)

    local function allTypes()
        types = {}
        local added = {}
        for addr, ctype in component.list() do
            if not added[ctype] then
                table.insert(types, ctype)
                added[ctype] = true
            end
        end
        table.sort(types)
    end

    local allTypesFlag
    local typesstr = "select "
    if types then
        typesstr = typesstr .. table.concat(types, "/")
    else
        typesstr = typesstr .. "component"
        allTypesFlag = true
    end
    if control then
        typesstr = "components"
    end

    local cancel, out
    local gNoShadow

    local th
    th = thread.create(function ()
        if allTypesFlag then
            allTypes()
        end

        local scroll
        local shadowDrawed
        if disableShadow then
            shadowDrawed = true
        end

        while true do
            local strs = {}
            local addresses = {}

            for _, ctype in ipairs(types) do
                local addrs = {}
                for addr in component.list(ctype, true) do
                    table.insert(addrs, addr)
                end
                table.sort(addrs)
                for _, addr in ipairs(addrs) do
                    if not blacklist or not table.exists(blacklist, addr) then
                        table.insert(addresses, addr)

                        local tags = {}
                        if fs.bootaddress == addr then
                            table.insert(tags, "system")
                        end
                        if vcomponent.isVirtual(addr) then
                            table.insert(tags, "virtual")
                        end

                        local ctype = component.type(addr)
                        local clabel = advLabeling.getLabel(addr) or ""
                        if #tags > 0 then
                            clabel = clabel .. " (" .. table.concat(tags, "/") .. ")"
                        end
                        clabel = gui_container.short(clabel, 20)

                        table.insert(strs, ctype .. string.rep(" ", 38 - unicode.wlen(ctype) - unicode.wlen(clabel)) .. clabel .. string.rep(" ", (1 - unicode.wlen(clabel)) + unicode.wlen(clabel)) .. addr:sub(1, 8))
                    end
                end
            end

            if allowAutoConfirm and #addresses == 1 then
                out = addresses[1]
                th:kill()
                return
            end

            local idx, lscroll, button, eventData, _, noShadow = gui.select(screen, cx, cy, typesstr, strs, scroll, control, nil, nil, true, shadowDrawed)
            scroll = lscroll
            if not shadowDrawed then
                gNoShadow = noShadow
            end
            shadowDrawed = true

            local function openEdit(tempfile)
                local clear = graphic.screenshot(screen)
                if callbacks and callbacks.onEdit then
                    callbacks.onEdit()
                end
                require("apps").execute("edit", screen, nil, tempfile, true)
                if callbacks and callbacks.onCloseEdit then
                    callbacks.onCloseEdit()
                end
                clear()
                fs.remove(tempfile)
            end

            local subWindowX, subWindowY = (cx + 25) - 16, cy + 4
            if idx then
                local addr = addresses[idx]
                if button == 0 and not control then
                    out = addr
                    th:kill()
                    return
                else
                    local strs = {
                        "copy name",
                        "copy address",
                        "set label",
                        "clear label",
                        "view api",
                        "device info"
                    }
                    local px, py = checkWindow:toRealPos(eventData[3], eventData[4])
                    local x, y, sx, sy = gui.contextPos(screen, px, py, strs)
                    local clear = graphic.screenshot(screen, x, y, sx + 2, sy + 1)
                    local _, action = gui.context(screen, x, y, strs)
                    clear()
                    if action == 1 then 
                        clipboard.set(eventData[6], component.type(addr))
                    elseif action == 2 then
                        clipboard.set(eventData[6], addr)
                    elseif action == 3 then
                        local liked = require("liked")
                        liked.umountAll()
                        local str = gui.input(screen, subWindowX, subWindowY, "new name", nil, nil, advLabeling.getLabel(addr))
                        if type(str) == "string" then
                            advLabeling.setLabel(addr, str)
                        end
                        liked.mountAll()
                    elseif action == 4 then
                        if gui.yesno(screen, subWindowX, subWindowY, "clear label on \"" .. (advLabeling.getLabel(addr) or component.type(addr)) .. "\"?") then
                            local liked = require("liked")
                            liked.umountAll()
                            if component.type(addr) == "filesystem" then
                                if not pcall(component.invoke, addr, "setLabel", nil) then
                                    local clear = gui.saveZone(screen)
                                    gui.warn(screen, subWindowX, subWindowY, "invalid name")
                                    clear()
                                end
                            else
                                advLabeling.setLabel(addr, nil)
                            end
                            liked.mountAll()
                        end
                    elseif action == 5 then
                        local format = require("format")

                        local tempfile = paths.concat("/tmp", component.type(addr) .. "_" .. math.round(math.random(0, 9999)) .. ".txt")
                        local file = fs.open(tempfile, "wb")
                        local methods = component.methods(addr)
                        local maxMethodLen = 0
                        for name in pairs(methods) do
                            if unicode.len(name) > maxMethodLen then
                                maxMethodLen = unicode.len(name)
                            end
                        end
                        for name, direct in pairs(methods) do
                            local smart = format.smartConcat()
                            smart.add(1, name)
                            smart.add(maxMethodLen + 2, direct and "DIRECT" or "INDIRECT")
                            smart.add(maxMethodLen + 2 + 8, " - " .. (component.doc(addr, name) or "Undocumented") .. "\n")
                            file.write(smart.get())
                        end
                        file.close()

                        openEdit(tempfile)
                    elseif action == 6 then
                        local format = require("format")

                        local ctype = component.type(addr)
                        local tempfile = paths.concat("/tmp", ctype .. "_" .. math.round(math.random(0, 9999)) .. ".txt")
                        local file = fs.open(tempfile, "wb")
                        file.write("address - " .. tostring(addr) .. "\n")
                        file.write("ctype   - " .. tostring(ctype) .. "\n")
                        file.write("virtual - " .. tostring(vcomponent.isVirtual(addr)) .. "\n\n")
                        local tbl = lastinfo.deviceinfo[addr] or {}
                        local maxMethodLen = 0
                        for name in pairs(tbl) do
                            name = tostring(name)
                            if unicode.len(name) > maxMethodLen then
                                maxMethodLen = unicode.len(name)
                            end
                        end
                        for k, v in pairs(tbl) do
                            local smart = format.smartConcat()
                            smart.add(1, tostring(k))
                            smart.add(maxMethodLen + 2, "-")
                            smart.add(maxMethodLen + 4, tostring(v) .. "\n")
                            file.write(smart.get())
                        end
                        file.close()
                        openEdit(tempfile)
                    end
                end
            else
                cancel = true
                th:kill()
                return
            end
        end
    end)
    th:resume()
    
    while true do
        local eventData = {computer.pullSignal(0.1)}

        if cancel or out then
            if gNoShadow then gNoShadow() end
            return out
        end

        if eventData[1] == "component_added" or eventData[1] == "component_removed" then
            th:kill()
            th = thread.create(th.func)
            th:resume()
        end
    end
end

function gui.selectcomponentProxy(screen, cx, cy, types, allowAutoConfirm, control, callbacks, blacklist)
    local addr = gui.selectcomponent(screen, cx, cy, types, allowAutoConfirm, control, callbacks, blacklist)
    if addr then
        return component.proxy(addr)
    end
end

function gui.selectExternalFs(screen, cx, cy)
    return gui.selectcomponentProxy(screen, cx, cy, {"filesystem"}, false, false, nil, {fs.bootaddress, fs.tmpaddress})
end

function gui.checkPassword(screen, cx, cy, disableStartSound, noCancel)
    local regData = registry.data
    if regData then
        if regData.password then
            local clear = gui.saveZone(screen)
            local password = gui.input(screen, cx, cy, "enter password", true, nil, nil, disableStartSound, noCancel)
            clear()

            if password then
                if require("sha256").sha256(password .. (regData.passwordSalt or "")) == regData.password then
                    return true
                else
                    local clear = gui.saveZone(screen)
                    gui.warn(screen, cx, cy, "invalid password")
                    clear()
                end
            else
                return false --false означает что пользователь отказался от ввода пароля
            end
        else
            return true
        end
    else
        return true
    end
end

function gui.checkPasswordLoop(...)
    while true do
        local ret = gui.checkPassword(...)
        if ret ~= nil then
            return ret
        end
    end
end

function gui.yesno(screen, cx, cy, str, backgroundColor)
    local window, noShadow = gui.smallWindow(screen, cx, cy, str, backgroundColor, function (window, color)
        window:set(2, 1, color, colors.green, "  " .. unicode.char(0x2800+192) ..  "  ")
        window:set(2, 2, color, colors.green, " ◢█◣ ")
        window:set(2, 3, color, colors.green, "◢███◣")
        window:set(4, 2, colors.green, colors.white, "?")
    end)

    window:set(32 - 5, 7, colors.lime, colors.white, " yes ")
    window:set(2, 7, colors.red, colors.white, " no ")

    graphic.forceUpdate(screen)
    if registry.soundEnable then
        sound.question()
    end

    local function drawYes()
        window:set(32 - 5, 7, colors.green, colors.white, " yes ")
        graphic.forceUpdate(screen)
        event.sleep(0.1)
    end

    while true do
        local eventData = {computer.pullSignal()}
        local windowEventData = window:uploadEvent(eventData)
        if windowEventData[1] == "touch" and windowEventData[5] == 0 then
            if windowEventData[4] == 7 and windowEventData[3] > (32 - 6) and windowEventData[3] <= ((32 - 5) + 4) then
                drawYes()
                noShadow()
                return true
            elseif windowEventData[4] == 7 and windowEventData[3] >= 2 and windowEventData[3] <= (2 + 3) then
                window:set(2, 7, colors.brown, colors.white, " no ")
                graphic.forceUpdate(screen)
                event.sleep(0.1)
                noShadow()
                return false
            end
        elseif windowEventData[1] == "key_down" and windowEventData[4] == 28 then
            drawYes()
            noShadow()
            return true
        end
    end
end


function gui.clearRun(func, screen, ...)
    local clear = gui.saveZone(screen)
    local result = {func(screen, ...)}
    clear()
    return table.unpack(result)
end

function gui.clearBigRun(func, screen, ...)
    local clear = gui.saveBigZone(screen)
    local result = {func(screen, ...)}
    clear()
    return table.unpack(result)
end

function gui.clearScreenRun(func, screen, ...)
    local clear = graphic.screenshot(screen)
    local result = {func(screen, ...)}
    clear()
    return table.unpack(result)
end

calls.loaded.gui_yesno = gui.yesno
calls.loaded.gui_warn = gui.warn
calls.loaded.gui_drawtext = gui.drawtext
calls.loaded.gui_context = gui.context
calls.loaded.gui_input = gui.input
calls.loaded.gui_select = gui.select
calls.loaded.gui_selectcomponent = gui.selectcomponent
calls.loaded.gui_checkPassword = gui.checkPassword
calls.loaded.gui_status = gui.status
calls.loaded.saveZone = gui.saveZone
calls.loaded.saveBigZone = gui.saveBigZone
return guisystem/lib/gui_container.lua 3586 local gui_container = {}
gui_container.criticalChargeLevel = 20

gui_container.colors = {}
gui_container.indexsColors = {}

--------------------------------------------

local fs = require("filesystem")
local unicode = require("unicode")
local paths = require("paths")

--------------------------------------------

gui_container.defaultUserRoot = "/data/userdata/"

gui_container.userRoot = {} --{screen = path, ...}
gui_container.viewFileExps = {} --если адрес экрана сдесь равен true то разширения имен файлов не будут скрыты
gui_container.devModeStates = {} --легаси, и почти негде не используеться, dev-mode был удален из системы
gui_container.unlockedDisks = {}
gui_container.hiddenFiles = {}

gui_container.chars = {
    threeDots = "…",
    splitLine = "⎯",
    wideSplitLine = "⠶",
    dot = "●"
}

gui_container.screenSaverPath = "/data/screenSaver.scrsv"

---------------------------- необходимо сканфигурировать это все, в своей програме для поддержки свого формата

gui_container.newCreate = { --структура {name, exp, allowCheck(), create(path)}
}

gui_container.filesExps = { --дополнительные действия к файлам
}

gui_container.openVia = {
}

gui_container.typecolors = {
}

gui_container.typenames = {
}

gui_container.knownExps = { --данные файлы не будет предложинно открыть в текстовом редакторе(если поставить editable то будет предложенно)
}

gui_container.editable = { --вместо "open is text editor" будет писаться "edit"
}

----------------------------

function gui_container.getUserRoot(screen)
    local path = gui_container.userRoot[screen] or gui_container.defaultUserRoot
    fs.makeDirectory(path)
    if path:sub(#path, #path) ~= "/" then
        return path .. "/"
    end
    return path
end

function gui_container.short(str, max, endcheck)
    local len = unicode.len(str)
    if len > max then
        if endcheck then
            return unicode.sub(str, 1, max - 1) .. gui_container.chars.threeDots
        else
            return gui_container.chars.threeDots .. unicode.sub(str, (len - max) + 2, len)
        end
    end
    return str
end

function gui_container.toUserPath(screen, path) --конвертирует рутовый путь в путь пользователя
    return paths.canonical(unicode.sub(path, unicode.len(gui_container.getUserRoot(screen)), unicode.len(path)))
end

function gui_container.checkPath(screen, path) --проверяет не вышел ли пользователь из своий папки
    local userPath = gui_container.getUserRoot(screen)
    if unicode.sub(path, 1, unicode.len(userPath)) ~= userPath then
        return userPath
    end
    return path
end

function gui_container.refresh()
    local colors = {
        ["app"] = gui_container.colors.red,
        ["afpx"] = gui_container.colors.orange,
        ["lua"] = gui_container.colors.lime
    }

    for k, v in pairs(colors) do
        gui_container.typecolors[k] = v
    end

    local registry = require("registry")
    for str, tbl in pairs(registry.gui_container or {}) do
        for key, value in pairs(tbl) do
            gui_container[str][key] = value
        end
    end

    local cache = require("cache")
    cache.cache.findIcon = nil
    cache.cache.getIcon = nil
end

return gui_containersystem/lib/hdd.lua 2656 local fs = require("filesystem")
local component = require("component")
local registry = require("registry")
local paths = require("paths")
local hdd = {}

function hdd.get(proxy)
    if type(proxy) == "string" then
        proxy = component.proxy(proxy)
    end

    if proxy.type == "filesystem" then
        return proxy
    end
end

function hdd.move(from, to)
    from = hdd.get(from)
    to = hdd.get(to)
    fs.umount("/mnt/from")
    fs.umount("/mnt/to")
    fs.mount(from, "/mnt/from")
    fs.mount(to, "/mnt/to")
    local result = {fs.copy("/mnt/from", "/mnt/to")}
    fs.umount("/mnt/from")
    fs.umount("/mnt/to")
    return table.unpack(result)
end

function hdd.genName(uuid)
    local label = component.invoke(uuid, "getLabel")
    if label and #label == 0 then
        label = nil
    end
    return paths.concat("/data/userdata", (label or "disk"):sub(1, 8) .. "-" .. uuid:sub(1, 5))
end

function hdd.clone(screen, proxy, selectFrom)
    local gui = require("gui")

    local from, to
    local blacklist = {proxy.address}

    local clear = saveBigZone(screen)

    if selectFrom then
        to = proxy
        from = gui.selectcomponentProxy(screen, nil, nil, {"filesystem"}, false, nil, nil, blacklist)
    else
        for addr in component.list("filesystem", true) do
            if component.invoke(addr, "isReadOnly") then
                table.insert(blacklist, addr)
            end
        end

        to = gui.selectcomponentProxy(screen, nil, nil, {"filesystem"}, false, nil, nil, blacklist)
        from = proxy
    end

    if not to or not from then
        return
    end

    clear()

    local isRoot = to.address == fs.bootaddress
    if isRoot and registry.disableRootAccess then
        gui.warn(screen, nil, nil, "it is not possible to clone a disk to a system disk")
        return
    end

    local fromname = paths.name(hdd.genName(from.address))
    local toname = paths.name(hdd.genName(to.address))

    if (not isRoot or gui.pleaseType(screen, "TOROOT", "clone to root")) and gui.yesno(screen, nil, nil, "are you sure you want to clone an \"" .. fromname .. "\" drive to a \"" .. toname .. "\" drive?") then
        gui.status(screen, nil, nil, "cloning the \"" .. fromname .. "\" disk to \"" .. toname .. "\"")
        local liked = require("liked")
        liked.umountAll()
        local ok, err = hdd.move(from, to)
        if ok then
            local fromlabel = from.getLabel()
            if fromlabel then
                to.setLabel(fromlabel)
            end
        end
        liked.mountAll()
        return liked.assertNoClear(screen, ok, err)
    end
end

hdd.unloadable = true
return hddsystem/lib/image.lua 16618 local fs = require("filesystem")
local graphic = require("graphic")
local calls = require("calls")
local gui_container = require("gui_container")
local cache = require("cache")
local paths = require("paths")
local unicode = require("unicode")
local colorslib = require("colors")
local computer = require("computer")
local liked = require("liked")
local registry = require("registry")
local format = require("format")
local component = require("component")
local gui = require("gui")

local image = {}
local t3colors = {0x000000, 0x000040, 0x000080, 0x0000BF, 0x0000FF, 0x002400, 0x002440, 0x002480, 0x0024BF, 0x0024FF, 0x004900, 0x004940, 0x004980, 0x0049BF, 0x0049FF, 0x006D00, 0x006D40, 0x006D80, 0x006DBF, 0x006DFF, 0x009200, 0x009240, 0x009280, 0x0092BF, 0x0092FF, 0x00B600, 0x00B640, 0x00B680, 0x00B6BF, 0x00B6FF, 0x00DB00, 0x00DB40, 0x00DB80, 0x00DBBF, 0x00DBFF, 0x00FF00, 0x00FF40, 0x00FF80, 0x00FFBF, 0x00FFFF, 0x0F0F0F, 0x1E1E1E, 0x2D2D2D, 0x330000, 0x330040, 0x330080, 0x3300BF, 0x3300FF, 0x332400, 0x332440, 0x332480, 0x3324BF, 0x3324FF, 0x334900, 0x334940, 0x334980, 0x3349BF, 0x3349FF, 0x336D00, 0x336D40, 0x336D80, 0x336DBF, 0x336DFF, 0x339200, 0x339240, 0x339280, 0x3392BF, 0x3392FF, 0x33B600, 0x33B640, 0x33B680, 0x33B6BF, 0x33B6FF, 0x33DB00, 0x33DB40, 0x33DB80, 0x33DBBF, 0x33DBFF, 0x33FF00, 0x33FF40, 0x33FF80, 0x33FFBF, 0x33FFFF, 0x3C3C3C, 0x4B4B4B, 0x5A5A5A, 0x660000, 0x660040, 0x660080, 0x6600BF, 0x6600FF, 0x662400, 0x662440, 0x662480, 0x6624BF, 0x6624FF, 0x664900, 0x664940, 0x664980, 0x6649BF, 0x6649FF, 0x666D00, 0x666D40, 0x666D80, 0x666DBF, 0x666DFF, 0x669200, 0x669240, 0x669280, 0x6692BF, 0x6692FF, 0x66B600, 0x66B640, 0x66B680, 0x66B6BF, 0x66B6FF, 0x66DB00, 0x66DB40, 0x66DB80, 0x66DBBF, 0x66DBFF, 0x66FF00, 0x66FF40, 0x66FF80, 0x66FFBF, 0x66FFFF, 0x696969, 0x787878, 0x878787, 0x969696, 0x990000, 0x990040, 0x990080, 0x9900BF, 0x9900FF, 0x992400, 0x992440, 0x992480, 0x9924BF, 0x9924FF, 0x994900, 0x994940, 0x994980, 0x9949BF, 0x9949FF, 0x996D00, 0x996D40, 0x996D80, 0x996DBF, 0x996DFF, 0x999200, 0x999240, 0x999280, 0x9992BF, 0x9992FF, 0x99B600, 0x99B640, 0x99B680, 0x99B6BF, 0x99B6FF, 0x99DB00, 0x99DB40, 0x99DB80, 0x99DBBF, 0x99DBFF, 0x99FF00, 0x99FF40, 0x99FF80, 0x99FFBF, 0x99FFFF, 0xA5A5A5, 0xB4B4B4, 0xC3C3C3, 0xCC0000, 0xCC0040, 0xCC0080, 0xCC00BF, 0xCC00FF, 0xCC2400, 0xCC2440, 0xCC2480, 0xCC24BF, 0xCC24FF, 0xCC4900, 0xCC4940, 0xCC4980, 0xCC49BF, 0xCC49FF, 0xCC6D00, 0xCC6D40, 0xCC6D80, 0xCC6DBF, 0xCC6DFF, 0xCC9200, 0xCC9240, 0xCC9280, 0xCC92BF, 0xCC92FF, 0xCCB600, 0xCCB640, 0xCCB680, 0xCCB6BF, 0xCCB6FF, 0xCCDB00, 0xCCDB40, 0xCCDB80, 0xCCDBBF, 0xCCDBFF, 0xCCFF00, 0xCCFF40, 0xCCFF80, 0xCCFFBF, 0xCCFFFF, 0xD2D2D2, 0xE1E1E1, 0xF0F0F0, 0xFF0000, 0xFF0040, 0xFF0080, 0xFF00BF, 0xFF00FF, 0xFF2400, 0xFF2440, 0xFF2480, 0xFF24BF, 0xFF24FF, 0xFF4900, 0xFF4940, 0xFF4980, 0xFF49BF, 0xFF49FF, 0xFF6D00, 0xFF6D40, 0xFF6D80, 0xFF6DBF, 0xFF6DFF, 0xFF9200, 0xFF9240, 0xFF9280, 0xFF92BF, 0xFF92FF, 0xFFB600, 0xFFB640, 0xFFB680, 0xFFB6BF, 0xFFB6FF, 0xFFDB00, 0xFFDB40, 0xFFDB80, 0xFFDBBF, 0xFFDBFF, 0xFFFF00, 0xFFFF40, 0xFFFF80, 0xFFFFBF, 0xFFFFFF}
local colors = gui_container.indexsColors
local readbit = bit32.readbit

local function otherCheck(path, exp)
    path = paths.changeExtension(path, exp)
    return fs.exists(path) and path
end

local function imageReColor(color, blackListedColor, cols)
    cols = cols or gui.smartShadowsColors
    if blackListedColor and color == blackListedColor then
        for i, lcolor in ipairs(gui_container.indexsColors) do
            if lcolor == blackListedColor then
                return gui_container.indexsColors[(cols[i] or gui.smartShadowsColors[i]) + 1]
            end
        end
    end
    return color
end

local function repath(screen, path)
    local depth = graphic.getDepth(screen or component.list("screen")())
    if depth == 8 then
        path = otherCheck(path, "t3p") or path
    elseif depth == 4 then
        path = otherCheck(path, "t2p") or path
    elseif depth == 1 then
        path = otherCheck(path, "t1p") or path
    end
    return paths.canonical(path)
end

--wallpaperMode заставляет считать цвет lightBlue как прозрачность
function image.draw(screen, path, x, y, wallpaperMode, forceFullColor, lightMul, imagePaletteUsed, blackListedColor, newColors)
    if liked.recoveryMode then
        return
    end

    local llcolors = colors
    if imagePaletteUsed then
        llcolors = image.readPalette(path, false, screen) or colors
    end

    
    lightMul = lightMul or 1
    path = repath(screen, path)

    local gpu = graphic.findGpu(screen)

    cache.cache.images = cache.cache.images or {}
    local buffer
    local lcache = cache.cache.images[path]
    if lcache and fs.lastModified(path) == lcache[2] then
        buffer = lcache[1]
    else
        buffer = assert(fs.readFile(path))
        if computer.freeMemory() > #buffer * 3 then
            cache.cache.images[path] = {buffer, fs.lastModified(path)}
        end
    end

    local function read(bytecount)
        local str = buffer:sub(1, bytecount)
        buffer = buffer:sub(bytecount + 1, #buffer)
        return str
    end

    ------------------------------------

    local sx = string.byte(read(1))
    local sy = string.byte(read(1))
    local t3paletteSupport = read(1) == "3"
    if read(1) == "f" then
        forceFullColor = true
    end
    local skipPalette
    if read(1) == "p" then
        skipPalette = true
    end
    read(5)

    if skipPalette then
        read(16 * 3)
    end

    local function norm(x, y, text)
        if x <= 0 then
            return 1, y, unicode.sub(text, 2 - x, unicode.len(text))
        end
        return x, y, text
    end

    local background, foreground
    local fullBack, fullFore
    local char
    local col, col2
    local _, c, f, b
    if gpu.getSoftwareBuffers then
        local chars, fores, backs = gpu.getSoftwareBuffers()
        local rx = graphic.getResolution(screen)
        local colorByte, countCharBytes
        local isEmptyBuff = true
        local index

        gpu.updateFlag()

        for cy = 1, sy do
            for cx = 1, sx do
                colorByte = string.byte(read(1))
                fullBack, fullFore = nil, nil
                if t3paletteSupport then
                    if forceFullColor or graphic.getDepth(screen) == 8 then
                        fullBack = t3colors[string.byte(read(1)) + 1]
                        fullFore = t3colors[string.byte(read(1)) + 1]
                        if registry.visionProtection then
                            fullBack = format.visionProtectionConvert(fullBack)
                            fullFore = format.visionProtectionConvert(fullFore)
                        end
                    else
                        read(2)
                    end
                end
                countCharBytes = string.byte(read(1))

                background = 
                ((readbit(colorByte, 0) and 1 or 0) * 1) + 
                ((readbit(colorByte, 1) and 1 or 0) * 2) + 
                ((readbit(colorByte, 2) and 1 or 0) * 4) + 
                ((readbit(colorByte, 3) and 1 or 0) * 8)
                foreground = 
                ((readbit(colorByte, 4) and 1 or 0) * 1) + 
                ((readbit(colorByte, 5) and 1 or 0) * 2) + 
                ((readbit(colorByte, 6) and 1 or 0) * 4) + 
                ((readbit(colorByte, 7) and 1 or 0) * 8)
                char = read(countCharBytes)
                isEmptyBuff = char == " "
                index = (x - 1) + cx + (((cy + y) - 2) * rx)

                if background ~= 0 or foreground ~= 0 then
                    if (background == foreground or isEmptyBuff) and not fullBack then
                        backs[index] = imageReColor(colorslib.colorMul(llcolors[background + 1], lightMul), blackListedColor, newColors)
                        chars[index] = " "
                    else
                        col, col2 = nil, nil
                        if wallpaperMode then
                            if background == colorslib.lightBlue then col = backs[index] end
                            if foreground == colorslib.lightBlue then col2 = backs[index] end
                        end
                        if col then
                            backs[index] = col
                        else
                            backs[index] = imageReColor(colorslib.colorMul(fullBack or llcolors[background + 1], lightMul), blackListedColor, newColors)
                        end
                        if col2 then
                            fores[index] = col2
                        else
                            fores[index] = imageReColor(colorslib.colorMul(fullFore or llcolors[foreground + 1], lightMul), blackListedColor, newColors)
                        end
                        chars[index] = char
                    end
                end
            end
        end
    else
        local colorByte, countCharBytes
        local oldX, oldY = 1, 1
        local oldFore, oldBack, oldForeFull, oldBackFull
        local buff = ""
        local isEmptyBuff = true
        for cy = 1, sy do
            for cx = 1, sx do
                colorByte = string.byte(read(1))
                fullBack, fullFore = nil, nil
                if t3paletteSupport then
                    if forceFullColor or graphic.getDepth(screen) == 8 then
                        fullBack = t3colors[string.byte(read(1)) + 1]
                        fullFore = t3colors[string.byte(read(1)) + 1]
                        if registry.visionProtection then
                            fullBack = format.visionProtectionConvert(fullBack)
                            fullFore = format.visionProtectionConvert(fullFore)
                        end
                    else
                        read(2)
                    end
                end
                countCharBytes = string.byte(read(1))

                background = 
                ((readbit(colorByte, 0) and 1 or 0) * 1) + 
                ((readbit(colorByte, 1) and 1 or 0) * 2) + 
                ((readbit(colorByte, 2) and 1 or 0) * 4) + 
                ((readbit(colorByte, 3) and 1 or 0) * 8)
                foreground = 
                ((readbit(colorByte, 4) and 1 or 0) * 1) + 
                ((readbit(colorByte, 5) and 1 or 0) * 2) + 
                ((readbit(colorByte, 6) and 1 or 0) * 4) + 
                ((readbit(colorByte, 7) and 1 or 0) * 8)

                if not oldFore then oldFore = foreground end
                if not oldBack then oldBack = background end
                if not oldForeFull then oldForeFull = fullFore end
                if not oldBackFull then oldBackFull = fullBack end

                char = read(countCharBytes)

                if foreground ~= oldFore or background ~= oldBack or fullBack ~= oldBackFull or fullFore ~= oldForeFull or oldY ~= cy then
                    if oldBack ~= 0 or oldFore ~= 0 then --прозрачность, в реальной картинке такого не будет потому что если paint замечает оба нуля то он меняет одной значения чтобы пиксель не мог просто так стать прозрачным
                        if (oldBack == oldFore or isEmptyBuff) and not oldBackFull then --по избежании визуальных артефактов при отображении unicode символов от лица сматряшего на монитор со стороны
                            gpu.setBackground(imageReColor(colorslib.colorMul(llcolors[oldBack + 1], lightMul), blackListedColor, newColors))
                            gpu.set(norm(oldX + (x - 1), oldY + (y - 1), string.rep(" ", unicode.len(buff))))
                        else
                            col, col2 = nil, nil
                            if wallpaperMode then
                                _, c, f, b = pcall(gpu.get, oldX + (x - 1), oldY + (y - 1))
                                if oldBack == colorslib.lightBlue then col = b end
                                if oldFore == colorslib.lightBlue then col2 = b end
                            end
                            if col then
                                gpu.setBackground(col)
                            else
                                gpu.setBackground(imageReColor(colorslib.colorMul(oldBackFull or llcolors[oldBack + 1], lightMul), blackListedColor, newColors))
                            end
                            if col2 then
                                gpu.setForeground(col2)
                            else
                                gpu.setForeground(imageReColor(colorslib.colorMul(oldForeFull or llcolors[oldFore + 1], lightMul), blackListedColor, newColors))
                            end
                            gpu.set(norm(oldX + (x - 1), oldY + (y - 1), buff))
                        end
                    end

                    oldFore = foreground
                    oldBack = background
                    oldForeFull = fullFore
                    oldBackFull = fullBack
                    oldX = cx
                    oldY = cy
                    buff = char
                    isEmptyBuff = char == " "
                else
                    buff = buff .. char
                    if char ~= " " then
                        isEmptyBuff = false
                    end
                end
            end
        end

        if oldBack ~= 0 or oldFore ~= 0 then --прозрачность, в реальной картинке такого не будет потому что если paint замечает оба нуля то он меняет одной значения чтобы пиксель не мог просто так стать прозрачным
            if (oldBack == oldFore or isEmptyBuff) and not oldBackFull then --по избежании визуальных артефактов при отображении unicode символов от лица сматряшего на монитор со стороны
                gpu.setBackground(imageReColor(colorslib.colorMul(llcolors[oldBack + 1], lightMul), blackListedColor, newColors))
                gpu.set(norm(oldX + (x - 1), oldY + (y - 1), string.rep(" ", unicode.len(buff))))
            else
                col, col2 = nil, nil
                if wallpaperMode then
                    _, c, f, b = pcall(gpu.get, oldX + (x - 1), oldY + (y - 1))
                    if oldBack == colorslib.lightBlue then col = b end
                    if oldFore == colorslib.lightBlue then col2 = b end
                end
                if col then
                    gpu.setBackground(col)
                else
                    gpu.setBackground(imageReColor(colorslib.colorMul(oldBackFull or llcolors[oldBack + 1], lightMul), blackListedColor, newColors))
                end
                if col2 then
                    gpu.setForeground(col2)
                else
                    gpu.setForeground(imageReColor(colorslib.colorMul(oldForeFull or llcolors[oldFore + 1], lightMul), blackListedColor, newColors))
                end
                gpu.set(norm(oldX + (x - 1), oldY + (y - 1), buff))
            end
        end
    end

    graphic.updateFlag(screen)
end

function image.readPalette(path, fromZero, screen)
    path = repath(screen, path)

    local file = fs.open(path, "rb", true)
    file.read(4)
    local isPal = file.read(1) == "p"
    file.read(5)

    if isPal then
        local palette = {}
        for i = 0, 15 do
            local color = colorslib.blend(string.byte(file.read(1)), string.byte(file.read(1)), string.byte(file.read(1)))
            if fromZero then
                palette[i] = color
            else
                table.insert(palette, color)
            end
        end
        return palette
    end
end

function image.applyPalette(screen, path)
    path = repath(screen, path)

    local pal = image.readPalette(path, false, screen)
    if pal then
        graphic.setPalette(screen, pal)
        return true
    end
end

function image.size(path, screen)
    path = repath(screen, path)

    local file = fs.open(path, "rb", 4)
    local sx = string.byte(file.read(1))
    local sy = string.byte(file.read(1))
    file.close()

    return sx, sy
end

function image.sizeX(path, screen)
    return (image.size(path, screen))
end

function image.sizeY(path, screen)
    return (select(2, image.size(path, screen)))
end

image.unloadable = true
return imagesystem/lib/iowindows.lua 6759 local gui = require("gui")
local paths = require("paths")
local fs = require("filesystem")
local gui_container = require("gui_container")
local text = require("text")
local format = require("format")
local iowindows = {}

local function iowindow(screen, dirmode, exp, save)
    ---- title
    local title = ""
    if save then
        title = title .. "save "
    else
        title = title .. "select "
    end
    
    local exps
    if exp then
        if type(exp) == "table" then
            exps = exp
            exp = exps[1]
        else
            exps = {exp}
        end
        title = title .. (gui_container.typenames[exp] or exp) .. " "
    end

    if dirmode then
        title = title .. "folder"
    else
        title = title .. "file"
    end

    ---- main
    local path = gui_container.defaultUserRoot
    local pathPos = 5 + (save and 17 or 0)

    local function retpathFunc(list, num, fullpath, confirm)
        local isDir = num == 1 or fs.isDirectory(fullpath)
        local lexp = paths.extension(fullpath)

        if isDir and not confirm then
            path = gui_container.checkPath(screen, fullpath)
        else
            local exists = fs.exists(fullpath)
            if (not exists or isDir == dirmode) and (not exp or lexp == exp) then
                local retpath = fullpath
                if num and list and list[num].name == ".." then
                    retpath = paths.canonical(path)
                end
                if save then
                    if not exists or gui.yesno(screen, nil, nil, "are you sure you want to " .. (isDir and "merge the directory?" or "overwrite the file?")) then
                        return retpath
                    end
                else
                    return retpath
                end
            else
                gui.warn(screen, nil, nil, "select the " .. (dirmode and "folder" or "file") .. (exp and (" with the " .. exp .. " extension") or ""))
            end
        end
    end

    local inputTextBuffer
    local disableShadow
    local clearShadow
    while true do
        local list = {{".. (back / current)", gui_container.colors.black, name = ".."}}
        for i, file in ipairs(fs.list(path)) do
            local fullpath = paths.concat(path, file)
            local isDir = fs.isDirectory(fullpath)
            if gui.isVisible(screen, fullpath) and (isDir or not dirmode) then
                local name = paths.name(file)
                local lexp = paths.extension(name)
                if isDir or not exp or lexp == exp then
                    if not gui_container.viewFileExps[screen] then
                        name = paths.hideExtension(name)
                    end

                    local smartString = format.smartConcat()
                    smartString.add(1, gui_container.short(name, 34, true))
                    smartString.add(47 - 5, lexp and gui_container.short(gui_container.typenames[lexp] or lexp, 6, true) or "", true)
                    smartString.add(47, isDir and "DIR" or "FILE", true)
                    table.insert(list, {smartString.get(), gui_container.typecolors[lexp] or gui_container.colors.black, name = file})
                end
            end
        end
        
        local reader
        local num, _, _, _, confirm, lClearShadow = gui.select(screen, nil, nil, title, list, nil, nil, function (window)
            window:set(1, window.sizeY, gui_container.colors.red, gui_container.colors.white, " + ")
            window:set(pathPos, window.sizeY, gui_container.colors.lightGray, gui_container.colors.white, gui_container.short(gui_container.toUserPath(screen, path), save and 18 or 35))
            local ret
            if save then
                if not reader then
                    reader = window:readNoDraw(5, window.sizeY, 16, gui_container.colors.white, gui_container.colors.gray, nil, nil, nil, true)
                    if inputTextBuffer then
                        reader.setBuffer(inputTextBuffer)
                        if #inputTextBuffer > 0 then
                            ret = true
                        end
                    end
                end
                reader.redraw()
            end
            return ret
        end, function (windowEventData, window)
            local fakeConfirm
            if reader then
                inputTextBuffer = reader.getBuffer()
                fakeConfirm = #inputTextBuffer > 0
            end

            if reader then
                local ret = reader.uploadEvent(windowEventData)
                if ret then
                    return -1, fakeConfirm
                end
            end

            if windowEventData[1] == "touch" then
                if windowEventData[4] == window.sizeY and windowEventData[3] <= 3 then
                    local clear = gui.saveZone(screen)
                    local name = gui.input(screen, nil, nil, "folder name")
                    clear()

                    if name then
                        fs.makeDirectory(paths.concat(path, name))
                        return true, fakeConfirm
                    end
                end
            end

            return nil, fakeConfirm
        end, true, disableShadow)
        disableShadow = true
        clearShadow = clearShadow or lClearShadow

        if num == -1 then
            num = nil
            confirm = true
        end

        if num then
            if num ~= true then
                local fullpath = paths.concat(path, list[num].name)
                local retpath = retpathFunc(list, num, fullpath, confirm)
                if retpath then
                    clearShadow()
                    return retpath
                end
            end
        elseif confirm and reader then
            local buff = reader.getBuffer()
            if #buff == 0 or buff:find("%\\") or buff:find("%/") or (exp and buff:find("%.")) then
                gui.warn(screen, nil, nil, "incorrect file name")
            else
                local retpath = retpathFunc(nil, nil, paths.concat(path, buff .. (exp and ("." .. exp) or "")), true)
                if retpath then
                    clearShadow()
                    return retpath
                end
            end
        else
            clearShadow()
            return
        end
    end
end


function iowindows.selectfile(screen, exp)
    return iowindow(screen, false, exp, false)
end

function iowindows.selectfolder(screen, exp)
    return iowindow(screen, true, exp, false)
end

function iowindows.savefile(screen, exp)
    return iowindow(screen, false, exp, true)
end

function iowindows.savefolder(screen, exp)
    return iowindow(screen, true, exp, true)
end

iowindows.unloadable = true
return iowindowssystem/lib/json.lua 4406 local a={unloadable=true}local b;local c={["\\"]="\\",['"']='"',["\b"]="b",["\f"]="f",["\n"]="n",["\r"]="r",["\t"]="t"}local d={["/"]="/"}for e,f in pairs(c)do d[f]=e end;local function g(h)return"\\"..(c[h]or string.format("u%04x",h:byte()))end;local function i(j)return"null"end;local function k(j,l)local m={}l=l or{}if l[j]then error("circular reference")end;l[j]=true;if j[1]~=nil or next(j)==nil then local n=0;for e in pairs(j)do if type(e)~="number"then error("invalid table: mixed or invalid key types")end;n=n+1 end;if n~=#j then error("invalid table: sparse array")end;for o,f in ipairs(j)do table.insert(m,b(f,l))end;l[j]=nil;return"["..table.concat(m,",").."]"else for e,f in pairs(j)do if type(e)~="string"then error("invalid table: mixed or invalid key types")end;table.insert(m,b(e,l)..":"..b(f,l))end;l[j]=nil;return"{"..table.concat(m,",").."}"end end;local function p(j)return'"'..j:gsub('[%z\1-\31%z\127-\255\\"]',g)..'"'end;local function q(j)if j~=j or j<=-math.huge or j>=math.huge then error("unexpected number value '"..tostring(j).."'")end;return string.format("%.14g",j)end;local r={["nil"]=i,["table"]=k,["string"]=p,["number"]=q,["boolean"]=tostring}b=function(j,l)local s=type(j)local t=r[s]if t then return t(j,l)end;error("unexpected type '"..s.."'")end;function a.encode(j)return b(j)end;local u;local function v(...)local m={}for o=1,select("#",...)do m[select(o,...)]=true end;return m end;local w=v(" ","\t","\r","\n")local x=v(" ","\t","\r","\n","]","}",",")local y=v("\\","/",'"',"b","f","n","r","t","u")local z=v("true","false","null")local A={["true"]=true,["false"]=false,["null"]=nil}local function B(C,D,E,F)for o=D,#C do if E[C:sub(o,o)]~=F then return o end end;return#C+1 end;local function G(C,D,H)local I=1;local J=1;for o=1,D-1 do J=J+1;if C:sub(o,o)=="\n"then I=I+1;J=1 end end;error(string.format("%s at line %d col %d",H,I,J))end;local function K(n)local t=math.floor;if n<=255 then return string.char(n)elseif n<=0x7ff then return string.char(t(n/64)+192,n%64+128)elseif n<=0xffff then return string.char(t(n/4096)+224,t(n%4096/64)+128,n%64+128)elseif n<=0x10ffff then return string.char(t(n/262144)+240,t(n%262144/4096)+128,t(n%4096/64)+128,n%64+128)end;error(string.format("invalid unicode codepoint '%x'",n))end;local function L(M)local N=tonumber(M:sub(1,4),16)local O=tonumber(M:sub(7,10),16)if O then return K((N-0xd800)*0x400+O-0xdc00+0x10000)else return K(N)end end;local function P(C,o)local m=""local Q=o+1;local e=Q;while Q<=#C do local R=C:byte(Q)if R<32 then G(C,Q,"control character in string")elseif R==92 then m=m..C:sub(e,Q-1)Q=Q+1;local h=C:sub(Q,Q)if h=="u"then local S=C:match("^[dD][89aAbB]%x%x\\u%x%x%x%x",Q+1)or C:match("^%x%x%x%x",Q+1)or G(C,Q-1,"invalid unicode escape in string")m=m..L(S)Q=Q+#S else if not y[h]then G(C,Q-1,"invalid escape char '"..h.."' in string")end;m=m..d[h]end;e=Q+1 elseif R==34 then m=m..C:sub(e,Q-1)return m,Q+1 end;Q=Q+1 end;G(C,o,"expected closing quote for string")end;local function T(C,o)local R=B(C,o,x)local M=C:sub(o,R-1)local n=tonumber(M)if not n then G(C,o,"invalid number '"..M.."'")end;return n,R end;local function U(C,o)local R=B(C,o,x)local V=C:sub(o,R-1)if not z[V]then G(C,o,"invalid literal '"..V.."'")end;return A[V],R end;local function W(C,o)local m={}local n=1;o=o+1;while 1 do local R;o=B(C,o,w,true)if C:sub(o,o)=="]"then o=o+1;break end;R,o=u(C,o)m[n]=R;n=n+1;o=B(C,o,w,true)local X=C:sub(o,o)o=o+1;if X=="]"then break end;if X~=","then G(C,o,"expected ']' or ','")end end;return m,o end;local function Y(C,o)local m={}o=o+1;while 1 do local Z,j;o=B(C,o,w,true)if C:sub(o,o)=="}"then o=o+1;break end;if C:sub(o,o)~='"'then G(C,o,"expected string for key")end;Z,o=u(C,o)o=B(C,o,w,true)if C:sub(o,o)~=":"then G(C,o,"expected ':' after key")end;o=B(C,o+1,w,true)j,o=u(C,o)m[Z]=j;o=B(C,o,w,true)local X=C:sub(o,o)o=o+1;if X=="}"then break end;if X~=","then G(C,o,"expected '}' or ','")end end;return m,o end;local _={['"']=P,["0"]=T,["1"]=T,["2"]=T,["3"]=T,["4"]=T,["5"]=T,["6"]=T,["7"]=T,["8"]=T,["9"]=T,["-"]=T,["t"]=U,["f"]=U,["n"]=U,["["]=W,["{"]=Y}u=function(C,D)local X=C:sub(D,D)local t=_[X]if t then return t(C,D)end;G(C,D,"unexpected character '"..X.."'")end;function a.decode(C)if type(C)~="string"then error("expected argument of type string, got "..type(C))end;local m,D=u(C,B(C,1,w,true))D=B(C,D,w,true)if D<=#C then G(C,D,"trailing garbage")end;return m end;return asystem/lib/liked/funcs/getComputerScore.lua 472 local cpuLevel = require("system").getCpuLevel()
local ram = require("computer").totalMemory() / 1024
local score = 0

if cpuLevel >= 3 then
    score = score + 5
elseif cpuLevel == 2 then
    score = score + 3
else
    score = score + 1
end

if ram >= 2048 then
    score = score + 5
elseif ram >= 1024 + 512 then
    score = score + 4
elseif ram >= 1024 then
    score = score + 3
elseif ram >= 768 then
    score = score + 2
else
    score = score + 1
end

return scoresystem/lib/liked/funcs/getScoreColor.lua 271 local gui_container = require("gui_container")
local colors = gui_container.colors

local score = ...

if score >= 10 then
    return colors.cyan
elseif score >= 7 then
    return colors.green
elseif score >= 5 then
    return colors.orange
else
    return colors.red
endsystem/lib/liked/init.lua 24435 local fs = require("filesystem")
local bootloader = require("bootloader")
local computer = require("computer")
local component = require("component")
local programs = require("programs")
local gui = require("gui")
local paths = require("paths")
local registry = require("registry")
local graphic = require("graphic")
local time = require("time")
local system = require("system")
local serialization = require("serialization")
local gui_container = require("gui_container")
local event = require("event")
local unicode = require("unicode")
local thread = require("thread")
local cache = require("cache")
local natives = require("natives")
local colorlib = require("colors")
local palette = require("palette")
local package = require("package")
local screensaver = require("screensaver")
local image = require("image")
local logs = require("logs")
local sysinit = require("sysinit")
local lastinfo = require("lastinfo")
local vcomponent = require("vcomponent")
local liked = {recoveryMode = bootloader.recoveryMode, colors = gui_container.colors}

local colors = gui_container.colors

--------------------------------------------------------

function liked.isLikedDisk(address)
    local signature = "--liked"

    local file = component.invoke(address, "open", "/system/main.lua", "rb")
    if file then
        local data = component.invoke(address, "read", file, #signature)
        component.invoke(address, "close", file)
        return signature == data
    end

    return false
end

function liked.isUserdata(path)
    local data = "/data/userdata/"
    return path:sub(1, #data) == data
end
    
function liked.wait(screen)
    while true do
        local eventData = {event.pull()}
        if eventData[1] == "close" and eventData[2] == screen then
            break
        elseif eventData[1] == "key_down" and table.exists(lastinfo.keyboards[screen], eventData[2]) and eventData[3] == 13 and eventData[4] == 28 then
            break
        end
    end
end

function liked.isUninstallScript(path)
    return fs.exists(paths.concat(path, "uninstall.lua"))
end

function liked.isUninstallAvailable(path)
    if fs.isReadOnly(path) then return false end

    local data = "/data/"
    local vendor = "/vendor/"
    if path:sub(1, #data) == data then --вы всегда можете удалить приложения из data
        return true
    elseif path:sub(1, #vendor) == vendor then --вы можете удалить приложения вендора только если в нем есть uninstall.lua
        return liked.isUninstallScript(path)
    end
    return false
end

function liked.isExecuteAvailable(path)
    if not registry.disableCustomPrograms then return true end
    return not liked.isUserdata(path)
end

--------------------------------------------------------

function liked.publicMode(screen, path)
    if registry.disableCustomFiles then
        if not path or liked.isUserdata(path) then
            local clear = saveZone(screen)
            gui.warn(screen, nil, nil, "this file cannot be used on your liked edition")
            clear()
            return false
        end
    end
    return true
end

function liked.lastVersion()
    local branch = "main"
    if package.isInstalled("sysdata") then
        branch = require("sysdata").get("branch")
    end
    local lastVersion, err = require("internet").getInternetFile("https://raw.githubusercontent.com/igorkll/liked/" .. branch .. "/system/version.cfg")
    if not lastVersion then return nil, err end
    return tonumber(lastVersion) or -1
end

function liked.version()
    return tonumber(assert(fs.readFile("/system/version.cfg")))
end

function liked.umountAll()
    local hdd = require("hdd")

    for address in component.list("filesystem") do
        if address ~= computer.tmpAddress() and address ~= fs.bootaddress then
            fs.umount(component.proxy(address))
        end
    end
end

function liked.mountAll()
    local hdd = require("hdd")

    for address in component.list("filesystem") do
        if address ~= computer.tmpAddress() and address ~= fs.bootaddress then
            fs.mount(address, hdd.genName(address))
        end
    end
end

--------------------------------------------------------

function liked.assert(screen, ...)
    local successful, err = ...
    if not successful then
        local clear = saveZone(screen)
        gui.warn(screen, nil, nil, err or "unknown error")
        clear()
    end
    return ...
end

function liked.bigAssert(screen, ...)
    local successful, err = ...
    if not successful then
        local clear = saveBigZone(screen)
        gui.bigWarn(screen, nil, nil, err or "unknown error")
        clear()
    end
    return ...
end

function liked.assertNoClear(screen, ...)
    local successful, err = ...
    if not successful then
        gui.warn(screen, nil, nil, err or "unknown error")
    end
    return ...
end

--------------------------------------------------------

function liked.applyReg(path, screen)
    if screen then
        if liked.assert(screen, registry.apply(path)) then
            gui_container.refresh()
            registry.save()
        end
    else
        if registry.apply(path) then
            gui_container.refresh()
            registry.save()
        end
    end
end

local bufferTimerId
function liked.applyBufferType()
    graphic.unloadBuffers()

    if liked.recoveryMode then
        graphic.allowSoftwareBuffer = false
        graphic.allowHardwareBuffer = false

        if bufferTimerId then
            event.cancel(bufferTimerId)
            bufferTimerId = nil
        end
    else
        graphic.allowSoftwareBuffer = registry.bufferType == "software"
        graphic.allowHardwareBuffer = registry.bufferType == "hardware"

        if graphic.allowHardwareBuffer or graphic.allowSoftwareBuffer then
            if not bufferTimerId then
                bufferTimerId = event.timer(0.1, function ()
                    for address in component.list("screen") do
                        graphic.update(address)
                    end
                end, math.huge)
            end
        else
            if bufferTimerId then
                event.cancel(bufferTimerId)
                bufferTimerId = nil
            end
        end
    end
end

local energyTh
local wakeupEvents = {
    touch = true,
    drop = true,
    drag = true,
    scroll = true,
    key_down = true,
    key_up = true
}
function liked.applyPowerMode()
    if registry.powerMode == "power" then
        event.minTime = 0
        if energyTh then
            energyTh:kill()
            energyTh = nil
        end
    else
        event.minTime = 0.05
        if not energyTh then
            energyTh = thread.createBackground(function ()
                local oldWakeTIme = computer.uptime()
                while true do
                    local eventData = {event.pull(1)}
                    if eventData[1] and wakeupEvents[eventData[1]] then
                        event.minTime = 0.05
                        oldWakeTIme = computer.uptime()
                    elseif computer.uptime() - oldWakeTIme > 10 then
                        event.minTime = 4
                    end
                end
            end)
            energyTh:resume()
        end
    end
end

function liked.applyBeepState()
    if registry.fullBeepDisable then
        computer.beep = system.stub
    else
        computer.beep = natives.computer.beep
    end
end

function liked.applyTimeZone()
    logs.timeZone = registry.timeZone or 0
    if not gui_container.timeZoneHook then
        package.applyHook(function (libname, lib)
            if libname == "logs" then
                lib.timeZone = registry.timeZone or 0
            end
            return lib
        end)
        gui_container.timeZoneHook = true
    end
end

--------------------------------------------------------

local function raw_drawUpBarTask(method, screen, ...)
    local tbl = {...}
    local function redraw()
        liked.drawUpBar(screen, table.unpack(tbl))
        graphic.updateFlag(screen)
    end
    local th = method(function ()
        while true do
            redraw()
            os.sleep(5)
        end
    end)
    th:resume()
    return th, redraw
end

function liked.upBarShadow(screen)
    if gui.scrShadow[screen] and gui.scrShadow[screen] > 0 then
        local rx = graphic.getResolution(screen)
        gui.shadow(screen, 1, 1, rx, 1, nil, true)
    end
end

function liked.drawUpBarTask(...)
    return raw_drawUpBarTask(require("thread").create, ...)
end

function liked.drawUpBarTaskBg(...)
    return raw_drawUpBarTask(require("thread").createBackground, ...)
end


function liked.drawUpBar(screen, withoutFill, bgcolor, guiOffset, noShadow)
    local rtc = "RTC-" .. time.formatTime(time.addTimeZone(time.getRealTime(), registry.timeZone or 0))
    local gtc = "GTC-" .. time.formatTime(time.getGameTime())
    local charge = system.getCharge()
    
    local gpu = graphic.findGpu(screen)
    local rx, ry = gpu.getResolution()
    gpu.setBackground(bgcolor or gui_container.colors.gray)
    gpu.setForeground(gui_container.colors.white)
    if not withoutFill then
        gpu.fill(1, 1, rx, 1, " ")
    end

    local battery = "⣏⣉⣉⡷"
    local batteryLen = unicode.len(battery)
    local offset = (batteryLen + 1) - (guiOffset or 0)

    gpu.set(rx - #rtc - 7 - offset, 1, rtc)
    gpu.set(rx - #gtc - 18 - offset, 1, gtc)
    if charge <= gui_container.criticalChargeLevel then
        gpu.setForeground(gui_container.colors.red)
    end
    local chargestr = tostring(charge)
    gpu.set(rx - 5 - offset, 1, "   ")
    gpu.set(rx - #chargestr - 2 - offset, 1, tostring(chargestr) .. "%")

    gpu.setBackground(bgcolor or gui_container.colors.gray)
    gpu.setForeground(gui_container.colors.white)

    for i = 1, batteryLen do
        local char = unicode.sub(battery, i, i)
        if i == batteryLen then
            gpu.setBackground(bgcolor or gui_container.colors.gray)
        else
            if charge <= gui_container.criticalChargeLevel then
                if i == 1 then
                    gpu.setBackground(gui_container.colors.red)
                else
                    gpu.setBackground(bgcolor or gui_container.colors.gray)
                end
            else
                local last = 3
                if charge <= 50 then
                    last = 1
                elseif charge <= 75 then
                    last = 2
                end

                if i <= last then
                    gpu.setBackground(gui_container.colors.lime)
                else
                    gpu.setBackground(bgcolor or gui_container.colors.gray)
                end
            end
        end
        gpu.set((rx - offset) + (i - 1), 1, char)
    end

    if not noShadow then
        liked.upBarShadow(screen)
    end

    graphic.updateFlag(screen)
end

--------------------------------------------------------

local function raw_drawFullUpBarTask(method, screen, title, withoutFill, bgcolor, wideExit)
    if wideExit == nil then wideExit = true end
    local function redraw()
        liked.drawFullUpBar(screen, title, withoutFill, bgcolor, wideExit)
        graphic.updateFlag(screen)
    end
    local callbacks = {}
    local th = method(function ()
        thread.create(function ()
            local rx, ry = graphic.getResolution(screen)
            local window = graphic.createWindow(screen, 1, 1, rx, 1)
            while true do
                local eventData = {event.pull()}
                local windowEventData = window:uploadEvent(eventData)
                if windowEventData[1] == "touch" then
                    if callbacks.exit then
                        if wideExit then
                            if windowEventData[3] >= rx - 2 then
                                callbacks.exit()
                            end
                        else
                            if windowEventData[3] == rx then
                                callbacks.exit()
                            end
                        end
                    end
                end
            end
        end):resume()

        while true do
            redraw()
            os.sleep(5)
        end
    end)
    th:resume()
    return th, redraw, callbacks
end

function liked.drawFullUpBarTask(...)
    return raw_drawFullUpBarTask(thread.create, ...)
end

function liked.drawFullUpBarTaskBg(...)
    return raw_drawFullUpBarTask(thread.createBackground, ...)
end

function liked.drawFullUpBar(screen, title, withoutFill, bgcolor, wideExit, noShadow)
    liked.drawUpBar(screen, withoutFill, bgcolor, wideExit and -2, true)
    local gpu = graphic.findGpu(screen)
    local rx, ry = gpu.getResolution()

    gpu.setForeground(gui_container.colors.white)
    if title then
        gpu.set(2, 1, title)
    end
    gpu.setBackground(gui_container.colors.red)
    if wideExit then
        gpu.set(rx - 2, 1, " X ")
    else
        gpu.set(rx, 1, "X")
    end

    if not noShadow then
        liked.upBarShadow(screen)
    end
end

--------------------------------------------------------

--[[
function liked.getRegistry(address)
    local mountpoint = os.tmpname()
    fs.mount(address or fs.get("/"), mountpoint)
    local regPath = paths.concat(mountpoint, "data/registry.dat")

    if fs.exists(regPath) or not fs.isDirectory(regPath) then
        local regData = fs.readFile(regPath)
        fs.umount(mountpoint)
        if regData then
            local ok, regTbl = pcall(serialization.unserialize, regData)
            if ok and type(regTbl) == "table" then
                return regTbl
            end
        end
    else
        fs.umount(mountpoint)
    end
end

function liked.labelReadonly(proxy)
    if type(proxy) == "string" then
        proxy = component.proxy(proxy)
    end
    return not pcall(proxy.setLabel, proxy.getLabel() or nil)
end

function liked.reg(str, key, value)
    gui_container[str][key] = value
    if not registry.gui_container then registry.gui_container = {} end
    if not registry.gui_container[str] then registry.gui_container[str] = {} end
    registry.gui_container[str][key] = value
    registry.save()
end
]]

function liked.getName(screen, path, isAlias)
    local name
    if not isAlias and gui_container.viewFileExps[screen] then
        name = paths.name(path)
    else
        name = paths.name(paths.hideExtension(path))
    end
    
    if unicode.len(name) > 12 then
        return unicode.sub(name, 1, 12) .. gui_container.chars.threeDots, name
    end
    return name, name
end

function liked.selfApplicationName()
    local scriptPath = system.getSelfScriptPath()
    local application = paths.path(scriptPath)
    if paths.extension(application) == "app" then
        application = scriptPath
    end
    return paths.hideExtension(paths.name(scriptPath))
end

function liked.applicationWindow(screen, title, bgcolor)
    local sx, sy = graphic.getResolution(screen)
    return graphic.createWindow(screen, 1, 2, sx, sy - 1), liked.drawFullUpBarTask(screen, title, bgcolor)
end

--------------------------------------------------------

function liked.getActions(path)
    local files, strs, actives = {}, {}, {}
    if fs.exists(path) and fs.isDirectory(path) then
        local actionPath = paths.concat(path, "actions.cfg") --раньше тут был lua файл, который выполнялся, но это слишком небезопастно

        if fs.exists(actionPath) and not fs.isDirectory(actionPath) then
            local content = fs.readFile(actionPath)
            if type(content) == "string" then
                local result = {pcall(serialization.unserialize, content)}
                event.yield() --предотващения краша при долгой десереализации

                if result and result[1] and type(result[2]) == "table" then
                    for _, value in ipairs(result[2]) do
                        if type(value) == "table" and type(value[1]) == "string" and type(value[3]) == "string" then
                            local action = value[1]
                            if unicode.len(action) < 24 then
                                table.insert(files, paths.xconcat(path, value[3]))
                                table.insert(strs, action)
                                table.insert(actives, not not value[2])
                                if #files >= 5 then --защита от приложений с большим количеством доп действий, так как это может использоваться для защиты от удаления
                                    break
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    return files, strs, actives
end

function liked.findIcon(name)
    cache.cache.findIcon = cache.cache.findIcon or {}
    if cache.cache.findIcon[name] then
        return cache.cache.findIcon[name]
    end

    if registry.icons and registry.icons[name] then
        return registry.icons[name]
    end

    local path = bootloader.find(paths.concat("icons", name .. ".t2p"))
    cache.cache.findIcon[name] = path
    return path
end

function liked.getIcon(screen, path)
    cache.cache.getIcon = cache.cache.getIcon or {}
    if cache.cache.getIcon[path] then
        if not fs.exists(path) then
            cache.cache.getIcon[path] = nil
            return liked.findIcon("badicon")
        end
        return cache.cache.getIcon[path]
    end

    local exp = paths.extension(path)
    local isDir = fs.isDirectory(path)
    local icon
    
    if isDir then
        local fsProxy, fsLocalPath = fs.get(path)
        if fsLocalPath ~= "/" then
            fsProxy = nil
        end
        if fsProxy then
            local disklevel = system.getDiskLevel(fsProxy.address)
            if fsProxy.cloud then
                icon = liked.findIcon("cloud")
            elseif fsProxy.public then
                icon = liked.findIcon("publicStorage")
            elseif disklevel == "tmp" then
                icon = liked.findIcon("tmp")
            elseif disklevel == "fdd" then
                if fsProxy.exists("/init.lua") then
                    icon = liked.findIcon("bootdevice")
                else
                    icon = liked.findIcon("fdd")
                end
            elseif disklevel == "raid" then
                icon = liked.findIcon("raid")
            elseif disklevel == "tier1" then
                icon = liked.findIcon("hdd1")
            elseif disklevel == "tier2" then
                icon = liked.findIcon("hdd2")
            elseif disklevel == "tier3" then
                icon = liked.findIcon("hdd3")
            else
                icon = liked.findIcon("hdd")
            end
        end

        local iconpath = paths.concat(path, "icon.t2p")
        if fs.exists(iconpath) and not fs.isDirectory(iconpath) then
            icon = iconpath
        elseif not fsProxy then
            if exp == "app" then
                icon = liked.findIcon("app")
            else
                icon = liked.findIcon("folder")
            end
        end
    else
        if exp == "t2p" then
            if path then
                local ok, sx, sy = pcall(image.size, path)
                if ok and sx == 8 and sy == 4 then
                    icon = path
                else
                    icon = liked.findIcon("t2p")
                end
            else
                icon = liked.findIcon("t2p")
            end
        elseif exp and #exp > 0 then
            icon = liked.findIcon(exp)
            if not icon then
                icon = liked.findIcon("unknown")
            end
        else
            icon = liked.findIcon("file")
        end
    end

    if not icon or not fs.exists(icon) then
        icon = liked.findIcon("unknown")
    end

    local ok, sx, sy = pcall(image.size, icon)
    if not ok or sx ~= 8 or sy ~= 4 then
        icon = nil
    end

    if not icon or not fs.exists(icon) then
        icon = liked.findIcon("badicon")
    end

    cache.cache.getIcon[path] = icon
    return icon
end

function liked.getBaseWallpaperColor()
    local baseColor = colors.lightBlue
    if registry.wallpaperBaseColor then
        if type(registry.wallpaperBaseColor) == "string" then
            baseColor = colors[registry.wallpaperBaseColor]
        elseif type(registry.wallpaperBaseColor) == "number" then
            baseColor = registry.wallpaperBaseColor
        end
    end
    return baseColor
end

local function demoTitle(screen, gpu)
    if registry.demoMode then
        local rx, ry = gpu.getResolution()
        if liked.recoveryMode then
            gpu.set(2, ry - 3, "a demo version is likeOS")
            gpu.set(2, ry - 2, "some functions may be disabled")
        else
            gui.drawtext(screen, 2, ry - 3, liked.colors.white, "a demo version is likeOS")
            gui.drawtext(screen, 2, ry - 2, liked.colors.white, "some functions may be disabled")
        end
    end
end

function liked.drawWallpaper(screen, customFolder)
    local gpu = graphic.findGpu(screen)
    local rx, ry = gpu.getResolution()

    if liked.recoveryMode then
        gpu.setBackground(liked.colors.black)
        gpu.setForeground(liked.colors.white)
        gpu.fill(1, 1, rx, ry, " ")
        gpu.set(rx - 14, ry - 2, "Recovery mode")
        demoTitle(screen, gpu)
        return
    end

    local baseColor = liked.getBaseWallpaperColor()
    
    gpu.setBackground(colorlib.colorMul(baseColor, registry.wallpaperLight or 1))
    gpu.fill(1, 1, rx, ry, " ")

    local function wdraw(path)
        local ok, sx, sy = pcall(image.size, path)
        if ok then
            local ix, iy = math.round((rx / 2) - (sx / 2)) + 1, math.round((ry / 2) - (sy / 2)) + 1
            pcall(image.draw, screen, path, ix, iy, nil, nil, registry.wallpaperLight)
        end
    end

    local wallpaperPath = "/data/wallpaper.t2p"
    if fs.exists(wallpaperPath) then
        wdraw(wallpaperPath)
    end

    demoTitle(screen, gpu)

    --[[ обои для папок были отключены, потому что это не совмем безопастно и в теории позволит сделать папку в которую нельзя будет зайти
    local customPath = paths.concat(customFolder or paths.path(wallpaperPath), paths.name(wallpaperPath))
    if fs.exists(customPath) then
        wdraw(customPath)
    elseif fs.exists(wallpaperPath) then
        wdraw(wallpaperPath)
    end
    ]]
end

function liked.minRamForDBuff()
    local kb = 512
    for _ in component.list("screen") do
        kb = kb + 512
    end
    return kb
end

function liked.isRealKeyboards(screen)
    for i, address in ipairs(lastinfo.keyboards[screen]) do
        if not vcomponent.isVirtual(address) then
            return true
        end
    end
    return false
end

-------------------------------------------------------- simple api

liked.regBar = liked.drawFullUpBarTask

function liked.regExit(screen, close, closeButton, enterAlias)
    local baseTh = thread.current()
    
    thread.listen("close", function (_, uuid)
        if uuid == screen then
            if close then
                close()
            else
                baseTh:kill()
            end
        end
    end)

    if enterAlias then
        thread.listen("key_down", function (_, uuid, code1, code2)
            if table.exists(lastinfo.keyboards[screen], uuid) and code1 == 13 and code2 == 28 then
                if close then
                    close()
                else
                    baseTh:kill()
                end
            end
        end)
    end

    if closeButton then
        thread.listen("touch", function (_, uuid, px, py)
            if uuid == screen then
                local rx, ry = graphic.getResolution(screen)
                if py == 1 and px >= rx - 2 then
                    if close then
                        close()
                    else
                        baseTh:kill()
                    end
                end
            end
        end)
    end
end

--------------------------------------------------------

package.attachFunctionFolder(liked, "funcs")
liked.unloadable = true
return likedsystem/lib/palette.lua 2017 local fs = require("filesystem")
local graphic = require("graphic")
local serialization = require("serialization")
local sysinit = require("sysinit")
local registry = require("registry")
local palette = {}

function palette.save(screen)
    return graphic.getPalette(screen, true)
end

function palette.set(screen, pal)
    graphic.setPalette(screen, pal, true)
end

function palette.fromFile(screen, path, noReg)
    if noReg then
        local pal = assert(serialization.load(path))
        graphic.setPalette(screen, pal)
    else
        pcall(sysinit.applyPalette, path, screen)
    end
end

function palette.system(screen, noReg)
    palette.fromFile(screen, sysinit.initPalPath, noReg)
end

function palette.blackWhite(screen, noReg)
    palette.fromFile(screen, "/system/t3default.plt", noReg)
end

function palette.setDefaultPalette(screen, noReg)
    local depth = graphic.getDepth(screen)
    if depth == 8 then
        palette.fromFile(screen, "/system/t3default.plt", noReg)
    elseif depth == 4 then
        palette.fromFile(screen, "/system/palettes/original.plt", noReg)
    end
end

function palette.setSystemPalette(path, regOnly, doNotOffScreen)
    if pcall(sysinit.applyPalette, path, regOnly, doNotOffScreen) then
        pcall(fs.copy, path, sysinit.initPalPath)
    else
        pcall(fs.copy, sysinit.defaultPalettePath, sysinit.initPalPath)
        sysinit.applyPalette(sysinit.defaultPalettePath, regOnly, doNotOffScreen)
    end
end

function palette.reBaseColor(palPath)
    if registry.wallpaperBaseColor then
        local oldPal = require("gui_container").indexsColors
        local newPal = serialization.load(palPath)

        if newPal then
            local index = table.find(oldPal, registry.wallpaperBaseColor)
            if index then
                local newColor = newPal[index]
                if newColor then
                    registry.wallpaperBaseColor = newColor
                end
            end
        end
    end
end

palette.unloadable = true
return palettesystem/lib/screensaver.lua 1993 local fs = require("filesystem")
local thread = require("thread")
local event = require("event")
local graphic = require("graphic")
local programs = require("programs")
local logs = require("logs")
local cache = require("cache")
local screensaver = {}

cache.static.screensaver_enabled = cache.static.screensaver_enabled or {}
cache.static.screensaver_current = cache.static.screensaver_current or {}

function screensaver.isEnabled(screen)
    return cache.static.screensaver_enabled[screen] == true or cache.static.screensaver_enabled[screen] == nil
end

function screensaver.setEnabled(screen, state)
    cache.static.screensaver_enabled[screen] = not not state
end


function screensaver.current(screen)
    return cache.static.screensaver_current[screen]
end

function screensaver.start(screen, path)
    local lpath = path or require("gui_container").screenSaverPath
    if lpath and fs.exists(lpath) then
        local clear = graphic.screenshot(screen)
        local th = thread.createBackground(logs.check(programs.load(lpath)) or function() end, screen)
        th.parentData.screen = screen
        th:resume()
        event.yield()
        event.listen(nil, function (eventName, uuid)
            if uuid == screen and (eventName == "touch" or eventName == "drag" or eventName == "scroll") then
                cache.static.screensaver_current[screen] = nil
                th:kill()
                clear()
                return false
            end
        end)
        cache.static.screensaver_current[screen] = th
    end
end

function screensaver.waitStart(screen, path)
    screensaver.start(screen, path)
    while screensaver.current(screen) do
        event.sleep()
    end
end

function screensaver.noScreensaver(screen)
    local oldScreenSaverState = screensaver.isEnabled(screen)
    screensaver.setEnabled(screen, false)
    return function ()
        screensaver.setEnabled(screen, oldScreenSaverState)
    end
end

screensaver.unloadable = true
return screensaversystem/lib/sound.lua 2173 local computer = require("computer")
local component = require("component")
local thread = require("thread")
local registry = require("registry")
local sound = {}

local iters = {}
local noiseChannelNums = {}
local function componentCoroutine(ctype)
    if iters[ctype] then
        local result = iters[ctype]()
        if result then
            return result
        end
    end

    iters[ctype] = component.list(ctype, true)
    if iters[ctype] then
        return (iters[ctype]())
    end
end

function sound.beep(freq, delay, blocked)
    if registry.fullBeepDisable then
        return
    end

    freq = freq or 440
    delay = delay or 0.1

    local function wait()
        if blocked then
            os.sleep(delay + 0.1)
        end
    end

    local beep = componentCoroutine("beep")
    if beep then
        component.invoke(beep, "beep", {[freq] = delay})
        wait()
    else
        local noise = componentCoroutine("noise")
        if noise then
            local channel = noiseChannelNums[noise] or 1
            component.invoke(noise, "setMode", channel, 1)
            component.invoke(noise, "add", channel, freq, delay)
            component.invoke(noise, "process")
            noiseChannelNums[noise] = channel + 1
            if noiseChannelNums[noise] > 8 then
                noiseChannelNums[noise] = 1
            end
            wait()
        else
            computer.beep(freq, delay)
        end
    end
end

------ sounds

local rawSounds = {}

function rawSounds.warn()
    sound.beep(100, 0.1, true)
    sound.beep(100, 0.1)
end

function rawSounds.done()
    sound.beep(1800, 0.05, true)
    sound.beep(1800, 0.05)
end

function rawSounds.lowPower()
    sound.beep(200, 0.1, true)
    sound.beep(200, 0.1, true)
    sound.beep(200, 1)
end

function rawSounds.question()
    sound.beep(2000, 0.1)
end

function rawSounds.input()
    sound.beep(2000, 0.1, true)
    sound.beep(1500, 0.1)
end



for name, func in pairs(rawSounds) do
    sound[name] = function()
        if not registry.fullBeepDisable then
            thread.createBackground(func):resume()
        end
    end
end

------

sound.unloadable = true
return soundsystem/lib/storage.lua 664 local registry = require("registry")
local serialization = require("serialization")
local paths = require("paths")
local system = require("system")
local fs = require("filesystem")
local storage = {}

function storage.getLang()
    local lang = registry.lang or "eng"
    local path = system.getResourcePath(paths.concat("lang", lang .. ".lang"))
    if fs.exists(path) then
        return path
    end

    path = system.getResourcePath("lang/eng.lang")
    if fs.exists(path) then
        return path
    end
end

function storage.getConf(default)
    return registry.new(system.getResourcePath("data.cfg"), default)
end

storage.unloadable = true
return storagesystem/lib/sysinit.lua 13070 local sysinit = {}
sysinit.screenThreads = {}
sysinit.initedScreens = {}
sysinit.defaultPalettePath = "/system/palettes/light.plt"

function sysinit.applyPalette(path, screen, doNotOffScreen)
    local fs = require("filesystem")
    local serialization = require("serialization")
    local component  = require("component")
    local graphic = require("graphic")
    local gui_container = require("gui_container")
    local registry = require("registry")

    local colors = assert(serialization.load(path))

    local function movetable(maintable, newtable)
        for k, v in pairs(maintable) do
            maintable[k] = nil
        end
        for k, v in pairs(newtable) do
            maintable[k] = v
        end
    end

    local t3default = colors.t3default
    colors.t3default = nil

    if registry.visionProtection then
        local colorlib = require("colors")
        local format = require("format")
        
        for i, v in ipairs(colors) do
            colors[i] = format.visionProtectionConvert(v)
        end
    end

    movetable(gui_container.indexsColors, colors)
    movetable(gui_container.colors, {
        white     = colors[1],
        orange    = colors[2],
        magenta   = colors[3],
        lightBlue = colors[4],
        yellow    = colors[5],
        lime      = colors[6],
        pink      = colors[7],
        gray      = colors[8],
        lightGray = colors[9],
        cyan      = colors[10],
        purple    = colors[11],
        blue      = colors[12],
        brown     = colors[13],
        green     = colors[14],
        red       = colors[15],
        black     = colors[16]
    })

    if screen ~= true then
        local blackWhile
        local function applyOnScreen(address)
            if graphic.maxDepth(address) ~= 1 then
                if not doNotOffScreen then pcall(component.invoke, address, "turnOff") end
                if t3default and graphic.getDepth(address) == 8 then
                    graphic.fakePalette = table.low(colors)
                    if not blackWhile then
                        blackWhile = assert(serialization.load("/system/t3default.plt"))
                    end
                    graphic.setPalette(address, blackWhile)
                else
                    graphic.fakePalette = nil
                    graphic.setPalette(address, colors)
                end
                if not doNotOffScreen then pcall(component.invoke, address, "turnOn") end
            end
        end

        if screen then
            applyOnScreen(screen)
        else
            for address in component.list("screen") do
                applyOnScreen(address)
            end
        end
    end
end

function sysinit.getResolution(screen)
    local graphic = require("graphic")
    local mx, my = graphic.maxResolution(screen)
    if mx and (mx > 80 or my > 25) then
        mx = 80
        my = 25
    end
    return mx, my
end

function sysinit.generatePrimaryScreen()
    local lastinfo = require("lastinfo")
    local screen
    local screenValue

    local component = require("component")
    for address in component.list("screen", true) do
        local x, y = component.invoke(address, "getAspectRatio")
        local value = x * y
        if #lastinfo.keyboards[address] == 0 then
            value = 0
        end
        if not screenValue or value > screenValue then
            screen = address
            screenValue = value
        end
    end

    return screen
end

function sysinit.initScreen(screen)
    local graphic = require("graphic")
    local component = require("component")
    local event = require("event")
    local lastinfo = require("lastinfo")
    
    pcall(component.invoke, screen, "turnOff")
    if graphic.isAvailable(screen) then
        -- resolution & depth
        graphic.setDepth(screen, graphic.maxDepth(screen))
        graphic.setResolution(screen, sysinit.getResolution(screen))

        -- clear
        graphic.setPaletteColor(15, 0)
        graphic.clear(screen, 15, true)
        graphic.forceUpdate(screen)

        -- palette
        sysinit.applyPalette(sysinit.initPalPath, screen, true)

        -- show
        graphic.clear(screen, 0x000000)
        graphic.forceUpdate(screen)
        pcall(component.invoke, screen, "turnOn")
    end

    if not sysinit.initedScreens[screen] then
        event.listen("key_down", function(_, uuid, c1, c2, nickname)
            if not lastinfo.keyboards[screen] then
                sysinit.initedScreens[screen] = nil
                return false
            end

            if table.exists(lastinfo.keyboards[screen], uuid) and c1 == 23 and c2 == 17 then
                event.push("close", screen, nickname)
            end
        end)

        sysinit.initedScreens[screen] = true
    end
end

function sysinit.runShell(screen, customShell)
    local graphic = require("graphic")
    if not graphic.isAvailable(screen) then
        return
    end

    local thread = require("thread")
    local registry = require("registry")
    local apps = require("apps")
    local bootloader = require("bootloader")

    sysinit.initScreen(screen)
    if sysinit.screenThreads[screen] then
        sysinit.screenThreads[screen]:kill()
    end
    
    local shellName = "shell"
    if customShell then
        shellName = customShell
    elseif registry.data.shell and registry.data.shell[screen] then
        shellName = registry.data.shell[screen]
    end

    local env = bootloader.createEnv()
    env.shellMode = true
    local t = thread.create(assert(apps.load(shellName, screen, nil, env)))
    t.parentData.screen = screen
    t:resume() --поток по умалчанию спит

    sysinit.screenThreads[screen] = t
end

function sysinit.init(box, lscreen)
    local fs = require("filesystem")
    _G._OSVERSION = "liked-v" .. assert(fs.readFile("/system/version.cfg"))
    require("calls") --подгрузка лютай легаси дичи
    local bootloader = require("bootloader")
    bootloader.runlevel = "user"

    if lscreen and bootloader.recoveryApi then
        bootloader.recoveryApi.offScreens()
    end

    local graphic = require("graphic")
    local programs = require("programs")
    local component = require("component")
    local package = require("package")
    local registry = require("registry")

    table.insert(package.paths, "/system/likedlib")
    table.insert(programs.paths, "/data/apps")
    table.insert(programs.paths, "/system/apps")
    table.insert(programs.paths, "/vendor/apps")

    ------------------------------------

    if not lscreen then
        if not registry.primaryScreen or not component.isConnected(registry.primaryScreen) then
            registry.primaryScreen = sysinit.generatePrimaryScreen()
        end
        component.setPrimary("screen", registry.primaryScreen)
    end

    ------------------------------------

    local screens = {}
    local minDepth = math.huge
    local maxDepth = 0
    local screensCount = 0
    local hardwareBufferAvailable = false
    for address in component.list("screen") do
        local gpu = graphic.findGpu(address)
        if gpu then
            if gpu.setActiveBuffer then
                hardwareBufferAvailable = true
                if gpu.getActiveBuffer() ~= 0 then
                    gpu.setActiveBuffer(0)
                end
            end
            local depth = gpu.maxDepth()
            if gpu then
                table.insert(screens, address)
                maxDepth = math.max(maxDepth, depth)
                minDepth = math.min(minDepth, depth)
            end
            screensCount = screensCount + 1
        end
    end
    minDepth = math.round(minDepth)
    maxDepth = math.round(maxDepth)

    ------------------------------------

    if box or lscreen then
        if lscreen then
            sysinit.initPalPath = "/system/palettes/original.plt"
        else
            sysinit.initPalPath = "/system/palette.plt"
        end
        sysinit.applyPalette(sysinit.initPalPath, true)
    else
        sysinit.initPalPath = "/data/palette.plt"

        if fs.exists(sysinit.initPalPath) then
            sysinit.applyPalette(sysinit.initPalPath, true)
        else
            local palette = require("palette")
            if minDepth == 1 then
                palette.setSystemPalette("/system/palettes/original.plt", true)
            else
                palette.setSystemPalette(sysinit.defaultPalettePath, true)
            end
        end
    end

    local gui_container = require("gui_container")
    local gui = require("gui") --нужно подключить заранию чтобы функции записались в calls.loaded

    package.hardAutoUnloading = true
    if package.isInstalled("sysmode") then
        require("sysmode").init()
    end

    local thread = require("thread")
    local liked = require("liked")
    local apps = require("apps")
    local event = require("event")
    local system = require("system")
    local computer = require("computer")

    local devicetype = system.getDeviceType()
    local isTablet = devicetype == "tablet"
    
    ------------------------------------

    if not box and not registry.wallpaperBaseColor then
        if minDepth == 1 then
            registry.wallpaperBaseColor = "black"
        else
            registry.wallpaperBaseColor = "lightBlue"
        end
    end

    ------------------------------------

    if not registry.powerMode then
        if isTablet and not box then
            registry.powerMode = "energy saving"
        else
            registry.powerMode = "power"
        end
    end
    liked.applyPowerMode()

    ------------------------------------

    local minDbuffRam = liked.minRamForDBuff() * 1024
    if not registry.bufferType then
        if not box and screensCount <= 2 and computer.totalMemory() >= minDbuffRam then
            registry.bufferType = "software"
        elseif not box and hardwareBufferAvailable then
            registry.bufferType = "hardware"
        else
            registry.bufferType = "none"
        end
    elseif registry.bufferType == "software" and computer.totalMemory() < minDbuffRam then
        registry.bufferType = "none"
    end
    liked.applyBufferType()

    ------------------------------------

    if not box and not fs.exists(gui_container.screenSaverPath) and not registry.screenSaverDefaultSetted then
        if isTablet then
            pcall(fs.copy, registry.defaultScreenSaverPath or "/system/screenSavers/black_screen.scrsv", gui_container.screenSaverPath)
        else
            pcall(fs.copy, registry.defaultScreenSaverPath or "/system/screenSavers/color_dots.scrsv", gui_container.screenSaverPath)
        end
        registry.defaultScreenSaverPath = nil
        registry.screenSaverDefaultSetted = true
    end

    ------------------------------------

    if not registry.shadowType then
        registry.shadowMode = "full"
        if minDepth == 4 then
            registry.shadowType = "smart"
        elseif minDepth == 8 then
            registry.shadowType = "advanced"
        else
            registry.shadowType = "none"
        end
    end

    ------------------------------------

    liked.applyBeepState()
    liked.applyTimeZone()
    gui_container.refresh()

    ------------------------------------

    if not liked.recoveryMode then
        bootloader.unittests("/vendor/unittests")
        bootloader.unittests("/data/unittests")

        bootloader.autorunsIn("/vendor/autoruns")
        bootloader.autorunsIn("/data/autoruns")

        require("autorun").autorun()
    end
    
    if programs.find("preinit") then
        apps.execute("preinit")
    end

    ------------------------------------

    if lscreen then
        sysinit.runShell(lscreen)
    else
        sysinit.runShell(registry.primaryScreen)
        for index, address in ipairs(screens) do
            if registry.primaryScreen ~= address then
                sysinit.runShell(address)
            end
        end
    end

    event.hyperListen(function (eventType, cuuid, ctype)
        if ctype == "screen" then
            if eventType == "component_added" then
                if not liked.recoveryMode and not sysinit.screenThreads[cuuid] then
                    sysinit.runShell(cuuid)
                end
            elseif eventType == "component_removed" then
                if sysinit.screenThreads[cuuid] then
                    sysinit.screenThreads[cuuid]:kill()
                    sysinit.screenThreads[cuuid] = nil
                end
            end
        end
    end)

    thread.create(function ()
        while true do
            for screen, th in pairs(sysinit.screenThreads) do
                if th:status() == "dead" then
                    th:kill()
                    sysinit.runShell(screen)
                end
            end
            os.sleep(1)
        end
    end):resume()

    sysinit.init = nil
    sysinit.inited = true
    event.timer(1, function ()
        sysinit.full = true
    end)
end

return sysinitsystem/lib/uix.lua 35822 local unicode = require("unicode")
local gui_container = require("gui_container")
local gui = require("gui")
local graphic = require("graphic")
local liked = require("liked")
local thread = require("thread")
local event = require("event")
local image = require("image")
local system = require("system")
local colorslib = require("colors")
local paths = require("paths")
local apps = require("apps")
local lastinfo = require("lastinfo")

local colors = gui_container.colors
local uix = {colors = colors}
uix.styles = {
    "round",
    "square"
}

---------------------------------- canvas

local canvasClass = {}

function canvasClass:onCreate(sx, sy, back, fore, char)
    self.back = back or colors.black
    self.fore = fore or colors.white
    self.char = char or " "
    self.sx = sx
    self.sy = sy
end

function canvasClass:onDraw()
    self.drawed = true
    if self.screenshot then
        self.screenshot()
        self.screenshot = nil
    else
        self.gui.window:fill(self.x, self.y, self.sx, self.sy, self.back, self.fore, self.char)
    end
end



function canvasClass:set(x, y, back, fore, text, vertical)
    if vertical then
        if x < 1 or x > self.sx then return end
        while y < 1 do
            y = y + 1
            text = unicode.sub(text, 2, unicode.len(text))
        end
        while y + (unicode.len(text) - 1) > self.sy do
            y = y - 1
            text = unicode.sub(text, 1, unicode.len(text) - 1)
        end
    else
        if y < 1 or y > self.sy then return end
        while x < 1 do
            x = x + 1
            text = unicode.sub(text, 2, unicode.len(text))
        end
        while x + (unicode.len(text) - 1) > self.sx do
            x = x - 1
            text = unicode.sub(text, 1, unicode.len(text) - 1)
        end
    end
    self.gui.window:set(self.x + (x - 1), self.y + (y - 1), back or self.back, fore or self.fore, text, vertical)
end

function canvasClass:fill(x, y, sx, sy, back, fore, text)
    self.gui.window:fill(self.x + (x - 1), self.y + (y - 1), sx, sy, back or self.back, fore or self.fore, text)
end

function canvasClass:centerText(x, y, back, fore, text, vertical)
    local offset = math.round(unicode.len(text) / 2) - 1
    if offset < 0 then offset = 0 end
    local offsetX, offsetY = offset, 0
    if vertical then
        offsetX, offsetY = offsetY, offsetX
    end
    self:set(x - offsetX, y - offsetY, back, fore, text, vertical)
end

function canvasClass:clear(color)
    self:fill(1, 1, self.sx, self.sy, color, 0, " ")
end

function canvasClass:stop()
    if self.drawed then
        local x, y = self.gui.window:toRealPos(self.x, self.y)
        self.screenshot = graphic.screenshot(self.gui.screen, x, y, self.sx, self.sy)
        self.drawed = nil
    end
end

function canvasClass:beforeRedraw()
    if self.drawed then
        local x, y = self.gui.window:toRealPos(self.x, self.y)
        self.screenshot = graphic.screenshot(self.gui.screen, x, y, self.sx, self.sy)
    end
end

---------------------------------- obj class

local objclass = {}

function objclass:destroy()
    if self.onDestroy then
        self:onDestroy()
    end
    
    for i = #self.gui.objs, 1, -1 do
        if self.gui.objs[i] == self then
            table.remove(self.gui.objs, i)
        end
    end
end

function objclass:stop()
    if self.type == "context" then
        self.state = false
        if self.th then
            self.th:kill()
            self.th = nil
        end
    elseif self.type == "button" then
        if not self.toggle then
            if self.state then
                self.state = false
                if self.onDrop then
                    self:onDrop()
                end
            end
        end
    elseif self.type == "input" then
        self.read.setDrawLock(true)
    end
end

function objclass:uploadEvent(eventData)
    if self.disabled or self.disabledHidden then return end
    local retval
    if self.type == "button" or self.type == "context" then
        if self.toggle then
            if eventData[1] == "touch" and eventData[3] >= self.x and eventData[4] >= self.y and eventData[3] < self.x + self.sx and eventData[4] < self.y + self.sy then
                self.state = not self.state
                self:draw()
                if self.onSwitch then
                    self:onSwitch(eventData[5], eventData[6], eventData)
                end
            end
        else
            if self.state and (eventData[1] == "touch" or eventData[1] == "drop") then
                if self.type ~= "context" and not self.autoRelease then
                    self.state = false
                    self:draw()

                    if self.onDrop then
                        retval = self:onDrop(eventData[5], eventData[6], eventData)
                    end
                end
            elseif not self.state and eventData[1] == "touch" and eventData[3] >= self.x and eventData[4] >= self.y and eventData[3] < self.x + self.sx and eventData[4] < self.y + self.sy then
                if self.type == "context" then
                    self.state = true
                    self:draw()

                    if not self.th then
                        self.th = thread.create(function ()
                            local x, y = self.gui.window:toRealPos(self.x + 1, self.y + 1)
                            local px, py, sx, sy = gui.contextPos(self.gui.window.screen, x, y, gui.contextStrs(self.strs))
                            local clear = graphic.screenshot(self.gui.window.screen, px, py, sx + 2, sy + 1)
                            local oldControlLock = self.gui.controlLock
                            self.gui.controlLock = true
                            local _, num = gui.context(self.gui.window.screen, px, py, self.strs, self.actives)
                            self.gui.controlLock = oldControlLock
                            clear()
                            if num and self.funcs[num] then
                                self.funcs[num]()
                            end

                            self.state = false
                            self:draw()

                            self.th:suspend()
                            self.th = nil
                        end)
                        self.th:resume()
                    end
                else
                    self.state = true
                    self:draw()
                    graphic.forceUpdate(self.gui.window.screen)
                    if self.autoRelease then
                        if self.noDropDraw then
                            self.state = false
                        else
                            os.sleep(0.1)
                            self.state = false
                            self:draw()
                            graphic.forceUpdate(self.gui.window.screen)
                        end
                    end
                    
                    if self.onClick then
                        retval = self:onClick(eventData[5], eventData[6], eventData)
                    end
                end
            end
        end
    elseif self.type == "big_switch" then
        if eventData[1] == "touch" and eventData[3] >= self.x and eventData[3] < self.x + self.sizeX and eventData[4] >= self.y and eventData[4] < self.y + self.sizeY then
            self.state = not self.state
            self:draw()

            if self.onSwitch then
                self:onSwitch(eventData[5], eventData[6], eventData)
            end
        end
    elseif self.type == "switch" then
        local size = self.checkbox and 2 or 6
        if eventData[1] == "touch" and eventData[3] >= self.x and eventData[3] < self.x + size and eventData[4] == self.y then
            self.state = not self.state
            self:draw()

            if self.onSwitch then
                self:onSwitch(eventData[5], eventData[6], eventData)
            end
        end
    elseif self.type == "input" then
        local str = self.read.uploadEvent(eventData)
        if str then
            if self.onTextAccepted then
                self:onTextAccepted(str)
            end
        end

        local text = self.read.getBuffer()
        if text ~= self.oldText then
            self.oldText = text
            if self.onTextChanged then
                self:onTextChanged(text)
            end
        end
    elseif self.type == "up" then
        if self.gui.returnLayout then
            local _, py = self.gui.window:toFakePos(1, 1)
            if eventData[1] == "touch" and eventData[3] >= 1 and eventData[3] <= 3 and eventData[4] == py then
                if type(self.gui.returnLayout) == "function" then
                    self.gui.returnLayout()
                else
                    self.gui.returnLayout:select()
                end
            end
        end
    elseif self.type == "seek" then
        local function doSeek(oldValue, isTouch)
            if self.value < 0 then self.value = 0 end
            if self.value > 1 then self.value = 1 end
            if self.onSeek then
                self:onSeek(self.value, oldValue, isTouch)
            end
            self:draw()
        end

        if eventData[1] == "scroll" then
            if self.vertical then
                if self.globalScroll or (eventData[3] == self.x and eventData[4] >= self.y and eventData[4] < self.y + self.size) then
                    local oldValue = self.value
                    self.value = self.value - (eventData[5] / self.size)
                    doSeek(oldValue)
                end
            else
                if self.globalScroll or (eventData[4] == self.y and eventData[3] >= self.x and eventData[3] < self.x + self.size) then
                    local oldValue = self.value
                    self.value = self.value + (eventData[5] / self.size)
                    doSeek(oldValue)
                end
            end
        else
            if self.vertical then
                if eventData[1] == "touch" and eventData[3] == self.x and eventData[4] >= self.y and eventData[4] < self.y + self.size then
                    self.focus = true
                elseif eventData[1] == "drop" or eventData[1] == "touch" then
                    self.focus = false
                end
            else
                if eventData[1] == "touch" and eventData[4] == self.y and eventData[3] >= self.x and eventData[3] < self.x + self.size then
                    self.focus = true
                elseif eventData[1] == "drop" or eventData[1] == "touch" then
                    self.focus = false
                end
            end
            if (eventData[1] == "touch" or eventData[1] == "drag") and self.focus then
                local oldValue = self.value
                if self.vertical then
                    self.value = (eventData[4] - self.y) / (self.size - 1)
                else
                    self.value = (eventData[3] - self.x) / (self.size - 1)
                end
                doSeek(oldValue, true)
            end
        end
    end
    return retval
end

function objclass:draw()
    if self.hidden or self.disabledHidden then return end
    local style = self.style or self.gui.style
    if self.type == "label" or self.type == "button" or self.type == "context" then
        local back, fore = self.back, self.fore
        if self.state then
            back, fore = self.back2 or back, self.fore2 or fore
        end

        local x, y, sx, sy = self.x, self.y, self.sx, self.sy
        
        local maxtextsize = self.sx
        local isRound = self.sy == 1 and style == "round"
        if isRound then
            maxtextsize = maxtextsize - 2
            local _, _, bg = self.gui.window:get(x, y)
            self.gui.window:fill(x + 1, y, sx - 2, sy, back, 0, " ")
            self.gui.window:set(x, y, bg, back, "◖")
            self.gui.window:set(x + (sx - 1), y, bg, back, "◗")
        else
            self.gui.window:fill(x, y, sx, sy, back, 0, " ")
        end

        if self.text then
            local dtext = self.text
            local dlen = unicode.len(self.text)
            if self.alignment == "right" then
                if dlen > maxtextsize then
                    dtext = unicode.sub(dtext, 1 + (dlen - maxtextsize), dlen)
                end
            else
                if dlen > maxtextsize then
                    dtext = unicode.sub(dtext, 1, maxtextsize)
                end
            end
            dlen = unicode.len(dtext)

            local tx
            local ty = y + (math.round(sy / 2) - 1)
            if self.alignment == "left" then
                tx = x
                if isRound then
                    tx = tx + 1
                end
            elseif self.alignment == "right" then
                tx = (x + sx) - dlen
                if isRound then
                    tx = tx - 1
                end
            else
                tx = (x + math.round(sx / 2)) - math.round(dlen / 2)
            end

            self.gui.window:set(tx, ty, back, fore, dtext)
        end
    elseif self.type == "switch" then
        local bg = self.state and self.enableColor or self.disableColor
        local _, _, fg = self.gui.window:get(self.x, self.y)

        if self.checkbox then
            if style == "round" then
                self.gui.window:set(self.x, self.y, self.pointerColor, bg, "◖◗")
            else
                self.gui.window:set(self.x, self.y, self.pointerColor, bg, "⠰⠆")
            end
        else
            if style == "round" then
                self.gui.window:set(self.x, self.y, fg, bg, "◖████◗")
                if self.state then
                    self.gui.window:set(self.x + 3, self.y, bg, self.pointerColor, "◖█")
                    self.gui.window:set(self.x + 5, self.y, fg, self.pointerColor, "◗")
                else
                    self.gui.window:set(self.x, self.y, fg, self.pointerColor, "◖")
                    self.gui.window:set(self.x + 1, self.y, bg, self.pointerColor, "█◗")
                end
            else
                self.gui.window:set(self.x, self.y, fg, bg, "██████")
                if self.state then
                    self.gui.window:set(self.x + 3, self.y, bg, self.pointerColor, "███")
                else
                    self.gui.window:set(self.x, self.y, fg, self.pointerColor, "███")
                end
            end
        end
    elseif self.type == "big_switch" then
        self.gui.window:fill(self.x, self.y, self.sizeX, self.sizeY, self.color, 0, " ")
        local x, y = self.gui.window:toRealPos(self.x, self.y)
        image.draw(self.gui.window.screen, self.state and "/system/images/switch_on.t2p" or "/system/images/switch_off.t2p", x, y, true)
    elseif self.type == "text" then
        if self.text then
            local _, _, bg = self.gui.window:get(self.x, self.y)
            self.gui.window:set(self.x, self.y, bg, self.color, self.text)
        end
    elseif self.type == "input" then
        local _, _, bg = self.gui.window:get(self.x, self.y)
        if style == "round" then
            self.gui.window:set(self.x, self.y, bg, self.back, "◖")
            self.gui.window:set(self.x + (self.sx - 1), self.y, bg, self.back, "◗")
        end
        
        self.read.setDrawLock(false)
        self.read.redraw()
    elseif self.type == "seek" then
        local _, _, bg = self.gui.window:get(self.x, self.y)
        local dotpos = math.round((self.size - 1) * self.value)

        if self.vertical then
            self.gui.window:fill(self.x, self.y, 1, dotpos, bg, self.fillColor, "┃")
            self.gui.window:fill(self.x, self.y + dotpos, 1, self.size - dotpos, bg, self.color, "┃")
            if style == "round" then
                self.gui.window:set(self.x, self.y + dotpos, bg, self.dotcolor, "●")
            else
                self.gui.window:set(self.x, self.y + dotpos, bg, self.dotcolor, "█")
            end
        else
            self.gui.window:fill(self.x, self.y, dotpos, 1, bg, self.fillColor, gui_container.chars.wideSplitLine)
            self.gui.window:fill(self.x + dotpos, self.y, self.size - dotpos, 1, bg, self.color, gui_container.chars.wideSplitLine)
            if style == "round" then
                if dotpos >= self.size - 1 then dotpos = dotpos - 1 end
                self.gui.window:set(self.x + dotpos, self.y, bg, self.dotcolor, "◖◗")
            else
                self.gui.window:set(self.x + dotpos, self.y, bg, self.dotcolor, "█")
            end
        end
    elseif self.type == "up" then
        liked.drawFullUpBar(self.gui.window.screen, (self.gui.returnLayout and "   " or "") .. self.title, self.withoutFill, self.bgcolor, self.wide, true)
        if self.gui.returnLayout then
            local px, py = self.gui.window:toFakePos(1, 1)
            self.gui.window:set(px, py, colors.red, colors.white, " < ")
        end
        liked.upBarShadow(self.gui.window.screen)
    elseif self.type == "plane" then
        self.gui.window:fill(self.x, self.y, self.sx, self.sy, self.color, 0, " ")
    elseif self.type == "image" then
        local x, y = self.gui.window:toRealPos(self.x, self.y)
        image.draw(self.gui.window.screen, self.path, x, y, self.wallpaperMode, self.forceFullColor, self.lightMul, self.imagePaletteUsed, self.blackListedColor, self.newColors)
    elseif self.type == "drawer" then
        self:func(self.gui.window:toRealPos(self.x, self.y))
    elseif self.type == "progress" then
        local _, _, bg = self.gui.window:get(self.x, self.y)
        local pos = math.round(math.map(self.value, 0, 1, 0, self.sx))
        self.gui.window:fill(self.x + pos, self.y, self.sx - pos, 1, bg, self.back, gui_container.chars.splitLine)
        self.gui.window:fill(self.x, self.y, pos, 1, bg, self.fore, gui_container.chars.wideSplitLine)
    end

    if self.postDraw then
        self:postDraw()
    end
end

---------------------------------- base custom class

local baseCustom = {}
baseCustom.destroy = objclass.destroy

function baseCustom:uploadEvent(eventData)
    if self.disabled or self.disabledHidden then return end
    if self.onEvent then
        self:onEvent(eventData)
    end
end

function baseCustom:draw()
    if self.hidden or self.disabledHidden then return end
    if self.onDraw then
        self:onDraw()
    end
end

function baseCustom:stop()
    if self.onStop then
        self:onStop()
    end
end

---------------------------------- layout objects

function uix:createUpBar(title, withoutFill, bgcolor) --working only in fullscreen ui
    local obj = setmetatable({gui = self, type = "up"}, {__index = objclass})
    obj.title = title
    obj.withoutFill = withoutFill
    obj.bgcolor = bgcolor
    obj.wide = true

    local px, py = self.window:toFakePos(self.window.sizeX, 1)
    obj.close = self:createButton(px - 2, py, 3, 1)
    obj.close.hidden = true

    obj.timer = thread.timer(10, function ()
        if self.active then
            obj:draw()
        end
    end, math.huge)

    local destroy = obj.destroy
    function obj:destroy()
        event.cancel(obj.timer)
        destroy(obj)
        obj.close:destroy()
    end

    table.insert(self.objs, obj)
    return obj
end

function uix:createUp(title, withoutFill, bgcolor)
    local upbar = self:createUpBar(title, withoutFill, bgcolor)

    local function onExit()
        if self.smartGuiManager and self.smartGuiManager.onExit then
            self.smartGuiManager:onExit()
        else
            self.smartGuiManager.exitFlag = true
            event.stub()
        end
    end

    --liked.regExit(self.window.screen, onExit)
    upbar.close.onClick = onExit
    return upbar
end
uix.createAutoUpBar = uix.createUp --legacy

function uix:createLabel(x, y, sx, sy, back, fore, text)
    local obj = setmetatable({gui = self, type = "label"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.sx = sx
    obj.sy = sy
    obj.text = text
    uix.doColor(obj, back, fore)
    obj.alignment = "center"
    obj.clamp = true

    table.insert(self.objs, obj)
    return obj
end

function uix:createButton(x, y, sx, sy, back, fore, text, autoRelease)
    local obj = setmetatable({gui = self, type = "button"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.sx = sx
    obj.sy = sy
    obj.text = text
    obj.state = false
    obj.autoRelease = not not autoRelease
    uix.doColor(obj, back, fore)
    obj.back2 = obj.fore
    obj.fore2 = obj.back
    obj.alignment = "center"
    obj.clamp = true
    obj.toggle = false

    table.insert(self.objs, obj)
    return obj
end

function uix:createSwitch(x, y, state, enableColor, disableColor, pointerColor)
    local obj = setmetatable({gui = self, type = "switch"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.state = not not state
    obj.enableColor = enableColor or colors.lime
    obj.disableColor = disableColor or colors.gray
    obj.pointerColor = pointerColor or colors.white

    table.insert(self.objs, obj)
    return obj
end

function uix:createCheckbox(...)
    local obj = self:createSwitch(...)
    obj.checkbox = true
    return obj
end

function uix:createBigSwitch(x, y, state, color)
    local obj = setmetatable({gui = self, type = "big_switch"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.sizeX = 16
    obj.sizeY = 16
    obj.color = color or colors.gray
    obj.state = not not state

    table.insert(self.objs, obj)
    return obj
end

function uix:createText(x, y, color, text)
    local obj = setmetatable({gui = self, type = "text"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.color = color or colors.white
    obj.text = text

    table.insert(self.objs, obj)
    return obj
end

function uix:createVText(x, y, color, text)
    return self:createText(x - (unicode.len(text) // 2), y, color, text)
end

function uix:createInput(x, y, sx, back, fore, testHidden, default, syntax, maxlen, preStr, titleColor, title)
    local obj = setmetatable({gui = self, type = "input"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.sx = sx
    obj.testHidden = testHidden
    obj.default = default
    obj.syntax = syntax
    obj.titleColor = titleColor or colors.lightGray
    obj.title = title
    uix.doColor(obj, back, fore)

    if self.style == "round" then
        obj.read = self.window:readNoDraw(x + 1, y, sx - 2, obj.back, obj.fore, preStr, testHidden, default, true, syntax)
    else
        obj.read = self.window:readNoDraw(x, y, sx, obj.back, obj.fore, preStr, testHidden, default, true, syntax)
    end
    
    obj.oldText = obj.read.getBuffer()
    if maxlen then
        obj.read.setMaxStringLen(maxlen)
    end

    if obj.title then
        obj.read.setTitle(obj.title, obj.titleColor)
    end

    table.insert(self.objs, obj)
    return obj
end

function uix:createSeek(x, y, size, color, fillColor, dotcolor, value, vertical, globalScroll)
    local obj = setmetatable({gui = self, type = "seek"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.size = size
    obj.color = color or colors.lightGray
    obj.fillColor = fillColor or colors.lime
    obj.dotcolor = dotcolor or colors.white
    obj.value = value or 0
    obj.vertical = not not vertical
    obj.globalScroll = not not globalScroll

    table.insert(self.objs, obj)
    return obj
end

function uix:createPlane(x, y, sx, sy, color)
    local obj = setmetatable({gui = self, type = "plane"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.sx = sx
    obj.sy = sy
    obj.color = color or colors.gray

    table.insert(self.objs, obj)
    return obj
end

function uix:createContext(x, y, sx, sy, back, fore, text, strs, funcs, actives)
    local obj = setmetatable({gui = self, type = "context"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.sx = sx
    obj.sy = sy
    obj.back = back or colors.white
    obj.fore = fore or colors.gray
    obj.back2 = obj.fore
    obj.fore2 = obj.back
    obj.text = text
    obj.state = false
    obj.alignment = "center"
    obj.clamp = true

    obj.strs = strs or {}
    obj.funcs = funcs or {}
    obj.actives = actives

    if not obj.actives then
        obj.actives = {}
        for i in ipairs(obj.strs) do
            obj.actives[i] = true
        end
    end

    table.insert(self.objs, obj)
    return obj
end

function uix:createImage(x, y, path, wallpaperMode, forceFullColor)
    local obj = setmetatable({gui = self, type = "image"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.path = system.getResourcePath(path)
    obj.wallpaperMode = not not wallpaperMode
    obj.forceFullColor = not not forceFullColor
    obj.blackListedColor = nil
    obj.newColors = nil
    obj.lightMul = nil
    obj.imagePaletteUsed = nil

    table.insert(self.objs, obj)
    return obj
end

function uix:createDrawer(x, y, func)
    local obj = setmetatable({gui = self, type = "drawer"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.func = func

    table.insert(self.objs, obj)
    return obj
end

function uix:createProgress(x, y, sx, fore, back, value)
    local obj = setmetatable({gui = self, type = "progress"}, {__index = objclass})
    obj.x = x
    obj.y = y
    obj.sx = sx
    obj.fore = fore or colors.lime
    obj.back = back or colors.blue
    obj.value = value or 0

    table.insert(self.objs, obj)
    return obj
end

local function makeMT(cls)
    local mt = getmetatable(cls)
    if mt then
        mt.__index = baseCustom
    else
        setmetatable(cls, {__index = baseCustom})
    end
    return cls
end

function uix:createCustom(x, y, cls, ...)
    local obj = setmetatable({}, {__index = makeMT(cls)})
    obj.destroy = objclass.destroy
    obj.gui = self
    obj.window = self.window
    obj.x = x
    obj.y = y
    obj.args = {...}

    if obj.onCreate then
        obj:onCreate(...)
    end

    table.insert(self.objs, obj)
    return obj
end

function uix:createCanvas(x, y, sx, sy, back, fore, char)
    return self:createCustom(x, y, canvasClass, sx, sy, back, fore, char)
end

function uix:createColorpic(x, y, sx, sy, text, color, full)
    local button = self:createButton(x, y, sx, sy, nil, nil, text, true)

    local function updateColor()
        if color == colors.black then
            color = colors.gray
        end
        
        button.back = color
        button.fore = color == colors.white and colors.black or colors.white
        button.back2 = button.fore
        button.fore2 = button.back
    end
    updateColor()

    function button:setColor(newcolor)
        color = newcolor
        updateColor()
    end

    function button:getColor()
        return color
    end

    local screen = self.screen
    function button:onClick()
        local fcolor, fout
        local clear = gui.saveBigZone(screen)

        if full then
            fout = gui.selectfullcolor(screen, nil, nil, text)
            fcolor = fout
        else
            fout = gui.selectcolor(screen, nil, nil, text)
            if fout and colorslib[fout] and colors[colorslib[fout]] then
                fcolor = colors[colorslib[fout]]
            end
        end
        clear()

        if fcolor then
            self:setColor(fcolor)
            button:draw()
        end

        if fout and self.onColor then
            self:onColor(fout, fcolor)
        end
    end

    return button
end

------------------------------------ layout api

function uix:setReturnLayout(returnLayout)
    self.returnLayout = returnLayout
end

function uix:timer(time, callback, count)
    return thread.timer(time, function (...)
        if not self.bgWork then return end
        return callback(...)
    end, count)
end

function uix:listen(eventType, callback)
    return thread.listen(eventType, function (...)
        if not self.bgWork then return end
        return callback(...)
    end)
end

function uix:thread(func, ...)
    local th = thread.create(func, ...)
    if th then
        table.insert(self.threads, th)
        return th
    end
end

function uix:uploadEvent(eventData)
    if self.controlLock or not self.active then return end

    if not eventData.windowEventData then
        eventData = self.window:uploadEvent(eventData)
    end

    if eventData and table.len(eventData) > 0 then
        if self.onEvent then
            self:onEvent(eventData)
        end

        for _, obj in ipairs(self.objs) do
            if obj.uploadEvent then
                if obj:uploadEvent(eventData) then
                    break
                end
            end
        end
    end

    return eventData
end

function uix:draw()
    if self.allowAutoActive then
        self.allowAutoActive = nil
        self.active = true
    end

    if not self.active then
        return
    end

    for _, obj in ipairs(self.objs) do
        if obj.draw and obj.type == "up" then
            obj:draw()
        end
    end

    for _, obj in ipairs(self.objs) do
        if obj.beforeRedraw then
            obj:beforeRedraw()
        end
    end

    if self.bgcolor then
        self.window:clear(self.bgcolor)
    end

    if self.onRedraw then
        self:onRedraw()
    end

    for _, obj in ipairs(self.objs) do
        if obj.draw then
            obj:draw()
        end
    end
end

function uix:stop()
    for _, obj in ipairs(self.objs) do
        if obj.stop then
            obj:stop()
        end
    end
end

function uix:fullStop()
    self.active = false
    self.bgWork = false
    self:stop()
    for _, th in ipairs(self.threads) do
        th:suspend()
    end
end

function uix:fullStart()
    self.active = true
    self.bgWork = true
    for _, th in ipairs(self.threads) do
        th:resume()
    end
end

function uix:select()
    if self.smartGuiManager then
        self.smartGuiManager:select(self)
    end
end

---------------------------------- uix methods

function uix.getSysImgPath(name)
    return paths.concat("/system/images", name .. ".t2p")
end

function uix.objEvent(self, eventData)
    if eventData and (eventData[1] == "touch" or eventData[1] == "drop" or eventData[1] == "drag" or eventData[1] == "scroll") then
        if eventData[3] >= self.x and eventData[4] >= self.y and eventData[3] < self.x + self.sizeX and eventData[4] < self.y + self.sizeY then
            eventData[3] = (eventData[3] - self.x) + 1
            eventData[4] = (eventData[4] - self.y) + 1

            return eventData
        end
    end
end

function uix.doColor(obj, back, fore)
    obj.back = back or colors.white
    obj.fore = fore
    if not obj.fore then
        if back then
            if back == colors.white then
                obj.fore = colors.black
            else
                obj.fore = colors.white
            end
        else
            obj.fore = colors.gray
        end
    end
end

function uix.create(window, bgcolor, style)
    local guiobj = setmetatable({}, {__index = uix})
    guiobj.window = window
    guiobj.screen = window.screen
    guiobj.style = style or "round"
    guiobj.objs = {}
    guiobj.selected = false
    guiobj.bgcolor = bgcolor
    guiobj.controlLock = false
    guiobj.active = false
    guiobj.bgWork = true
    guiobj.allowAutoActive = true
    guiobj.sizeX = window.sizeX
    guiobj.sizeY = window.sizeY
    guiobj.threads = {}

    return guiobj
end

function uix.createLayout(screen, title, bgcolor, style)
    local window = screen
    if type(screen) == "string" then
        local rx, ry = graphic.getResolution(screen)
        window = graphic.createWindow(screen, 1, 2, rx, ry - 1)
        window.outsideEvents = true
    end

    local layout = uix.create(window, bgcolor or colors.black, style)
    layout:createUp(title or liked.selfApplicationName())
    return layout
end

function uix.createSimpleLayout(screen, bgcolor, style)
    local window = screen
    if type(screen) == "string" then
        local rx, ry = graphic.getResolution(screen)
        window = graphic.createWindow(screen, 1, 1, rx, ry)
    end
    return uix.create(window, bgcolor or colors.black, style)
end

---------------------------------- legacy manager

function uix.createAuto(screen, title, bgcolor, style) --legacy
    local rx, ry = graphic.getResolution(screen)
    local window = graphic.createWindow(screen, 1, 1, rx, ry)

    local layout = uix.create(window, bgcolor or colors.black, style)
    layout:createUp(title)
    return layout
end

function uix.loop(guimanager, layout, func) --legacy manager
    function guimanager.select(newLayout)
        if layout then
            layout.active = false
            layout:stop()
        end
        layout = newLayout
        if layout then
            layout.active = true
        end
        layout:draw()
    end

    layout:draw()
    while true do
        local eventData = {event.pull()}
        layout:uploadEvent(eventData)
        if func then
            func(eventData)
        end
    end
end

---------------------------------- manager

local manager = {}

function manager:fullStop()
    if self.current then
        self.current:fullStop()
    end
end

function manager:fullStart()
    if self.current then
        self.current:fullStart()
    end
end

function manager:execute(...)
    self:fullStop()
    local result = {apps.execute(...)}
    self:fullStart()
    self:draw()
    return table.unpack(result)
end

function manager:select(layout)
    if self.current then
        self.current:fullStop()
    end

    self.current = layout
    if self.current then
        self.current.smartGuiManager = self
        self.current.allowAutoActive = nil
        self.current:fullStart()
        if self.current.onSelect then
            self.current:onSelect()
        end
        self.current:draw()
    end
end

function manager:setExit_ctrlW()
    self.exit_ctrlW = true
end

function manager:setExit_enter()
    self.exit_enter = true
end

function manager:loop(timeout)
    if self.firstLayout and not self.current then
        self:select(self.firstLayout)
    end

    while true do
        local eventData = {event.pull(timeout)}
        local windowEventData
        if self.current and not self.stopUpload then
            windowEventData = self.current:uploadEvent(eventData)
        end

        if self.onEvent then
            self:onEvent(eventData, windowEventData)
        end

        if self.exit_ctrlW and eventData[1] == "close" then
            break
        elseif self.exit_enter and (eventData[1] == "key_down" and table.exists(lastinfo.keyboards[self.screen], eventData[2]) and eventData[3] == 13 and eventData[4] == 28) then
            break
        elseif self.exitFlag then
            break
        end
    end
end

function manager:create(title, bgcolor, style)
    local layout = uix.createLayout(self.window or self.screen, title, bgcolor, style)
    layout.bgWork = false
    layout.allowAutoActive = nil
    if not self.firstLayout then self.firstLayout = layout end
    return layout
end

function manager:simpleCreate(bgcolor, style)
    local layout = uix.createSimpleLayout(self.window or self.screen, bgcolor, style)
    layout.bgWork = false
    layout.allowAutoActive = nil
    if not self.firstLayout then self.firstLayout = layout end
    return layout
end

function manager:size()
    return graphic.getResolution(self.screen)
end

function manager:zoneSize()
    if self.current then
        return self.current.window.sizeX, self.current.window.sizeY
    else
        local x, y = graphic.getResolution(self.screen)
        return x, y - 1
    end
end

function manager:draw()
    if self.current then
        self.current:draw()
    end
end

function uix.manager(screen)
    return setmetatable({screen = screen}, {__index = manager})
end

----------------------------------

uix.unloadable = true
return uixsystem/lib/viewer.lua 938 local uix = require("uix")
local fs = require("filesystem")
local gobjs = require("gobjs")
local viewer = {}

function viewer.license(screen, path)
    local ui = uix.manager(screen)
    local rx, ry = ui:size()
    local ret

    local licenseLayout = ui:simpleCreate(uix.colors.cyan, uix.styles[2])
    licenseLayout:createCustom(3, 2, gobjs.scrolltext, rx - 4, ry - 4, assert(fs.readFile(path)):gsub("\r", ""))

    local back1 = licenseLayout:createButton(3, ry - 1, 8, 1, uix.colors.lightBlue, uix.colors.white, " ← back", true)
    back1.alignment = "left"
    function back1:onClick()
        ret = false
        ui.exitFlag = true
    end

    local next2 = licenseLayout:createButton(rx - 17, ry - 1, 16, 1, uix.colors.lightBlue, uix.colors.white, "accept & next", true)
    function next2:onClick()
        ret = true
        ui.exitFlag = true
    end

    ui:loop()
    return ret
end

viewer.unloadable = true
return viewersystem/lib/vkeyboard.lua 9740 local graphic = require("graphic")
local uix = require("uix")
local event = require("event")
local unicode = require("unicode")
local computer = require("computer")
local lastinfo = require("lastinfo")
local thread = require("thread")
local utils = require("utils")
local vcomponent = require("vcomponent")
local hook = require("hook")
local uuid = require("uuid")
local gui = require("gui")
local vkeyboard = {}

local function postDraw(self)
    local bg = self.state and self.back2 or self.back
    self.gui.window:fill(self.x, self.y, self.sx, 1, uix.colors.lightGray, bg, "⣤")
    self.gui.window:fill(self.x, self.y + (self.sy - 1), self.sx, 1, bg, uix.colors.lightGray, "⣤")
end

function vkeyboard.input(screen, splash, allowActions)
    local rx, ry = graphic.getResolution(screen)
    local window = graphic.createWindow(screen, 5, ry - 18, rx - 8, 18)
    gui.shadow(screen, 5, ry - 18, rx - 8, 18)

    local layout1 = uix.create(window, uix.colors.lightGray, "square")
    local layout2 = uix.create(window, uix.colors.lightGray, "square")
    local layout = layout1

    local function selectLayout(l)
        layout = l
        layout:draw()
    end

    local currentInput, returnVal = ""
    local inputLabel = layout:createLabel(2, 2, window.sizeX - 2, 1, uix.colors.gray, uix.colors.white)
    inputLabel.alignment = "left"
    local function doInput()
        inputLabel.text = (splash or "") .. "> " .. currentInput .. "|"
        inputLabel:draw()
    end
    doInput()

    local esc = layout:createButton(2, 4, 5, 3, uix.colors.red, uix.colors.white, "ESC", true)
    esc.postDraw = postDraw
    function esc:onClick()
        if currentInput == "" then
            returnVal = true
        else
            currentInput = ""
            doInput()
        end
    end

    local back = layout:createButton(window.sizeX - 5, 4, 5, 3, uix.colors.red, uix.colors.white, "<", true)
    back.postDraw = postDraw
    function back:onClick()
        currentInput = unicode.sub(currentInput, 1, unicode.len(currentInput) - 1)
        doInput()
    end

    local enter = layout:createButton(window.sizeX - 16, 4, 10, 3, uix.colors.red, uix.colors.white, "enter", true)
    enter.postDraw = postDraw
    function enter:onClick()
        returnVal = currentInput
    end

    local back = layout:createButton(window.sizeX - 2, 1, 3, 1, uix.colors.red, uix.colors.white, "X", true)
    function back:onClick()
        returnVal = true
    end

    local space = layout:createButton(3, window.sizeY - 1, window.sizeX / 2, 1, uix.colors.blue, uix.colors.white, "⣇" .. ("⣀"):rep(4) .. "⣸", true)
    function space:onClick()
        currentInput = currentInput .. " "
        doInput()
    end

    local upperCase = layout:createCheckbox(40, window.sizeY - 1)
    layout:createText(43, window.sizeY - 1, nil, "Upper Case")

    local function addButton(index, y, char, func, line1)
        local button = layout:createButton(8 + ((index - 1) * 4), (line1 and 2 or 4) + (y * 3), 3, 3, func and uix.colors.green or uix.colors.blue, uix.colors.white, char, true)
        button.postDraw = postDraw
        function button:onClick()
            if func then
                func(self)
            else
                if upperCase.state then
                    currentInput = currentInput .. char:upper()
                else
                    currentInput = currentInput .. char
                end
                doInput()
            end
        end
    end

    for i = 1, 10 do
        local char = i
        if i == 10 then
            char = 0
        end
        char = tostring(char)
        
        addButton(i, 0, char)
    end

    addButton(11, 0, "-")
    addButton(12, 0, "+")

    addButton(0, 1, "q")
    addButton(1, 1, "w")
    addButton(2, 1, "e")
    addButton(3, 1, "r")
    addButton(4, 1, "t")
    addButton(5, 1, "y")
    addButton(6, 1, "u")
    addButton(7, 1, "i")
    addButton(8, 1, "o")
    addButton(9, 1, "p")
    addButton(10, 1, "[")
    addButton(11, 1, "]")
    addButton(12, 1, "{")
    addButton(13, 1, "}")
    addButton(14, 1, "(")
    addButton(15, 1, ")")
    addButton(16, 1, "`")

    addButton(0, 2, "a")
    addButton(1, 2, "s")
    addButton(2, 2, "d")
    addButton(3, 2, "f")
    addButton(4, 2, "g")
    addButton(5, 2, "h")
    addButton(6, 2, "j")
    addButton(7, 2, "k")
    addButton(8, 2, "l")
    addButton(9, 2, ";")
    addButton(10, 2, "'")
    addButton(11, 2, ":")
    addButton(12, 2, "\"")
    addButton(13, 2, "\\")
    addButton(14, 2, "|")
    addButton(15, 2, "/")
    addButton(16, 2, "!")

    addButton(0, 3, "z")
    addButton(1, 3, "x")
    addButton(2, 3, "c")
    addButton(3, 3, "v")
    addButton(4, 3, "b")
    addButton(5, 3, "n")
    addButton(6, 3, "m")
    addButton(7, 3, "<")
    addButton(8, 3, ">")
    addButton(9, 3, "?")
    addButton(10, 3, "@")
    addButton(11, 3, "#")
    addButton(12, 3, "$")
    addButton(13, 3, "%")
    addButton(14, 3, "^")
    addButton(15, 3, "&")
    addButton(16, 3, "*")

    if allowActions then
        addButton(13, 4, "#", function ()
            selectLayout(layout2)
        end)
    end
    addButton(14, 4, "~")
    addButton(15, 4, ",")
    addButton(16, 4, ".")

    layout = layout2

    local back = layout:createButton(window.sizeX - 2, 1, 3, 1, uix.colors.red, uix.colors.white, "X", true)
    function back:onClick()
        selectLayout(layout1)
    end

    addButton(0, 0, "^W", function ()
        returnVal = {23, 17}
    end, true)

    addButton(1, 0, "^A", function ()
        returnVal = {1, 30}
    end, true)

    addButton(2, 0, "^C", function ()
        returnVal = {3, 46}
    end, true)

    addButton(3, 0, "^V", function ()
        returnVal = {22, 47}
    end, true)

    addButton(4, 0, "^X", function ()
        returnVal = {24, 45}
    end, true)

    addButton(5, 0, "^Y", function ()
        returnVal = {25, 21}
    end, true)


    selectLayout(layout1)

    while true do
        local eventData = {event.pull()}
        local windowEventData = window:uploadEvent(eventData)
        layout:uploadEvent(windowEventData)

        if returnVal then
            if returnVal == true then
                return
            else
                return returnVal
            end
        end
    end
end

function vkeyboard.save(screen)
    local rx, ry = graphic.getResolution(screen)
    local clear = graphic.screenshot(screen, 5, ry - 18, rx - 6, 19)

    local oldStates = {}
    for i, window in ipairs(graphic.windows) do
        if window.screen == screen then
            oldStates[window] = not not window.selected
        end
    end

    return function ()
        for window, state in pairs(oldStates) do
            window.selected = state
        end

        clear()
    end
end

local hooked = {}
local clicks = {}
local opened = {}
function vkeyboard.hook(screen, exitCallback)
    if hooked[screen] then return end
    hooked[screen] = true

    local virtualKeyboardUuid = uuid.next()
    hook.addComponentHook(screen, function (address, method, args)
        return address, method, args, function (result)
            if result[1] and method == "getKeyboards" then
                if type(result[2]) == "table" then
                    table.insert(result[2], virtualKeyboardUuid)
                end
            end
            return result
        end
    end)
    vcomponent.register(virtualKeyboardUuid, "keyboard", {}, {})

    event.hyperHook(function (...)
        local tbl = {...}

        return utils.safeExec(function ()
            if tbl[1] == "touch" then
                if tbl[2] == screen and #lastinfo.keyboards[screen] <= 1 then
                    if clicks[tbl[2]] then
                        local clk = clicks[tbl[2]]

                        if clk[1] == tbl[3] and clk[2] == tbl[4] and computer.uptime() - clk[3] <= 0.3 then
                            clk[3] = computer.uptime()
                            clk[4] = clk[4] + 1
                            if clk[4] >= 3 then
                                event.push("vkeyboard", tbl[2], tbl[6])
                            end
                        else
                            clicks[tbl[2]] = {tbl[3], tbl[4], computer.uptime(), 1}
                        end
                    else
                        clicks[tbl[2]] = {tbl[3], tbl[4], computer.uptime(), 1}
                    end
                end
            elseif tbl[1] == "vkeyboard" and tbl[2] == screen and not opened[tbl[2]] then
                opened[tbl[2]] = true

                local threads = thread.all()
                local suspended = {}
                for _, t in ipairs(threads) do
                    if t.parentData.screen == tbl[2] then
                        t:suspend()
                        table.insert(suspended, t)
                    end
                end
                local clear = vkeyboard.save(screen)

                local str = vkeyboard.input(tbl[2], nil, true)
                if str then
                    if type(str) == "table" then
                        event.push("key_down", virtualKeyboardUuid, str[1], str[2], tbl[3])
                        event.push("key_up", virtualKeyboardUuid, str[1], str[2], tbl[3])
                    else
                        event.push("softwareInsert", tbl[2], str, tbl[3])
                    end
                end
                if exitCallback then
                    exitCallback()
                end

                clear()
                for _, t in ipairs(suspended) do
                    t:resume()
                end

                opened[tbl[2]] = nil
            end

            return table.unpack(tbl)
        end, tbl, "vkeyboard error")
    end)
end

return vkeyboardsystem/lib/warnings.lua 1141 local computer = require("computer")
local gui = require("gui")
local fs = require("filesystem")
local liked = require("liked")
local warnings = {}

function warnings.list(screen)
    local list = {}

    if not liked.isRealKeyboards(screen) then
        table.insert(list, "there is no physical keyboard\nto use the virtual keyboard, tap the screen three times quickly")
    end

    if computer.totalMemory() / 1024 < 512 then
        table.insert(list, "small amount of RAM on the device\nthis can lead to problems")
    end

    local rootfs = fs.get("/")
    if (rootfs.spaceTotal() - rootfs.spaceUsed()) / 1024 < 128 then
        table.insert(list, "not enough free disk space\nthis can lead to problems")
    end

    local tmpfs = fs.get("/tmp")
    if (tmpfs.spaceTotal() - tmpfs.spaceUsed()) / 1024 < 16 then
        table.insert(list, "there is no space in the temporary filesystem\nthis can lead to problems")
    end

    if fs.exists("/data/errorlog.log") then
        table.insert(list, "there were errors in your system, please check the \"errorlog\"")
    end

    return list
end

warnings.unloadable = true
return warningssystem/logo.lua 1582 local rx, ry = 50, 16
bootloader.initScreen(gpu, screen, rx, ry)
gpu.fill(1, 1, rx, ry, " ")
gpu.set(1, 1 , [[                                                  ]])
gpu.set(1, 2 , [[--------------------------------------------------]])
gpu.set(1, 3 , [[ █     █ █   █ ████ ███     ████   █████  █     █ ]])
gpu.set(1, 4 , [[ █       █  █  █    █  █    █   █ █     █  █   █  ]])
gpu.set(1, 5 , [[ █     █ █ █   █    █  █    █   █ █     █   █ █   ]])
gpu.set(1, 6 , [[ █     █ ██    ███  █  █    ████  █     █    █    ]])
gpu.set(1, 7 , [[ █     █ █ █   █    █  █    █   █ █     █   █ █   ]])
gpu.set(1, 8 , [[ █     █ █  █  █    █  █    █   █ █     █  █   █  ]])
gpu.set(1, 9 , [[ █████ █ █   █ ████ ███     ████   █████  █     █ ]])
gpu.set(1, 10, [[             The Best Embedded System             ]])
gpu.set(1, 11, [[--------------------------------------------------]])
gpu.set(1, 12, [[                                                  ]])
gpu.set(1, 13, [[                                                  ]])
gpu.set(1, 14, [[                                                  ]])
gpu.set(1, 15, [[--------------------------------------------------]])

if text then
    while text:sub(#text, #text) == "." do
        text = text:sub(1, #text - 1)
    end
    gpu.set(math.floor(((rx / 2) - (unicode.len(text) / 2)) + 0.5) + 1, 13, text or "")
endsystem/main.lua 66 --liked
require("sysinit").init(true, ...)
require("event").wait()system/palette.plt 176 {0xFFFFFF, 0xFFB640, 0xCC6DBF, 0x99B6FF, 0xFFFF80, 0x66DB00, 0xFFB6BF, 0x4B4B4B, 0x969696, 0x3392BF, 0x996DFF, 0x3324FF, 0x996D40, 0x66B640, 0xFF2440, 0x000000, t3default=true}system/registry.dat 98 {soundEnable=false,diskSound=false,lowPowerSound=false,fullBeepDisable=false,disableRecovery=true}system/sysinfo.cfg 63 {
    name = "liked",
    versionPath = "/system/version.cfg"
}system/t2advanced.plt 226 {
    0xffffff,
    0xbfbfbf,
    0x808080,
    0x3f3f3f,
    0x000000,
    0xff0000,
    0x00ff00,
    0x0000ff,
    0xffff00,
    0x00ffff,
    0xff00ff,
    0xffc800,
    0xff8800,
    0xb500ff,
    0x00ffa0,
    0x0b6b07
}system/t3default.plt 134 {986895,1973790,2960685,3947580,4934475,5921370,6908265,7895160,8882055,9868950,10855845,11842740,12829635,13816530,14803425,15790320}system/version.cfg 2 23